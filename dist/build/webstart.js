var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/******/ (function () {
    /******/ "use strict";
    /******/ var __webpack_modules__ = ({
        /***/ "./node_modules/lezer-python/dist/index.cjs": 
        /*!**************************************************!*\
          !*** ./node_modules/lezer-python/dist/index.cjs ***!
          \**************************************************/
        /***/ (function (__unused_webpack_module, exports, __webpack_require__) {
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var lezer = __webpack_require__(/*! lezer */ "./node_modules/lezer/dist/index.cjs");
            // This file was generated by lezer-generator. You probably shouldn't edit it.
            var printKeyword = 1, indent = 162, dedent = 163, newline$1 = 164, newlineBracketed = 165, newlineEmpty = 166, eof = 167, ParenthesizedExpression = 21, TupleExpression = 47, ComprehensionExpression = 48, ArrayExpression = 52, ArrayComprehensionExpression = 55, DictionaryExpression = 56, DictionaryComprehensionExpression = 59, SetExpression = 60, SetComprehensionExpression = 61, ArgList = 63, ParamList = 121;
            var newline = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35, parenOpen = 40, dot = 46;
            var bracketed = [
                ParenthesizedExpression, TupleExpression, ComprehensionExpression, ArrayExpression, ArrayComprehensionExpression,
                DictionaryExpression, DictionaryComprehensionExpression, SetExpression, SetComprehensionExpression, ArgList, ParamList
            ];
            var cachedIndent = 0, cachedInput = null, cachedPos = 0;
            function getIndent(input, pos) {
                if (pos == cachedPos && input == cachedInput)
                    return cachedIndent;
                cachedInput = input;
                cachedPos = pos;
                return cachedIndent = getIndentInner(input, pos);
            }
            function getIndentInner(input, pos) {
                for (var indent_1 = 0;; pos++) {
                    var ch = input.get(pos);
                    if (ch == space)
                        indent_1++;
                    else if (ch == tab)
                        indent_1 += 8 - (indent_1 % 8);
                    else if (ch == newline || ch == carriageReturn || ch == hash)
                        return -1;
                    else
                        return indent_1;
                }
            }
            var newlines = new lezer.ExternalTokenizer(function (input, token, stack) {
                var next = input.get(token.start);
                if (next < 0) {
                    token.accept(eof, token.start);
                }
                else if (next != newline && next != carriageReturn)
                    ;
                else if (stack.startOf(bracketed) != null) {
                    token.accept(newlineBracketed, token.start + 1);
                }
                else if (getIndent(input, token.start + 1) < 0) {
                    token.accept(newlineEmpty, token.start + 1);
                }
                else {
                    token.accept(newline$1, token.start + 1);
                }
            }, { contextual: true, fallback: true });
            var indentation = new lezer.ExternalTokenizer(function (input, token, stack) {
                var prev = input.get(token.start - 1), depth;
                if ((prev == newline || prev == carriageReturn) &&
                    (depth = getIndent(input, token.start)) >= 0 &&
                    depth != stack.context.depth &&
                    stack.startOf(bracketed) == null)
                    token.accept(depth < stack.context.depth ? dedent : indent, token.start);
            });
            function IndentLevel(parent, depth) {
                this.parent = parent;
                this.depth = depth;
                this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4);
            }
            var topIndent = new IndentLevel(null, 0);
            var trackIndent = new lezer.ContextTracker({
                start: topIndent,
                shift: function (context, term, input, stack) {
                    return term == indent ? new IndentLevel(context, getIndent(input, stack.pos)) :
                        term == dedent ? context.parent : context;
                },
                hash: function (context) { return context.hash; }
            });
            var legacyPrint = new lezer.ExternalTokenizer(function (input, token) {
                var pos = token.start;
                for (var print_1 = "print", i = 0; i < print_1.length; i++, pos++)
                    if (input.get(pos) != print_1.charCodeAt(i))
                        return;
                var end = pos;
                if (/\w/.test(String.fromCharCode(input.get(pos))))
                    return;
                for (;; pos++) {
                    var next = input.get(pos);
                    if (next == space || next == tab)
                        continue;
                    if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash)
                        token.accept(printKeyword, end);
                    return;
                }
            });
            // This file was generated by lezer-generator. You probably shouldn't edit it.
            var spec_identifier = { __proto__: null, await: 40, or: 48, and: 50, in: 54, not: 56, is: 58, if: 64, else: 66, lambda: 70, yield: 88, from: 90, async: 98, for: 100, None: 152, True: 154, False: 154, del: 168, pass: 172, break: 176, continue: 180, return: 184, raise: 192, import: 196, as: 198, global: 202, nonlocal: 204, assert: 208, elif: 218, while: 222, try: 228, except: 230, finally: 232, with: 236, def: 240, class: 250 };
            var parser = lezer.Parser.deserialize({
                version: 13,
                states: "!?|O`Q$IXOOO%cQ$I[O'#GaOOQ$IS'#Cm'#CmOOQ$IS'#Cn'#CnO'RQ$IWO'#ClO(tQ$I[O'#G`OOQ$IS'#Ga'#GaOOQ$IS'#DR'#DROOQ$IS'#G`'#G`O)bQ$IWO'#CqO)rQ$IWO'#DbO*SQ$IWO'#DfOOQ$IS'#Ds'#DsO*gO`O'#DsO*oOpO'#DsO*wO!bO'#DtO+SO#tO'#DtO+_O&jO'#DtO+jO,UO'#DtO-lQ$I[O'#GQOOQ$IS'#GQ'#GQO'RQ$IWO'#GPO/OQ$I[O'#GPOOQ$IS'#E]'#E]O/gQ$IWO'#E^OOQ$IS'#GO'#GOO/qQ$IWO'#F}OOQ$IV'#F}'#F}O/|Q$IWO'#FPOOQ$IS'#Fr'#FrO0RQ$IWO'#FOOOQ$IV'#HZ'#HZOOQ$IV'#F|'#F|OOQ$IT'#FR'#FRQ`Q$IXOOO'RQ$IWO'#CoO0aQ$IWO'#CzO0hQ$IWO'#DOO0vQ$IWO'#GeO1WQ$I[O'#EQO'RQ$IWO'#EROOQ$IS'#ET'#ETOOQ$IS'#EV'#EVOOQ$IS'#EX'#EXO1lQ$IWO'#EZO2SQ$IWO'#E_O/|Q$IWO'#EaO2gQ$I[O'#EaO/|Q$IWO'#EdO/gQ$IWO'#EgO/gQ$IWO'#EkO/gQ$IWO'#EnO2rQ$IWO'#EpO2yQ$IWO'#EuO3UQ$IWO'#EqO/gQ$IWO'#EuO/|Q$IWO'#EwO/|Q$IWO'#E|OOQ$IS'#Cc'#CcOOQ$IS'#Cd'#CdOOQ$IS'#Ce'#CeOOQ$IS'#Cf'#CfOOQ$IS'#Cg'#CgOOQ$IS'#Ch'#ChOOQ$IS'#Cj'#CjO'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O3ZQ$IWO'#DmOOQ$IS,5:W,5:WO3nQ$IWO,5:ZO3{Q%1`O,5:ZO4QQ$I[O,59WO0aQ$IWO,59_O0aQ$IWO,59_O0aQ$IWO,59_O6pQ$IWO,59_O6uQ$IWO,59_O6|Q$IWO,59gO7TQ$IWO'#G`O8ZQ$IWO'#G_OOQ$IS'#G_'#G_OOQ$IS'#DX'#DXO8rQ$IWO,59]O'RQ$IWO,59]O9QQ$IWO,59]O9VQ$IWO,5:PO'RQ$IWO,5:POOQ$IS,59|,59|O9eQ$IWO,59|O9jQ$IWO,5:VO'RQ$IWO,5:VO'RQ$IWO,5:TOOQ$IS,5:Q,5:QO9{Q$IWO,5:QO:QQ$IWO,5:UOOOO'#FZ'#FZO:VO`O,5:_OOQ$IS,5:_,5:_OOOO'#F['#F[O:_OpO,5:_O:gQ$IWO'#DuOOOO'#F]'#F]O:wO!bO,5:`OOQ$IS,5:`,5:`OOOO'#F`'#F`O;SO#tO,5:`OOOO'#Fa'#FaO;_O&jO,5:`OOOO'#Fb'#FbO;jO,UO,5:`OOQ$IS'#Fc'#FcO;uQ$I[O,5:dO>gQ$I[O,5<kO?QQ%GlO,5<kO?qQ$I[O,5<kOOQ$IS,5:x,5:xO@YQ$IXO'#FkOAiQ$IWO,5;TOOQ$IV,5<i,5<iOAtQ$I[O'#HWOB]Q$IWO,5;kOOQ$IS-E9p-E9pOOQ$IV,5;j,5;jO3PQ$IWO'#EwOOQ$IT-E9P-E9POBeQ$I[O,59ZODlQ$I[O,59fOEVQ$IWO'#GbOEbQ$IWO'#GbO/|Q$IWO'#GbOEmQ$IWO'#DQOEuQ$IWO,59jOEzQ$IWO'#GfO'RQ$IWO'#GfO/gQ$IWO,5=POOQ$IS,5=P,5=PO/gQ$IWO'#D|OOQ$IS'#D}'#D}OFiQ$IWO'#FeOFyQ$IWO,58zOGXQ$IWO,58zO)eQ$IWO,5:jOG^Q$I[O'#GhOOQ$IS,5:m,5:mOOQ$IS,5:u,5:uOGqQ$IWO,5:yOHSQ$IWO,5:{OOQ$IS'#Fh'#FhOHbQ$I[O,5:{OHpQ$IWO,5:{OHuQ$IWO'#HYOOQ$IS,5;O,5;OOITQ$IWO'#HVOOQ$IS,5;R,5;RO3UQ$IWO,5;VO3UQ$IWO,5;YOIfQ$I[O'#H[O'RQ$IWO'#H[OIpQ$IWO,5;[O2rQ$IWO,5;[O/gQ$IWO,5;aO/|Q$IWO,5;cOIuQ$IXO'#ElOKOQ$IZO,5;]ONaQ$IWO'#H]O3UQ$IWO,5;aONlQ$IWO,5;cONqQ$IWO,5;hO!#fQ$I[O1G.hO!#mQ$I[O1G.hO!&^Q$I[O1G.hO!&hQ$I[O1G.hO!)RQ$I[O1G.hO!)fQ$I[O1G.hO!)yQ$IWO'#GnO!*XQ$I[O'#GQO/gQ$IWO'#GnO!*cQ$IWO'#GmOOQ$IS,5:X,5:XO!*kQ$IWO,5:XO!*pQ$IWO'#GoO!*{Q$IWO'#GoO!+`Q$IWO1G/uOOQ$IS'#Dq'#DqOOQ$IS1G/u1G/uOOQ$IS1G.y1G.yO!,`Q$I[O1G.yO!,gQ$I[O1G.yO0aQ$IWO1G.yO!-SQ$IWO1G/ROOQ$IS'#DW'#DWO/gQ$IWO,59qOOQ$IS1G.w1G.wO!-ZQ$IWO1G/cO!-kQ$IWO1G/cO!-sQ$IWO1G/dO'RQ$IWO'#GgO!-xQ$IWO'#GgO!-}Q$I[O1G.wO!._Q$IWO,59fO!/eQ$IWO,5=VO!/uQ$IWO,5=VO!/}Q$IWO1G/kO!0SQ$I[O1G/kOOQ$IS1G/h1G/hO!0dQ$IWO,5=QO!1ZQ$IWO,5=QO/gQ$IWO1G/oO!1xQ$IWO1G/qO!1}Q$I[O1G/qO!2_Q$I[O1G/oOOQ$IS1G/l1G/lOOQ$IS1G/p1G/pOOOO-E9X-E9XOOQ$IS1G/y1G/yOOOO-E9Y-E9YO!2oQ$IWO'#GzO/gQ$IWO'#GzO!2}Q$IWO,5:aOOOO-E9Z-E9ZOOQ$IS1G/z1G/zOOOO-E9^-E9^OOOO-E9_-E9_OOOO-E9`-E9`OOQ$IS-E9a-E9aO!3YQ%GlO1G2VO!3yQ$I[O1G2VO'RQ$IWO,5<OOOQ$IS,5<O,5<OOOQ$IS-E9b-E9bOOQ$IS,5<V,5<VOOQ$IS-E9i-E9iOOQ$IV1G0o1G0oO/|Q$IWO'#FgO!4bQ$I[O,5=rOOQ$IS1G1V1G1VO!4yQ$IWO1G1VOOQ$IS'#DS'#DSO/gQ$IWO,5<|OOQ$IS,5<|,5<|O!5OQ$IWO'#FSO!5ZQ$IWO,59lO!5cQ$IWO1G/UO!5mQ$I[O,5=QOOQ$IS1G2k1G2kOOQ$IS,5:h,5:hO!6^Q$IWO'#GPOOQ$IS,5<P,5<POOQ$IS-E9c-E9cO!6oQ$IWO1G.fOOQ$IS1G0U1G0UO!6}Q$IWO,5=SO!7_Q$IWO,5=SO/gQ$IWO1G0eO/gQ$IWO1G0eO/|Q$IWO1G0gOOQ$IS-E9f-E9fO!7pQ$IWO1G0gO!7{Q$IWO1G0gO!8QQ$IWO,5=tO!8`Q$IWO,5=tO!8nQ$IWO,5=qO!9UQ$IWO,5=qO!9gQ$IZO1G0qO!<uQ$IZO1G0tO!@QQ$IWO,5=vO!@[Q$IWO,5=vO!@dQ$I[O,5=vO/gQ$IWO1G0vO!@nQ$IWO1G0vO3UQ$IWO1G0{ONlQ$IWO1G0}OOQ$IV,5;W,5;WO!@sQ$IYO,5;WO!@xQ$IZO1G0wO!DZQ$IWO'#FoO3UQ$IWO1G0wO3UQ$IWO1G0wO!DhQ$IWO,5=wO!DuQ$IWO,5=wO/|Q$IWO,5=wOOQ$IV1G0{1G0{O!D}Q$IWO'#EyO!E`Q%1`O1G0}OOQ$IV1G1S1G1SO3UQ$IWO1G1SOOQ$IS,5=Y,5=YOOQ$IS'#Dn'#DnO/gQ$IWO,5=YO!EhQ$IWO,5=XO!E{Q$IWO,5=XOOQ$IS1G/s1G/sO!FTQ$IWO,5=ZO!FeQ$IWO,5=ZO!FmQ$IWO,5=ZO!GQQ$IWO,5=ZO!GbQ$IWO,5=ZOOQ$IS7+%a7+%aOOQ$IS7+$e7+$eO!5cQ$IWO7+$mO!ITQ$IWO1G.yO!I[Q$IWO1G.yOOQ$IS1G/]1G/]OOQ$IS,5;p,5;pO'RQ$IWO,5;pOOQ$IS7+$}7+$}O!IcQ$IWO7+$}OOQ$IS-E9S-E9SOOQ$IS7+%O7+%OO!IsQ$IWO,5=RO'RQ$IWO,5=ROOQ$IS7+$c7+$cO!IxQ$IWO7+$}O!JQQ$IWO7+%OO!JVQ$IWO1G2qOOQ$IS7+%V7+%VO!JgQ$IWO1G2qO!JoQ$IWO7+%VOOQ$IS,5;o,5;oO'RQ$IWO,5;oO!JtQ$IWO1G2lOOQ$IS-E9R-E9RO!KkQ$IWO7+%ZOOQ$IS7+%]7+%]O!KyQ$IWO1G2lO!LhQ$IWO7+%]O!LmQ$IWO1G2rO!L}Q$IWO1G2rO!MVQ$IWO7+%ZO!M[Q$IWO,5=fO!MrQ$IWO,5=fO!MrQ$IWO,5=fO!NQO!LQO'#DwO!N]OSO'#G{OOOO1G/{1G/{O!NbQ$IWO1G/{O!NjQ%GlO7+'qO# ZQ$I[O1G1jP# tQ$IWO'#FdOOQ$IS,5<R,5<ROOQ$IS-E9e-E9eOOQ$IS7+&q7+&qOOQ$IS1G2h1G2hOOQ$IS,5;n,5;nOOQ$IS-E9Q-E9QOOQ$IS7+$p7+$pO#!RQ$IWO,5<kO#!lQ$IWO,5<kO#!}Q$I[O,5;qO##bQ$IWO1G2nOOQ$IS-E9T-E9TOOQ$IS7+&P7+&PO##rQ$IWO7+&POOQ$IS7+&R7+&RO#$QQ$IWO'#HXO/|Q$IWO7+&RO#$fQ$IWO7+&ROOQ$IS,5<U,5<UO#$qQ$IWO1G3`OOQ$IS-E9h-E9hOOQ$IS,5<Q,5<QO#%PQ$IWO1G3]OOQ$IS-E9d-E9dO#%gQ$IZO7+&]O!DZQ$IWO'#FmO3UQ$IWO7+&]O3UQ$IWO7+&`O#(uQ$I[O,5<YO'RQ$IWO,5<YO#)PQ$IWO1G3bOOQ$IS-E9l-E9lO#)ZQ$IWO1G3bO3UQ$IWO7+&bO/gQ$IWO7+&bOOQ$IV7+&g7+&gO!E`Q%1`O7+&iO#)cQ$IXO1G0rOOQ$IV-E9m-E9mO3UQ$IWO7+&cO3UQ$IWO7+&cOOQ$IV,5<Z,5<ZO#+UQ$IWO,5<ZOOQ$IV7+&c7+&cO#+aQ$IZO7+&cO#.lQ$IWO,5<[O#.wQ$IWO1G3cOOQ$IS-E9n-E9nO#/UQ$IWO1G3cO#/^Q$IWO'#H_O#/lQ$IWO'#H_O/|Q$IWO'#H_OOQ$IS'#H_'#H_O#/wQ$IWO'#H^OOQ$IS,5;e,5;eO#0PQ$IWO,5;eO/gQ$IWO'#E{OOQ$IV7+&i7+&iO3UQ$IWO7+&iOOQ$IV7+&n7+&nOOQ$IS1G2t1G2tOOQ$IS,5;s,5;sO#0UQ$IWO1G2sOOQ$IS-E9V-E9VO#0iQ$IWO,5;tO#0tQ$IWO,5;tO#1XQ$IWO1G2uOOQ$IS-E9W-E9WO#1iQ$IWO1G2uO#1qQ$IWO1G2uO#2RQ$IWO1G2uO#1iQ$IWO1G2uOOQ$IS<<HX<<HXO#2^Q$I[O1G1[OOQ$IS<<Hi<<HiP#2kQ$IWO'#FUO6|Q$IWO1G2mO#2xQ$IWO1G2mO#2}Q$IWO<<HiOOQ$IS<<Hj<<HjO#3_Q$IWO7+(]OOQ$IS<<Hq<<HqO#3oQ$I[O1G1ZP#4`Q$IWO'#FTO#4mQ$IWO7+(^O#4}Q$IWO7+(^O#5VQ$IWO<<HuO#5[Q$IWO7+(WOOQ$IS<<Hw<<HwO#6RQ$IWO,5;rO'RQ$IWO,5;rOOQ$IS-E9U-E9UOOQ$IS<<Hu<<HuOOQ$IS,5;x,5;xO/gQ$IWO,5;xO#6WQ$IWO1G3QOOQ$IS-E9[-E9[O#6nQ$IWO1G3QOOOO'#F_'#F_O#6|O!LQO,5:cOOOO,5=g,5=gOOOO7+%g7+%gO#7XQ$IWO1G2VO#7rQ$IWO1G2VP'RQ$IWO'#FVO/gQ$IWO<<IkO#8TQ$IWO,5=sO#8fQ$IWO,5=sO/|Q$IWO,5=sO#8wQ$IWO<<ImOOQ$IS<<Im<<ImO/|Q$IWO<<ImP/|Q$IWO'#FjP/gQ$IWO'#FfOOQ$IV-E9k-E9kO3UQ$IWO<<IwOOQ$IV,5<X,5<XO3UQ$IWO,5<XOOQ$IV<<Iw<<IwOOQ$IV<<Iz<<IzO#8|Q$I[O1G1tP#9WQ$IWO'#FnO#9_Q$IWO7+(|O#9iQ$IZO<<I|O3UQ$IWO<<I|OOQ$IV<<JT<<JTO3UQ$IWO<<JTOOQ$IV'#Fl'#FlO#<tQ$IZO7+&^OOQ$IV<<I}<<I}O#>mQ$IZO<<I}OOQ$IV1G1u1G1uO/|Q$IWO1G1uO3UQ$IWO<<I}O/|Q$IWO1G1vP/gQ$IWO'#FpO#AxQ$IWO7+(}O#BVQ$IWO7+(}OOQ$IS'#Ez'#EzO/gQ$IWO,5=yO#B_Q$IWO,5=yOOQ$IS,5=y,5=yO#BjQ$IWO,5=xO#B{Q$IWO,5=xOOQ$IS1G1P1G1POOQ$IS,5;g,5;gP#CTQ$IWO'#FXO#CeQ$IWO1G1`O#CxQ$IWO1G1`O#DYQ$IWO1G1`P#DeQ$IWO'#FYO#DrQ$IWO7+(aO#ESQ$IWO7+(aO#ESQ$IWO7+(aO#E[Q$IWO7+(aO#ElQ$IWO7+(XO6|Q$IWO7+(XOOQ$ISAN>TAN>TO#FVQ$IWO<<KxOOQ$ISAN>aAN>aO/gQ$IWO1G1^O#FgQ$I[O1G1^P#FqQ$IWO'#FWOOQ$IS1G1d1G1dP#GOQ$IWO'#F^O#G]Q$IWO7+(lOOOO-E9]-E9]O#GsQ$IWO7+'qOOQ$ISAN?VAN?VO#H^Q$IWO,5<TO#HrQ$IWO1G3_OOQ$IS-E9g-E9gO#ITQ$IWO1G3_OOQ$ISAN?XAN?XO#IfQ$IWOAN?XOOQ$IVAN?cAN?cOOQ$IV1G1s1G1sO3UQ$IWOAN?hO#IkQ$IZOAN?hOOQ$IVAN?oAN?oOOQ$IV-E9j-E9jOOQ$IV<<Ix<<IxO3UQ$IWOAN?iO3UQ$IWO7+'aOOQ$IVAN?iAN?iOOQ$IS7+'b7+'bO#LvQ$IWO<<LiOOQ$IS1G3e1G3eO/gQ$IWO1G3eOOQ$IS,5<],5<]O#MTQ$IWO1G3dOOQ$IS-E9o-E9oO#MfQ$IWO7+&zO#MvQ$IWO7+&zOOQ$IS7+&z7+&zO#NRQ$IWO<<K{O#NcQ$IWO<<K{O#NcQ$IWO<<K{O#NkQ$IWO'#GiOOQ$IS<<Ks<<KsO#NuQ$IWO<<KsOOQ$IS7+&x7+&xO/|Q$IWO1G1oP/|Q$IWO'#FiO$ `Q$IWO7+(yO$ qQ$IWO7+(yOOQ$ISG24sG24sOOQ$IVG25SG25SO3UQ$IWOG25SOOQ$IVG25TG25TOOQ$IV<<J{<<J{OOQ$IS7+)P7+)PP$!SQ$IWO'#FqOOQ$IS<<Jf<<JfO$!bQ$IWO<<JfO$!rQ$IWOANAgO$#SQ$IWOANAgO$#[Q$IWO'#GjOOQ$IS'#Gj'#GjO0hQ$IWO'#DaO$#uQ$IWO,5=TOOQ$ISANA_ANA_OOQ$IS7+'Z7+'ZO$$^Q$IWO<<LeOOQ$IVLD*nLD*nOOQ$ISAN@QAN@QO$$oQ$IWOG27RO$%PQ$IWO,59{OOQ$IS1G2o1G2oO#NkQ$IWO1G/gOOQ$IS7+%R7+%RO6|Q$IWO'#CzO6|Q$IWO,59_O6|Q$IWO,59_O6|Q$IWO,59_O$%UQ$I[O,5<kO6|Q$IWO1G.yO/gQ$IWO1G/UO/gQ$IWO7+$mP$%iQ$IWO'#FdO'RQ$IWO'#GPO$%vQ$IWO,59_O$%{Q$IWO,59_O$&SQ$IWO,59jO$&XQ$IWO1G/RO0hQ$IWO'#DOO6|Q$IWO,59g",
                stateData: "$&o~O$oOS$lOS$kOSQOS~OPhOTeOdsOfXOltOp!SOsuO|vO}!PO!R!VO!S!UO!VYO!ZZO!fdO!mdO!ndO!odO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO$jqO$zQO${QO%PRO%QVO%e[O%f]O%i^O%l_O%r`O%uaO%wbO~OT!aO]!aO_!bOf!iO!V!kO!d!lO$u![O$v!]O$w!^O$x!_O$y!_O$z!`O${!`O$|!aO$}!aO%O!aO~Oh%TXi%TXj%TXk%TXl%TXm%TXp%TXw%TXx%TX!s%TX#^%TX$j%TX$m%TX%V%TX!O%TX!R%TX!S%TX%W%TX!W%TX![%TX}%TX#V%TXq%TX!j%TX~P$_OdsOfXO!VYO!ZZO!fdO!mdO!ndO!odO$zQO${QO%PRO%QVO%e[O%f]O%i^O%l_O%r`O%uaO%wbO~Ow%SXx%SX#^%SX$j%SX$m%SX%V%SX~Oh!oOi!pOj!nOk!nOl!qOm!rOp!sO!s%SX~P(`OT!yOl-fOs-tO|vO~P'ROT!|Ol-fOs-tO!W!}O~P'ROT#QO_#ROl-fOs-tO![#SO~P'RO%g#VO%h#XO~O%j#YO%k#XO~O!Z#[O%m#]O%q#_O~O!Z#[O%s#`O%t#_O~O!Z#[O%h#_O%v#bO~O!Z#[O%k#_O%x#dO~OT$tX]$tX_$tXf$tXh$tXi$tXj$tXk$tXl$tXm$tXp$tXw$tX!V$tX!d$tX$u$tX$v$tX$w$tX$x$tX$y$tX$z$tX${$tX$|$tX$}$tX%O$tX!O$tX!R$tX!S$tX~O%e[O%f]O%i^O%l_O%r`O%uaO%wbOx$tX!s$tX#^$tX$j$tX$m$tX%V$tX%W$tX!W$tX![$tX}$tX#V$tXq$tX!j$tX~P+uOw#iOx$sX!s$sX#^$sX$j$sX$m$sX%V$sX~Ol-fOs-tO~P'RO#^#lO$j#nO$m#nO~O%QVO~O!R#sO#l!YO#q!ZO#tlO~OltO~P'ROT#xO_#yO%QVOxtP~OT#}Ol-fOs-tO}$OO~P'ROx$QO!s$VO%V$RO#^!tX$j!tX$m!tX~OT#}Ol-fOs-tO#^!}X$j!}X$m!}X~P'ROl-fOs-tO#^#RX$j#RX$m#RX~P'RO!d$]O!m$]O%QVO~OT$gO~P'RO!S$iO#j$jO#l$kO~Ox$lO~OT$zO_$zOl-fOs-tO!O$|O~P'ROl-fOs-tOx%PO~P'RO%d%RO~O_!bOf!iO!V!kO!d!lOT`a]`ah`ai`aj`ak`al`am`ap`aw`ax`a!s`a#^`a$j`a$m`a$u`a$v`a$w`a$x`a$y`a$z`a${`a$|`a$}`a%O`a%V`a!O`a!R`a!S`a%W`a!W`a![`a}`a#V`aq`a!j`a~Ok%WO~Ol%WO~P'ROl-fO~P'ROh-hOi-iOj-gOk-gOl-pOm-qOp-uO!O%SX!R%SX!S%SX%W%SX!W%SX![%SX}%SX#V%SX!j%SX~P(`O%W%YOw%RX!O%RX!R%RX!S%RX!W%RXx%RX~Ow%]O!O%[O!R%aO!S%`O~O!O%[O~Ow%dO!R%aO!S%`O!W%_X~O!W%hO~Ow%iOx%kO!R%aO!S%`O![%YX~O![%oO~O![%pO~O%g#VO%h%rO~O%j#YO%k%rO~OT%uOl-fOs-tO|vO~P'RO!Z#[O%m#]O%q%xO~O!Z#[O%s#`O%t%xO~O!Z#[O%h%xO%v#bO~O!Z#[O%k%xO%x#dO~OT!la]!la_!laf!lah!lai!laj!lak!lal!lam!lap!law!lax!la!V!la!d!la!s!la#^!la$j!la$m!la$u!la$v!la$w!la$x!la$y!la$z!la${!la$|!la$}!la%O!la%V!la!O!la!R!la!S!la%W!la!W!la![!la}!la#V!laq!la!j!la~P#vOw%}Ox$sa!s$sa#^$sa$j$sa$m$sa%V$sa~P$_OT&POltOsuOx$sa!s$sa#^$sa$j$sa$m$sa%V$sa~P'ROw%}Ox$sa!s$sa#^$sa$j$sa$m$sa%V$sa~OPhOTeOltOsuO|vO}!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#^$_X$j$_X$m$_X~P'RO#^#lO$j&UO$m&UO~O!d&VOf%zX$j%zX#V%zX#^%zX$m%zX#U%zX~Of!iO$j&XO~Ohcaicajcakcalcamcapcawcaxca!sca#^ca$jca$mca%Vca!Oca!Rca!Sca%Wca!Wca![ca}ca#Vcaqca!jca~P$_Opnawnaxna#^na$jna$mna%Vna~Oh!oOi!pOj!nOk!nOl!qOm!rO!sna~PDTO%V&ZOw%UXx%UX~O%QVOw%UXx%UX~Ow&^OxtX~Ox&`O~Ow%iO#^%YX$j%YX$m%YX!O%YXx%YX![%YX!j%YX%V%YX~OT-oOl-fOs-tO|vO~P'RO%V$RO#^Sa$jSa$mSa~O%V$RO~Ow&iO#^%[X$j%[X$m%[Xk%[X~P$_Ow&lO}&kO#^#Ra$j#Ra$m#Ra~O#V&mO#^#Ta$j#Ta$m#Ta~O!d$]O!m$]O#U&oO%QVO~O#U&oO~Ow&qO#^%|X$j%|X$m%|X~Ow&sO#^%yX$j%yX$m%yXx%yX~Ow&wOk&OX~P$_Ok&zO~OPhOTeOltOsuO|vO}!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO$j'PO~P'ROq'TO#g'RO#h'SOP#eaT#ead#eaf#eal#eap#eas#ea|#ea}#ea!R#ea!S#ea!V#ea!Z#ea!f#ea!m#ea!n#ea!o#ea!v#ea!x#ea!z#ea!|#ea#O#ea#S#ea#U#ea#X#ea#Y#ea#[#ea#c#ea#f#ea#j#ea#l#ea#q#ea#t#ea$g#ea$j#ea$z#ea${#ea%P#ea%Q#ea%e#ea%f#ea%i#ea%l#ea%r#ea%u#ea%w#ea$i#ea$m#ea~Ow'UO#V'WOx&PX~Of'YO~Of!iOx$lO~OT!aO]!aO_!bOf!iO!V!kO!d!lO$w!^O$x!_O$y!_O$z!`O${!`O$|!aO$}!aO%O!aOhUiiUijUikUilUimUipUiwUixUi!sUi#^Ui$jUi$mUi$uUi%VUi!OUi!RUi!SUi%WUi!WUi![Ui}Ui#VUiqUi!jUi~O$v!]O~PNyO$vUi~PNyOT!aO]!aO_!bOf!iO!V!kO!d!lO$z!`O${!`O$|!aO$}!aO%O!aOhUiiUijUikUilUimUipUiwUixUi!sUi#^Ui$jUi$mUi$uUi$vUi$wUi%VUi!OUi!RUi!SUi%WUi!WUi![Ui}Ui#VUiqUi!jUi~O$x!_O$y!_O~P!#tO$xUi$yUi~P!#tO_!bOf!iO!V!kO!d!lOhUiiUijUikUilUimUipUiwUixUi!sUi#^Ui$jUi$mUi$uUi$vUi$wUi$xUi$yUi$zUi${Ui%VUi!OUi!RUi!SUi%WUi!WUi![Ui}Ui#VUiqUi!jUi~OT!aO]!aO$|!aO$}!aO%O!aO~P!&rOTUi]Ui$|Ui$}Ui%OUi~P!&rO!R%aO!S%`Ow%bX!O%bX~O%V'_O%W'_O~P+uOw'aO!O%aX~O!O'cO~Ow'dOx'fO!W%cX~Ol-fOs-tOw'dOx'gO!W%cX~P'RO!W'iO~Oj!nOk!nOl!qOm!rOhgipgiwgixgi!sgi#^gi$jgi$mgi%Vgi~Oi!pO~P!+eOigi~P!+eOh-hOi-iOj-gOk-gOl-pOm-qO~Oq'kO~P!,nOT'pOl-fOs-tO!O'qO~P'ROw'rO!O'qO~O!O'tO~O!S'vO~Ow'rO!O'wO!R%aO!S%`O~P$_Oh-hOi-iOj-gOk-gOl-pOm-qO!Ona!Rna!Sna%Wna!Wna![na}na#Vnaqna!jna~PDTOT'pOl-fOs-tO!W%_a~P'ROw'zO!W%_a~O!W'{O~Ow'zO!R%aO!S%`O!W%_a~P$_OT(POl-fOs-tO![%Ya#^%Ya$j%Ya$m%Ya!O%Yax%Ya!j%Ya%V%Ya~P'ROw(QO![%Ya#^%Ya$j%Ya$m%Ya!O%Yax%Ya!j%Ya%V%Ya~O![(TO~Ow(QO!R%aO!S%`O![%Ya~P$_Ow(WO!R%aO!S%`O![%`a~P$_Ow(ZOx%nX![%nX!j%nX~Ox(^O![(`O!j(aO~OT&POltOsuOx$si!s$si#^$si$j$si$m$si%V$si~P'ROw(bOx$si!s$si#^$si$j$si$m$si%V$si~O!d&VOf%za$j%za#V%za#^%za$m%za#U%za~O$j(gO~OT#xO_#yO%QVO~Ow&^Oxta~OltOsuO~P'ROw(QO#^%Ya$j%Ya$m%Ya!O%Yax%Ya![%Ya!j%Ya%V%Ya~P$_Ow(lO#^$sX$j$sX$m$sX%V$sX~O%V$RO#^Si$jSi$mSi~O#^%[a$j%[a$m%[ak%[a~P'ROw(oO#^%[a$j%[a$m%[ak%[a~OT(sOf(uO%QVO~O#U(vO~O%QVO#^%|a$j%|a$m%|a~Ow(xO#^%|a$j%|a$m%|a~Ol-fOs-tO#^%ya$j%ya$m%yax%ya~P'ROw({O#^%ya$j%ya$m%yax%ya~Oq)PO#a)OOP#_iT#_id#_if#_il#_ip#_is#_i|#_i}#_i!R#_i!S#_i!V#_i!Z#_i!f#_i!m#_i!n#_i!o#_i!v#_i!x#_i!z#_i!|#_i#O#_i#S#_i#U#_i#X#_i#Y#_i#[#_i#c#_i#f#_i#j#_i#l#_i#q#_i#t#_i$g#_i$j#_i$z#_i${#_i%P#_i%Q#_i%e#_i%f#_i%i#_i%l#_i%r#_i%u#_i%w#_i$i#_i$m#_i~Oq)QOP#biT#bid#bif#bil#bip#bis#bi|#bi}#bi!R#bi!S#bi!V#bi!Z#bi!f#bi!m#bi!n#bi!o#bi!v#bi!x#bi!z#bi!|#bi#O#bi#S#bi#U#bi#X#bi#Y#bi#[#bi#c#bi#f#bi#j#bi#l#bi#q#bi#t#bi$g#bi$j#bi$z#bi${#bi%P#bi%Q#bi%e#bi%f#bi%i#bi%l#bi%r#bi%u#bi%w#bi$i#bi$m#bi~OT)SOk&Oa~P'ROw)TOk&Oa~Ow)TOk&Oa~P$_Ok)XO~O$h)[O~Oq)_O#g'RO#h)^OP#eiT#eid#eif#eil#eip#eis#ei|#ei}#ei!R#ei!S#ei!V#ei!Z#ei!f#ei!m#ei!n#ei!o#ei!v#ei!x#ei!z#ei!|#ei#O#ei#S#ei#U#ei#X#ei#Y#ei#[#ei#c#ei#f#ei#j#ei#l#ei#q#ei#t#ei$g#ei$j#ei$z#ei${#ei%P#ei%Q#ei%e#ei%f#ei%i#ei%l#ei%r#ei%u#ei%w#ei$i#ei$m#ei~Ol-fOs-tOx$lO~P'ROl-fOs-tOx&Pa~P'ROw)eOx&Pa~OT)iO_)jO!O)mO$|)kO%QVO~Ox$lO&S)oO~OT$zO_$zOl-fOs-tO!O%aa~P'ROw)uO!O%aa~Ol-fOs-tOx)xO!W%ca~P'ROw)yO!W%ca~Ol-fOs-tOw)yOx)|O!W%ca~P'ROl-fOs-tOw)yO!W%ca~P'ROw)yOx)|O!W%ca~Oj-gOk-gOl-pOm-qOhgipgiwgi!Ogi!Rgi!Sgi%Wgi!Wgixgi![gi#^gi$jgi$mgi}gi#Vgiqgi!jgi%Vgi~Oi-iO~P!GmOigi~P!GmOT'pOl-fOs-tO!O*RO~P'ROk*TO~Ow*VO!O*RO~O!O*WO~OT'pOl-fOs-tO!W%_i~P'ROw*XO!W%_i~O!W*YO~OT(POl-fOs-tO![%Yi#^%Yi$j%Yi$m%Yi!O%Yix%Yi!j%Yi%V%Yi~P'ROw*]O!R%aO!S%`O![%`i~Ow*`O![%Yi#^%Yi$j%Yi$m%Yi!O%Yix%Yi!j%Yi%V%Yi~O![*aO~O_*cOl-fOs-tO![%`i~P'ROw*]O![%`i~O![*eO~OT*gOl-fOs-tOx%na![%na!j%na~P'ROw*hOx%na![%na!j%na~O!Z#[O%p*kO![!kX~O![*mO~Ox(^O![*nO~OT&POltOsuOx$sq!s$sq#^$sq$j$sq$m$sq%V$sq~P'ROw$Wix$Wi!s$Wi#^$Wi$j$Wi$m$Wi%V$Wi~P$_OT&POltOsuO~P'ROT&POl-fOs-tO#^$sa$j$sa$m$sa%V$sa~P'ROw*oO#^$sa$j$sa$m$sa%V$sa~Ow#ya#^#ya$j#ya$m#yak#ya~P$_O#^%[i$j%[i$m%[ik%[i~P'ROw*rO#^#Rq$j#Rq$m#Rq~Ow*sO#V*uO#^%{X$j%{X$m%{X!O%{X~OT*wOf*xO%QVO~O%QVO#^%|i$j%|i$m%|i~Ol-fOs-tO#^%yi$j%yi$m%yix%yi~P'ROq*|O#a)OOP#_qT#_qd#_qf#_ql#_qp#_qs#_q|#_q}#_q!R#_q!S#_q!V#_q!Z#_q!f#_q!m#_q!n#_q!o#_q!v#_q!x#_q!z#_q!|#_q#O#_q#S#_q#U#_q#X#_q#Y#_q#[#_q#c#_q#f#_q#j#_q#l#_q#q#_q#t#_q$g#_q$j#_q$z#_q${#_q%P#_q%Q#_q%e#_q%f#_q%i#_q%l#_q%r#_q%u#_q%w#_q$i#_q$m#_q~Ok$baw$ba~P$_OT)SOk&Oi~P'ROw+TOk&Oi~OPhOTeOltOp!SOsuO|vO}!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO~P'ROw+_Ox$lO#V+_O~O#h+`OP#eqT#eqd#eqf#eql#eqp#eqs#eq|#eq}#eq!R#eq!S#eq!V#eq!Z#eq!f#eq!m#eq!n#eq!o#eq!v#eq!x#eq!z#eq!|#eq#O#eq#S#eq#U#eq#X#eq#Y#eq#[#eq#c#eq#f#eq#j#eq#l#eq#q#eq#t#eq$g#eq$j#eq$z#eq${#eq%P#eq%Q#eq%e#eq%f#eq%i#eq%l#eq%r#eq%u#eq%w#eq$i#eq$m#eq~O#V+aOw$dax$da~Ol-fOs-tOx&Pi~P'ROw+cOx&Pi~Ox$QO%V+eOw&RX!O&RX~O%QVOw&RX!O&RX~Ow+iO!O&QX~O!O+kO~OT$zO_$zOl-fOs-tO!O%ai~P'ROx+nOw#|a!W#|a~Ol-fOs-tOx+oOw#|a!W#|a~P'ROl-fOs-tOx)xO!W%ci~P'ROw+rO!W%ci~Ol-fOs-tOw+rO!W%ci~P'ROw+rOx+uO!W%ci~Ow#xi!O#xi!W#xi~P$_OT'pOl-fOs-tO~P'ROk+wO~OT'pOl-fOs-tO!O+xO~P'ROT'pOl-fOs-tO!W%_q~P'ROw#wi![#wi#^#wi$j#wi$m#wi!O#wix#wi!j#wi%V#wi~P$_OT(POl-fOs-tO~P'RO_*cOl-fOs-tO![%`q~P'ROw+yO![%`q~O![+zO~OT(POl-fOs-tO![%Yq#^%Yq$j%Yq$m%Yq!O%Yqx%Yq!j%Yq%V%Yq~P'ROx+{O~OT*gOl-fOs-tOx%ni![%ni!j%ni~P'ROw,QOx%ni![%ni!j%ni~O!Z#[O%p*kO![!ka~OT&POl-fOs-tO#^$si$j$si$m$si%V$si~P'ROw,SO#^$si$j$si$m$si%V$si~O%QVO#^%{a$j%{a$m%{a!O%{a~Ow,VO#^%{a$j%{a$m%{a!O%{a~O!O,YO~Ok$biw$bi~P$_OT)SO~P'ROT)SOk&Oq~P'ROq,^OP#dyT#dyd#dyf#dyl#dyp#dys#dy|#dy}#dy!R#dy!S#dy!V#dy!Z#dy!f#dy!m#dy!n#dy!o#dy!v#dy!x#dy!z#dy!|#dy#O#dy#S#dy#U#dy#X#dy#Y#dy#[#dy#c#dy#f#dy#j#dy#l#dy#q#dy#t#dy$g#dy$j#dy$z#dy${#dy%P#dy%Q#dy%e#dy%f#dy%i#dy%l#dy%r#dy%u#dy%w#dy$i#dy$m#dy~OPhOTeOltOp!SOsuO|vO}!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO$i,bO$m,bO~P'RO#h,cOP#eyT#eyd#eyf#eyl#eyp#eys#ey|#ey}#ey!R#ey!S#ey!V#ey!Z#ey!f#ey!m#ey!n#ey!o#ey!v#ey!x#ey!z#ey!|#ey#O#ey#S#ey#U#ey#X#ey#Y#ey#[#ey#c#ey#f#ey#j#ey#l#ey#q#ey#t#ey$g#ey$j#ey$z#ey${#ey%P#ey%Q#ey%e#ey%f#ey%i#ey%l#ey%r#ey%u#ey%w#ey$i#ey$m#ey~Ol-fOs-tOx&Pq~P'ROw,gOx&Pq~O%V+eOw&Ra!O&Ra~OT)iO_)jO$|)kO%QVO!O&Qa~Ow,kO!O&Qa~OT$zO_$zOl-fOs-tO~P'ROl-fOs-tOx,mOw#|i!W#|i~P'ROl-fOs-tOw#|i!W#|i~P'ROx,mOw#|i!W#|i~Ol-fOs-tOx)xO~P'ROl-fOs-tOx)xO!W%cq~P'ROw,pO!W%cq~Ol-fOs-tOw,pO!W%cq~P'ROp,sO!R%aO!S%`O!O%Zq!W%Zq![%Zqw%Zq~P!,nO_*cOl-fOs-tO![%`y~P'ROw#zi![#zi~P$_O_*cOl-fOs-tO~P'ROT*gOl-fOs-tO~P'ROT*gOl-fOs-tOx%nq![%nq!j%nq~P'ROT&POl-fOs-tO#^$sq$j$sq$m$sq%V$sq~P'RO#V,wOw$]a#^$]a$j$]a$m$]a!O$]a~O%QVO#^%{i$j%{i$m%{i!O%{i~Ow,yO#^%{i$j%{i$m%{i!O%{i~O!O,{O~Oq,}OP#d!RT#d!Rd#d!Rf#d!Rl#d!Rp#d!Rs#d!R|#d!R}#d!R!R#d!R!S#d!R!V#d!R!Z#d!R!f#d!R!m#d!R!n#d!R!o#d!R!v#d!R!x#d!R!z#d!R!|#d!R#O#d!R#S#d!R#U#d!R#X#d!R#Y#d!R#[#d!R#c#d!R#f#d!R#j#d!R#l#d!R#q#d!R#t#d!R$g#d!R$j#d!R$z#d!R${#d!R%P#d!R%Q#d!R%e#d!R%f#d!R%i#d!R%l#d!R%r#d!R%u#d!R%w#d!R$i#d!R$m#d!R~Ol-fOs-tOx&Py~P'ROT)iO_)jO$|)kO%QVO!O&Qi~Ol-fOs-tOw#|q!W#|q~P'ROx-TOw#|q!W#|q~Ol-fOs-tOx)xO!W%cy~P'ROw-UO!W%cy~Ol-fOs-YO~P'ROp,sO!R%aO!S%`O!O%Zy!W%Zy![%Zyw%Zy~P!,nO%QVO#^%{q$j%{q$m%{q!O%{q~Ow-^O#^%{q$j%{q$m%{q!O%{q~OT)iO_)jO$|)kO%QVO~Ol-fOs-tOw#|y!W#|y~P'ROl-fOs-tOx)xO!W%c!R~P'ROw-aO!W%c!R~Op%^X!O%^X!R%^X!S%^X!W%^X![%^Xw%^X~P!,nOp,sO!R%aO!S%`O!O%]a!W%]a![%]aw%]a~O%QVO#^%{y$j%{y$m%{y!O%{y~Ol-fOs-tOx)xO!W%c!Z~P'ROx-dO~Ow*oO#^$sa$j$sa$m$sa%V$sa~P$_OT&POl-fOs-tO~P'ROk-kO~Ol-kO~P'ROx-lO~Oq-mO~P!,nO%f%i%u%w%e!Z%m%s%v%x%l%r%l%Q~",
                goto: "!,u&SPPPP&TP&])n*T*k+S+l,VP,qP&]-_-_&]P&]P0pPPPPPP0p3`PP3`P5l5u:yPP:|;[;_PPP&]&]PP;k&]PP&]&]PP&]&]&]&];o<c&]P<fP<i<i@OP@d&]PPP@h@n&TP&T&TP&TP&TP&TP&TP&T&T&TP&TPP&TPP&TP@tP@{ARP@{P@{@{PPP@{PBzPCTCZCaBzP@{CgPCnCtCzDWDjDpDzEQEnEtEzFQF[FbFhFnFtFzG^GhGnGtGzHUH[HbHhHnHxIOIYI`PPPPPPPPPIiIqIzJUJaPPPPPPPPPPPPNv! `!%n!(zPP!)S!)b!)k!*a!*W!*j!*p!*s!*v!*y!+RPPPPPPPPPP!+U!+XPPPPPPPPP!+_!+k!+w!,T!,W!,^!,d!,j!,m]iOr#l$l)[+Z'odOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!k!n!o!p!r!s!y!|#Q#R#[#i#l#}$O$Q$S$V$g$i$j$l$z%P%W%Z%]%`%d%i%k%u%}&P&[&`&i&k&l&s&w&z'R'U'`'a'd'f'g'k'p'r'v'z(P(Q(W(Z(b(d(l(o({)O)S)T)X)[)e)o)u)x)y)|*S*T*V*X*[*]*`*c*g*h*o*q*r*z+S+T+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,g,i,m,p,s-T-U-a-d-f-g-h-i-k-l-m-n-o-q-uw!cP#h#u$W$f%b%g%m%n&a&y(c(n)R*Q*Z+R+|-jy!dP#h#u$W$f$r%b%g%m%n&a&y(c(n)R*Q*Z+R+|-j{!eP#h#u$W$f$r$s%b%g%m%n&a&y(c(n)R*Q*Z+R+|-j}!fP#h#u$W$f$r$s$t%b%g%m%n&a&y(c(n)R*Q*Z+R+|-j!P!gP#h#u$W$f$r$s$t$u%b%g%m%n&a&y(c(n)R*Q*Z+R+|-j!R!hP#h#u$W$f$r$s$t$u$v%b%g%m%n&a&y(c(n)R*Q*Z+R+|-j!V!hP!m#h#u$W$f$r$s$t$u$v$w%b%g%m%n&a&y(c(n)R*Q*Z+R+|-j'oSOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!k!n!o!p!r!s!y!|#Q#R#[#i#l#}$O$Q$S$V$g$i$j$l$z%P%W%Z%]%`%d%i%k%u%}&P&[&`&i&k&l&s&w&z'R'U'`'a'd'f'g'k'p'r'v'z(P(Q(W(Z(b(d(l(o({)O)S)T)X)[)e)o)u)x)y)|*S*T*V*X*[*]*`*c*g*h*o*q*r*z+S+T+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,g,i,m,p,s-T-U-a-d-f-g-h-i-k-l-m-n-o-q-u&ZUOXYZhrtv|}!R!S!T!X!i!k!n!o!p!r!s#[#i#l$O$Q$S$V$j$l$z%P%W%Z%]%d%i%k%u%}&[&`&k&l&s&z'R'U'`'a'd'f'g'k'r'z(Q(W(Z(b(d(l({)O)X)[)e)o)u)x)y)|*S*T*V*X*[*]*`*g*h*o*r*z+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,g,i,m,p,s-T-U-a-d-f-g-h-i-k-l-m-n-q-u%eWOXYZhrv|}!R!S!T!X!i!k#[#i#l$O$Q$S$V$j$l$z%P%Z%]%d%i%k%u%}&[&`&k&l&s&z'R'U'`'a'd'f'g'k'r'z(Q(W(Z(b(d(l({)O)X)[)e)o)u)x)y)|*S*V*X*[*]*`*g*h*o*r*z+Z+b+c+f+m+n+o+q+r+u+y+{+},P,Q,S,g,i,m,p-T-U-a-l-m-nQ#{uQ-b-YR-r-t'fdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!k!n!o!p!r!s!y!|#Q#R#[#i#l#}$O$Q$S$V$g$i$j$l$z%P%W%Z%]%`%d%i%k%u%}&P&[&`&i&k&l&s&w&z'R'U'`'d'f'g'k'p'r'v'z(P(Q(W(Z(b(d(l(o({)O)S)T)X)[)e)o)x)y)|*S*T*V*X*[*]*`*c*g*h*o*q*r*z+S+T+Z+b+c+f+n+o+q+r+u+w+y+{+},P,Q,S,g,i,m,p,s-T-U-a-d-f-g-h-i-k-l-m-n-o-q-uW#ol!O!P$^W#wu&^-Y-tQ$`!QQ$p!YQ$q!ZW$y!i'a)u+mS&]#x#yQ&}$kQ(e&VQ(s&mW(t&o(u(v*xU(w&q(x*yQ)g'WW)h'Y+i,k-RS+h)i)jY,U*s,V,x,y-^Q,X*uQ,d+_Q,f+aR-],wR&[#wi!vXY!S!T%]%d'r'z)O*S*V*XR%Z!uQ!zXQ%v#[Q&e$SR&h$VT-X,s-d!U!jP!m#h#u$W$f$r$s$t$u$v$w%b%g%m%n&a&y(c(n)R*Q*Z+R+|-jQ&Y#pR']$qR'`$yR%S!l'ncOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!k!n!o!p!r!s!y!|#Q#R#[#i#l#}$O$Q$S$V$g$i$j$l$z%P%W%Z%]%`%d%i%k%u%}&P&[&`&i&k&l&s&w&z'R'U'`'a'd'f'g'k'p'r'v'z(P(Q(W(Z(b(d(l(o({)O)S)T)X)[)e)o)u)x)y)|*S*T*V*X*[*]*`*c*g*h*o*q*r*z+S+T+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,g,i,m,p,s-T-U-a-d-f-g-h-i-k-l-m-n-o-q-uT#fc#gS#]_#^S#``#aS#ba#cS#db#eT*k(^*lT(_%v(aQ$UwR+g)hX$Sw$T$U&gZkOr$l)[+ZXoOr)[+ZQ$m!WQ&u$dQ&v$eQ'X$oQ'[$qQ)Y&|Q)`'RQ)b'SQ)c'TQ)p'ZQ)r']Q*})OQ+P)PQ+Q)QQ+U)WS+W)Z)qQ+[)^Q+])_Q+^)aQ,[*|Q,]+OQ,_+VQ,`+XQ,e+`Q,|,^Q-O,cQ-P,dR-_,}WoOr)[+ZR#rnQ'Z$pR)Z&}Q+f)hR,i+gQ)q'ZR+X)ZZmOnr)[+ZQrOR#trQ&_#zR(j&_S%j#P#|S(R%j(UT(U%m&aQ%^!xQ%e!{W's%^%e'x'|Q'x%bR'|%gQ&j$WR(p&jQ(X%nQ*^(ST*d(X*^Q'b${R)v'bS'e%O%PY)z'e){+s,q-VU){'f'g'hU+s)|)}*OS,q+t+uR-V,rQ#W]R%q#WQ#Z^R%s#ZQ#^_R%w#^Q([%tS*i([*jR*j(]Q*l(^R,R*lQ#a`R%y#aQ#caR%z#cQ#ebR%{#eQ#gcR%|#gQ#jfQ&O#hW&R#j&O(m*pQ(m&dR*p-jQ$TwS&f$T&gR&g$UQ&t$bR(|&tQ&W#oR(f&WQ$^!PR&n$^Q*t(tS,W*t,zR,z,XQ&r$`R(y&rQ#mjR&T#mQ+Z)[R,a+ZQ(}&uR*{(}Q&x$fS)U&x)VR)V&yQ'Q$mR)]'QQ'V$nS)f'V+dR+d)gQ+j)lR,l+jWnOr)[+ZR#qnSqOrT+Y)[+ZWpOr)[+ZR'O$lYjOr$l)[+ZR&S#l[wOr#l$l)[+ZR&e$S&YPOXYZhrtv|}!R!S!T!X!i!k!n!o!p!r!s#[#i#l$O$Q$S$V$j$l$z%P%W%Z%]%d%i%k%u%}&[&`&k&l&s&z'R'U'`'a'd'f'g'k'r'z(Q(W(Z(b(d(l({)O)X)[)e)o)u)x)y)|*S*T*V*X*[*]*`*g*h*o*r*z+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,g,i,m,p,s-T-U-a-d-f-g-h-i-k-l-m-n-q-uQ!mSQ#heQ#usU$Wx%`'vS$f!U$iQ$r!cQ$s!dQ$t!eQ$u!fQ$v!gQ$w!hQ%b!yQ%g!|Q%m#QQ%n#RQ&a#}Q&y$gQ(c&PU(n&i(o*qW)R&w)T+S+TQ*Q'pQ*Z(PQ+R)SQ+|*cR-j-oQ!xXQ!{YQ$d!SQ$e!T^'o%]%d'r'z*S*V*XR+O)O[fOr#l$l)[+Zh!uXY!S!T%]%d'r'z)O*S*V*XQ#PZQ#khS#|v|Q$Z}W$b!R$V&z)XS$n!X$jW$x!i'a)u+mQ%O!kQ%t#[`&Q#i%}(b(d(l*o,S-nQ&b$OQ&c$QQ&d$SQ'^$zQ'h%PQ'n%ZW(O%i(Q*[*`Q(S%kQ(]%uQ(h&[S(k&`-lQ(q&kQ(r&lU(z&s({*zQ)a'RY)d'U)e+b+c,gQ)s'`^)w'd)y+q+r,p-U-aQ)}'fQ*O'gS*P'k-mW*b(W*]+y+}W*f(Z*h,P,QQ+l)oQ+p)xQ+t)|Q,O*gQ,T*rQ,h+fQ,n+nQ,o+oQ,r+uQ,v+{Q-Q,iQ-S,mR-`-ThTOr#i#l$l%}&`'k(b(d)[+Z$z!tXYZhv|}!R!S!T!X!i!k#[$O$Q$S$V$j$z%P%Z%]%d%i%k%u&[&k&l&s&z'R'U'`'a'd'f'g'r'z(Q(W(Z(l({)O)X)e)o)u)x)y)|*S*V*X*[*]*`*g*h*o*r*z+b+c+f+m+n+o+q+r+u+y+{+},P,Q,S,g,i,m,p-T-U-a-l-m-nQ#vtW%T!n!r-g-qQ%U!oQ%V!pQ%X!sQ%c-fS'j%W-kQ'l-hQ'm-iQ+v*TQ,u+wS-W,s-dR-s-uU#zu-Y-tR(i&^[gOr#l$l)[+ZX!wX#[$S$VQ#UZQ$PvR$Y|Q%_!xQ%f!{Q%l#PQ'^$xQ'y%bQ'}%gQ(V%mQ(Y%nQ*_(SQ,t+vQ-[,uR-c-ZQ$XxQ'u%`R*U'vQ-Z,sR-e-dR#OYR#TZR$}!iQ${!iV)t'a)u+mR%Q!kR%v#[Q(`%vR*n(aQ$c!RQ&h$VQ)W&zR+V)XQ#plQ$[!OQ$_!PR&p$^Q(s&oQ*v(uQ*w(vR,Z*xR$a!QXpOr)[+ZQ$h!UR&{$iQ$o!XR&|$jR)n'YQ)l'YV,j+i,k-R",
                nodeNames: "âš  print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ParenthesizedExpression ( BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from ) TupleExpression ComprehensionExpression async for LambdaExpression ArrayExpression [ ] ArrayComprehensionExpression DictionaryExpression { } DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At",
                maxTerm: 234,
                context: trackIndent,
                nodeProps: [
                    [lezer.NodeProp.group, -14, 4, 80, 82, 83, 85, 87, 89, 91, 93, 94, 95, 97, 100, 103, "Statement Statement", -22, 6, 16, 19, 21, 37, 47, 48, 52, 55, 56, 59, 60, 61, 62, 65, 68, 69, 70, 74, 75, 76, 77, "Expression", -9, 105, 107, 110, 112, 113, 117, 119, 124, 126, "Statement"]
                ],
                skippedNodes: [0, 2],
                repeatNodeCount: 32,
                tokenData: "&AaMgR!^OX$}XY!#xY[$}[]!#x]p$}pq!#xqr!&Srs!)yst!C{tu$}uv$+}vw$.awx$/mxy$Lgyz$Mmz{$Ns{|%#c|}%$o}!O%%u!O!P%([!P!Q%3b!Q!R%6Q!R![%:S![!]%EO!]!^%Gb!^!_%Hh!_!`%KW!`!a%Ld!a!b$}!b!c& P!c!d&!_!d!e&$P!e!h&!_!h!i&.R!i!t&!_!t!u&7g!u!w&!_!w!x&,a!x!}&!_!}#O&9q#O#P!%b#P#Q&:w#Q#R&;}#R#S&!_#S#T$}#T#U&!_#U#V&$P#V#Y&!_#Y#Z&.R#Z#f&!_#f#g&7g#g#i&!_#i#j&,a#j#o&!_#o#p&=Z#p#q&>P#q#r&?]#r#s&@Z#s$g$}$g~&!_<r%`Z%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}9[&^Z%p7[%gS%m`%v!bOr'PrsCxsw'Pwx(Px#O'P#O#P>v#P#o'P#o#pCU#p#q'P#q#r?[#r~'P9['^Z%p7[%gS%jW%m`%v!bOr'Prs&Rsw'Pwx(Px#O'P#O#P>v#P#o'P#o#pCU#p#q'P#q#r?[#r~'P8z(WZ%p7[%jWOr(yrs)wsw(ywx;bx#O(y#O#P2V#P#o(y#o#p7n#p#q(y#q#r2k#r~(y8z)UZ%p7[%gS%jW%v!bOr(yrs)wsw(ywx(Px#O(y#O#P2V#P#o(y#o#p7n#p#q(y#q#r2k#r~(y8z*QZ%p7[%gS%v!bOr(yrs*ssw(ywx(Px#O(y#O#P2V#P#o(y#o#p7n#p#q(y#q#r2k#r~(y8z*|Z%p7[%gS%v!bOr(yrs+osw(ywx(Px#O(y#O#P2V#P#o(y#o#p7n#p#q(y#q#r2k#r~(y8r+xX%p7[%gS%v!bOw+owx,ex#O+o#O#P.V#P#o+o#o#p0^#p#q+o#q#r.k#r~+o8r,jX%p7[Ow+owx-Vx#O+o#O#P.V#P#o+o#o#p0^#p#q+o#q#r.k#r~+o8r-[X%p7[Ow+owx-wx#O+o#O#P.V#P#o+o#o#p0^#p#q+o#q#r.k#r~+o7[-|R%p7[O#o-w#p#q-w#r~-w8r.[T%p7[O#o+o#o#p.k#p#q+o#q#r.k#r~+o!f.rV%gS%v!bOw.kwx/Xx#O.k#O#P0W#P#o.k#o#p0^#p~.k!f/[VOw.kwx/qx#O.k#O#P0W#P#o.k#o#p0^#p~.k!f/tUOw.kx#O.k#O#P0W#P#o.k#o#p0^#p~.k!f0ZPO~.k!f0cV%gSOw0xwx1^x#O0x#O#P2P#P#o0x#o#p.k#p~0xS0}T%gSOw0xwx1^x#O0x#O#P2P#P~0xS1aTOw0xwx1px#O0x#O#P2P#P~0xS1sSOw0xx#O0x#O#P2P#P~0xS2SPO~0x8z2[T%p7[O#o(y#o#p2k#p#q(y#q#r2k#r~(y!n2tX%gS%jW%v!bOr2krs3asw2kwx4wx#O2k#O#P7h#P#o2k#o#p7n#p~2k!n3hX%gS%v!bOr2krs4Tsw2kwx4wx#O2k#O#P7h#P#o2k#o#p7n#p~2k!n4[X%gS%v!bOr2krs.ksw2kwx4wx#O2k#O#P7h#P#o2k#o#p7n#p~2k!n4|X%jWOr2krs3asw2kwx5ix#O2k#O#P7h#P#o2k#o#p7n#p~2k!n5nX%jWOr2krs3asw2kwx6Zx#O2k#O#P7h#P#o2k#o#p7n#p~2kW6`T%jWOr6Zrs6os#O6Z#O#P7b#P~6ZW6rTOr6Zrs7Rs#O6Z#O#P7b#P~6ZW7USOr6Zs#O6Z#O#P7b#P~6ZW7ePO~6Z!n7kPO~2k!n7uX%gS%jWOr8brs9Osw8bwx:Ux#O8b#O#P;[#P#o8b#o#p2k#p~8b[8iV%gS%jWOr8brs9Osw8bwx:Ux#O8b#O#P;[#P~8b[9TV%gSOr8brs9jsw8bwx:Ux#O8b#O#P;[#P~8b[9oV%gSOr8brs0xsw8bwx:Ux#O8b#O#P;[#P~8b[:ZV%jWOr8brs9Osw8bwx:px#O8b#O#P;[#P~8b[:uV%jWOr8brs9Osw8bwx6Zx#O8b#O#P;[#P~8b[;_PO~8b8z;iZ%p7[%jWOr(yrs)wsw(ywx<[x#O(y#O#P2V#P#o(y#o#p7n#p#q(y#q#r2k#r~(y7d<cX%p7[%jWOr<[rs=Os#O<[#O#P>b#P#o<[#o#p6Z#p#q<[#q#r6Z#r~<[7d=TX%p7[Or<[rs=ps#O<[#O#P>b#P#o<[#o#p6Z#p#q<[#q#r6Z#r~<[7d=uX%p7[Or<[rs-ws#O<[#O#P>b#P#o<[#o#p6Z#p#q<[#q#r6Z#r~<[7d>gT%p7[O#o<[#o#p6Z#p#q<[#q#r6Z#r~<[9[>{T%p7[O#o'P#o#p?[#p#q'P#q#r?[#r~'P#O?gX%gS%jW%m`%v!bOr?[rs@Ssw?[wx4wx#O?[#O#PCO#P#o?[#o#pCU#p~?[#O@]X%gS%m`%v!bOr?[rs@xsw?[wx4wx#O?[#O#PCO#P#o?[#o#pCU#p~?[#OARX%gS%m`%v!bOr?[rsAnsw?[wx4wx#O?[#O#PCO#P#o?[#o#pCU#p~?[!vAwV%gS%m`%v!bOwAnwx/Xx#OAn#O#PB^#P#oAn#o#pBd#p~An!vBaPO~An!vBiV%gSOw0xwx1^x#O0x#O#P2P#P#o0x#o#pAn#p~0x#OCRPO~?[#OC]X%gS%jWOr8brs9Osw8bwx:Ux#O8b#O#P;[#P#o8b#o#p?[#p~8b9[DTZ%p7[%gS%m`%v!bOr'PrsDvsw'Pwx(Px#O'P#O#P>v#P#o'P#o#pCU#p#q'P#q#r?[#r~'P9SERX%p7[%gS%m`%v!bOwDvwx,ex#ODv#O#PEn#P#oDv#o#pBd#p#qDv#q#rAn#r~Dv9SEsT%p7[O#oDv#o#pAn#p#qDv#q#rAn#r~Dv<bF_Z%p7[%jW%sp%x#tOrGQrs)wswGQwxM^x#OGQ#O#PHS#P#oGQ#o#pLj#p#qGQ#q#rHh#r~GQ<bGaZ%p7[%gS%jW%sp%v!b%x#tOrGQrs)wswGQwxFSx#OGQ#O#PHS#P#oGQ#o#pLj#p#qGQ#q#rHh#r~GQ<bHXT%p7[O#oGQ#o#pHh#p#qGQ#q#rHh#r~GQ&UHuX%gS%jW%sp%v!b%x#tOrHhrs3aswHhwxIbx#OHh#O#PLd#P#oHh#o#pLj#p~Hh&UIkX%jW%sp%x#tOrHhrs3aswHhwxJWx#OHh#O#PLd#P#oHh#o#pLj#p~Hh&UJaX%jW%sp%x#tOrHhrs3aswHhwxJ|x#OHh#O#PLd#P#oHh#o#pLj#p~Hh$nKVX%jW%sp%x#tOrJ|rs6oswJ|wxJ|x#OJ|#O#PKr#P#oJ|#o#pKx#p~J|$nKuPO~J|$nK}V%jWOr6Zrs6os#O6Z#O#P7b#P#o6Z#o#pJ|#p~6Z&ULgPO~Hh&ULqX%gS%jWOr8brs9Osw8bwx:Ux#O8b#O#P;[#P#o8b#o#pHh#p~8b<bMiZ%p7[%jW%sp%x#tOrGQrs)wswGQwxN[x#OGQ#O#PHS#P#oGQ#o#pLj#p#qGQ#q#rHh#r~GQ:zNgZ%p7[%jW%sp%x#tOrN[rs=OswN[wxN[x#ON[#O#P! Y#P#oN[#o#pKx#p#qN[#q#rJ|#r~N[:z! _T%p7[O#oN[#o#pJ|#p#qN[#q#rJ|#r~N[<r! sT%p7[O#o$}#o#p!!S#p#q$}#q#r!!S#r~$}&f!!cX%gS%jW%m`%sp%v!b%x#tOr!!Srs@Ssw!!SwxIbx#O!!S#O#P!#O#P#o!!S#o#p!#U#p~!!S&f!#RPO~!!S&f!#]X%gS%jWOr8brs9Osw8bwx:Ux#O8b#O#P;[#P#o8b#o#p!!S#p~8bMg!$]a%p7[%gS%jW$o1s%m`%sp%v!b%x#tOX$}XY!#xY[$}[]!#x]p$}pq!#xqr$}rs&Rsw$}wxFSx#O$}#O#P!%b#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Mg!%gX%p7[OY$}YZ!#xZ]$}]^!#x^#o$}#o#p!!S#p#q$}#q#r!!S#r~$}<u!&eb%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`!'m!`#O$}#O#P! n#P#T$}#T#U!(s#U#f$}#f#g!(s#g#h!(s#h#o$}#o#p!#U#p#q$}#q#r!!S#r~$}<u!(QZjR%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}<u!)WZ!jR%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{!*Y_%tp%p7[%gS%e,X%m`%v!bOY!+XYZ'PZ]!+X]^'P^r!+Xrs!BPsw!+Xwx!-gx#O!+X#O#P!>e#P#o!+X#o#p!@}#p#q!+X#q#r!>y#r~!+XDe!+h_%p7[%gS%jW%e,X%m`%v!bOY!+XYZ'PZ]!+X]^'P^r!+Xrs!,gsw!+Xwx!-gx#O!+X#O#P!>e#P#o!+X#o#p!@}#p#q!+X#q#r!>y#r~!+XDe!,tZ%p7[%gS%e,X%m`%v!bOr'PrsCxsw'Pwx(Px#O'P#O#P>v#P#o'P#o#pCU#p#q'P#q#r?[#r~'PDT!-p_%p7[%jW%e,XOY!.oYZ(yZ]!.o]^(y^r!.ors!/{sw!.owx!;Rx#O!.o#O#P!0y#P#o!.o#o#p!6m#p#q!.o#q#r!1_#r~!.oDT!.|_%p7[%gS%jW%e,X%v!bOY!.oYZ(yZ]!.o]^(y^r!.ors!/{sw!.owx!-gx#O!.o#O#P!0y#P#o!.o#o#p!6m#p#q!.o#q#r!1_#r~!.oDT!0WZ%p7[%gS%e,X%v!bOr(yrs*ssw(ywx(Px#O(y#O#P2V#P#o(y#o#p7n#p#q(y#q#r2k#r~(yDT!1OT%p7[O#o!.o#o#p!1_#p#q!.o#q#r!1_#r~!.o-w!1j]%gS%jW%e,X%v!bOY!1_YZ2kZ]!1_]^2k^r!1_rs!2csw!1_wx!3Xx#O!1_#O#P!6g#P#o!1_#o#p!6m#p~!1_-w!2lX%gS%e,X%v!bOr2krs4Tsw2kwx4wx#O2k#O#P7h#P#o2k#o#p7n#p~2k-w!3`]%jW%e,XOY!1_YZ2kZ]!1_]^2k^r!1_rs!2csw!1_wx!4Xx#O!1_#O#P!6g#P#o!1_#o#p!6m#p~!1_-w!4`]%jW%e,XOY!1_YZ2kZ]!1_]^2k^r!1_rs!2csw!1_wx!5Xx#O!1_#O#P!6g#P#o!1_#o#p!6m#p~!1_,a!5`X%jW%e,XOY!5XYZ6ZZ]!5X]^6Z^r!5Xrs!5{s#O!5X#O#P!6a#P~!5X,a!6QT%e,XOr6Zrs7Rs#O6Z#O#P7b#P~6Z,a!6dPO~!5X-w!6jPO~!1_-w!6v]%gS%jW%e,XOY!7oYZ8bZ]!7o]^8b^r!7ors!8ksw!7owx!9Xx#O!7o#O#P!:{#P#o!7o#o#p!1_#p~!7o,e!7xZ%gS%jW%e,XOY!7oYZ8bZ]!7o]^8b^r!7ors!8ksw!7owx!9Xx#O!7o#O#P!:{#P~!7o,e!8rV%gS%e,XOr8brs9jsw8bwx:Ux#O8b#O#P;[#P~8b,e!9`Z%jW%e,XOY!7oYZ8bZ]!7o]^8b^r!7ors!8ksw!7owx!:Rx#O!7o#O#P!:{#P~!7o,e!:YZ%jW%e,XOY!7oYZ8bZ]!7o]^8b^r!7ors!8ksw!7owx!5Xx#O!7o#O#P!:{#P~!7o,e!;OPO~!7oDT!;[_%p7[%jW%e,XOY!.oYZ(yZ]!.o]^(y^r!.ors!/{sw!.owx!<Zx#O!.o#O#P!0y#P#o!.o#o#p!6m#p#q!.o#q#r!1_#r~!.oBm!<d]%p7[%jW%e,XOY!<ZYZ<[Z]!<Z]^<[^r!<Zrs!=]s#O!<Z#O#P!>P#P#o!<Z#o#p!5X#p#q!<Z#q#r!5X#r~!<ZBm!=dX%p7[%e,XOr<[rs=ps#O<[#O#P>b#P#o<[#o#p6Z#p#q<[#q#r6Z#r~<[Bm!>UT%p7[O#o!<Z#o#p!5X#p#q!<Z#q#r!5X#r~!<ZDe!>jT%p7[O#o!+X#o#p!>y#p#q!+X#q#r!>y#r~!+X.X!?W]%gS%jW%e,X%m`%v!bOY!>yYZ?[Z]!>y]^?[^r!>yrs!@Psw!>ywx!3Xx#O!>y#O#P!@w#P#o!>y#o#p!@}#p~!>y.X!@[X%gS%e,X%m`%v!bOr?[rs@xsw?[wx4wx#O?[#O#PCO#P#o?[#o#pCU#p~?[.X!@zPO~!>y.X!AW]%gS%jW%e,XOY!7oYZ8bZ]!7o]^8b^r!7ors!8ksw!7owx!9Xx#O!7o#O#P!:{#P#o!7o#o#p!>y#p~!7oGZ!B^Z%p7[%gS%e,X%m`%v!bOr'Prs!CPsw'Pwx(Px#O'P#O#P>v#P#o'P#o#pCU#p#q'P#q#r?[#r~'PGZ!C`X%k#|%p7[%gS%i,X%m`%v!bOwDvwx,ex#ODv#O#PEn#P#oDv#o#pBd#p#qDv#q#rAn#r~DvMg!D`_Q1s%p7[%gS%jW%m`%sp%v!b%x#tOY!C{YZ$}Z]!C{]^$}^r!C{rs!E_sw!C{wx#Hqx#O!C{#O#P$(i#P#o!C{#o#p$*{#p#q!C{#q#r$)]#r~!C{JP!El_Q1s%p7[%gS%m`%v!bOY!FkYZ'PZ]!Fk]^'P^r!Fkrs#Eksw!Fkwx!Gyx#O!Fk#O#P#=u#P#o!Fk#o#p#Di#p#q!Fk#q#r#>i#r~!FkJP!Fz_Q1s%p7[%gS%jW%m`%v!bOY!FkYZ'PZ]!Fk]^'P^r!Fkrs!E_sw!Fkwx!Gyx#O!Fk#O#P#=u#P#o!Fk#o#p#Di#p#q!Fk#q#r#>i#r~!FkIo!HS_Q1s%p7[%jWOY!IRYZ(yZ]!IR]^(y^r!IRrs!J_sw!IRwx#8wx#O!IR#O#P#*R#P#o!IR#o#p#2}#p#q!IR#q#r#*u#r~!IRIo!I`_Q1s%p7[%gS%jW%v!bOY!IRYZ(yZ]!IR]^(y^r!IRrs!J_sw!IRwx!Gyx#O!IR#O#P#*R#P#o!IR#o#p#2}#p#q!IR#q#r#*u#r~!IRIo!Jj_Q1s%p7[%gS%v!bOY!IRYZ(yZ]!IR]^(y^r!IRrs!Kisw!IRwx!Gyx#O!IR#O#P#*R#P#o!IR#o#p#2}#p#q!IR#q#r#*u#r~!IRIo!Kt_Q1s%p7[%gS%v!bOY!IRYZ(yZ]!IR]^(y^r!IRrs!Lssw!IRwx!Gyx#O!IR#O#P#*R#P#o!IR#o#p#2}#p#q!IR#q#r#*u#r~!IRIg!MO]Q1s%p7[%gS%v!bOY!LsYZ+oZ]!Ls]^+o^w!Lswx!Mwx#O!Ls#O#P#!y#P#o!Ls#o#p#&m#p#q!Ls#q#r##m#r~!LsIg!NO]Q1s%p7[OY!LsYZ+oZ]!Ls]^+o^w!Lswx!Nwx#O!Ls#O#P#!y#P#o!Ls#o#p#&m#p#q!Ls#q#r##m#r~!LsIg# O]Q1s%p7[OY!LsYZ+oZ]!Ls]^+o^w!Lswx# wx#O!Ls#O#P#!y#P#o!Ls#o#p#&m#p#q!Ls#q#r##m#r~!LsHP#!OXQ1s%p7[OY# wYZ-wZ]# w]^-w^#o# w#o#p#!k#p#q# w#q#r#!k#r~# w1s#!pRQ1sOY#!kZ]#!k^~#!kIg##QXQ1s%p7[OY!LsYZ+oZ]!Ls]^+o^#o!Ls#o#p##m#p#q!Ls#q#r##m#r~!Ls3Z##vZQ1s%gS%v!bOY##mYZ.kZ]##m]^.k^w##mwx#$ix#O##m#O#P#&X#P#o##m#o#p#&m#p~##m3Z#$nZQ1sOY##mYZ.kZ]##m]^.k^w##mwx#%ax#O##m#O#P#&X#P#o##m#o#p#&m#p~##m3Z#%fZQ1sOY##mYZ.kZ]##m]^.k^w##mwx#!kx#O##m#O#P#&X#P#o##m#o#p#&m#p~##m3Z#&^TQ1sOY##mYZ.kZ]##m]^.k^~##m3Z#&tZQ1s%gSOY#'gYZ0xZ]#'g]^0x^w#'gwx#(Zx#O#'g#O#P#)m#P#o#'g#o#p##m#p~#'g1w#'nXQ1s%gSOY#'gYZ0xZ]#'g]^0x^w#'gwx#(Zx#O#'g#O#P#)m#P~#'g1w#(`XQ1sOY#'gYZ0xZ]#'g]^0x^w#'gwx#({x#O#'g#O#P#)m#P~#'g1w#)QXQ1sOY#'gYZ0xZ]#'g]^0x^w#'gwx#!kx#O#'g#O#P#)m#P~#'g1w#)rTQ1sOY#'gYZ0xZ]#'g]^0x^~#'gIo#*YXQ1s%p7[OY!IRYZ(yZ]!IR]^(y^#o!IR#o#p#*u#p#q!IR#q#r#*u#r~!IR3c#+Q]Q1s%gS%jW%v!bOY#*uYZ2kZ]#*u]^2k^r#*urs#+ysw#*uwx#-}x#O#*u#O#P#2i#P#o#*u#o#p#2}#p~#*u3c#,S]Q1s%gS%v!bOY#*uYZ2kZ]#*u]^2k^r#*urs#,{sw#*uwx#-}x#O#*u#O#P#2i#P#o#*u#o#p#2}#p~#*u3c#-U]Q1s%gS%v!bOY#*uYZ2kZ]#*u]^2k^r#*urs##msw#*uwx#-}x#O#*u#O#P#2i#P#o#*u#o#p#2}#p~#*u3c#.U]Q1s%jWOY#*uYZ2kZ]#*u]^2k^r#*urs#+ysw#*uwx#.}x#O#*u#O#P#2i#P#o#*u#o#p#2}#p~#*u3c#/U]Q1s%jWOY#*uYZ2kZ]#*u]^2k^r#*urs#+ysw#*uwx#/}x#O#*u#O#P#2i#P#o#*u#o#p#2}#p~#*u1{#0UXQ1s%jWOY#/}YZ6ZZ]#/}]^6Z^r#/}rs#0qs#O#/}#O#P#2T#P~#/}1{#0vXQ1sOY#/}YZ6ZZ]#/}]^6Z^r#/}rs#1cs#O#/}#O#P#2T#P~#/}1{#1hXQ1sOY#/}YZ6ZZ]#/}]^6Z^r#/}rs#!ks#O#/}#O#P#2T#P~#/}1{#2YTQ1sOY#/}YZ6ZZ]#/}]^6Z^~#/}3c#2nTQ1sOY#*uYZ2kZ]#*u]^2k^~#*u3c#3W]Q1s%gS%jWOY#4PYZ8bZ]#4P]^8b^r#4Prs#4{sw#4Pwx#6ox#O#4P#O#P#8c#P#o#4P#o#p#*u#p~#4P2P#4YZQ1s%gS%jWOY#4PYZ8bZ]#4P]^8b^r#4Prs#4{sw#4Pwx#6ox#O#4P#O#P#8c#P~#4P2P#5SZQ1s%gSOY#4PYZ8bZ]#4P]^8b^r#4Prs#5usw#4Pwx#6ox#O#4P#O#P#8c#P~#4P2P#5|ZQ1s%gSOY#4PYZ8bZ]#4P]^8b^r#4Prs#'gsw#4Pwx#6ox#O#4P#O#P#8c#P~#4P2P#6vZQ1s%jWOY#4PYZ8bZ]#4P]^8b^r#4Prs#4{sw#4Pwx#7ix#O#4P#O#P#8c#P~#4P2P#7pZQ1s%jWOY#4PYZ8bZ]#4P]^8b^r#4Prs#4{sw#4Pwx#/}x#O#4P#O#P#8c#P~#4P2P#8hTQ1sOY#4PYZ8bZ]#4P]^8b^~#4PIo#9Q_Q1s%p7[%jWOY!IRYZ(yZ]!IR]^(y^r!IRrs!J_sw!IRwx#:Px#O!IR#O#P#*R#P#o!IR#o#p#2}#p#q!IR#q#r#*u#r~!IRHX#:Y]Q1s%p7[%jWOY#:PYZ<[Z]#:P]^<[^r#:Prs#;Rs#O#:P#O#P#=R#P#o#:P#o#p#/}#p#q#:P#q#r#/}#r~#:PHX#;Y]Q1s%p7[OY#:PYZ<[Z]#:P]^<[^r#:Prs#<Rs#O#:P#O#P#=R#P#o#:P#o#p#/}#p#q#:P#q#r#/}#r~#:PHX#<Y]Q1s%p7[OY#:PYZ<[Z]#:P]^<[^r#:Prs# ws#O#:P#O#P#=R#P#o#:P#o#p#/}#p#q#:P#q#r#/}#r~#:PHX#=YXQ1s%p7[OY#:PYZ<[Z]#:P]^<[^#o#:P#o#p#/}#p#q#:P#q#r#/}#r~#:PJP#=|XQ1s%p7[OY!FkYZ'PZ]!Fk]^'P^#o!Fk#o#p#>i#p#q!Fk#q#r#>i#r~!Fk3s#>v]Q1s%gS%jW%m`%v!bOY#>iYZ?[Z]#>i]^?[^r#>irs#?osw#>iwx#-}x#O#>i#O#P#DT#P#o#>i#o#p#Di#p~#>i3s#?z]Q1s%gS%m`%v!bOY#>iYZ?[Z]#>i]^?[^r#>irs#@ssw#>iwx#-}x#O#>i#O#P#DT#P#o#>i#o#p#Di#p~#>i3s#AO]Q1s%gS%m`%v!bOY#>iYZ?[Z]#>i]^?[^r#>irs#Awsw#>iwx#-}x#O#>i#O#P#DT#P#o#>i#o#p#Di#p~#>i3k#BSZQ1s%gS%m`%v!bOY#AwYZAnZ]#Aw]^An^w#Awwx#$ix#O#Aw#O#P#Bu#P#o#Aw#o#p#CZ#p~#Aw3k#BzTQ1sOY#AwYZAnZ]#Aw]^An^~#Aw3k#CbZQ1s%gSOY#'gYZ0xZ]#'g]^0x^w#'gwx#(Zx#O#'g#O#P#)m#P#o#'g#o#p#Aw#p~#'g3s#DYTQ1sOY#>iYZ?[Z]#>i]^?[^~#>i3s#Dr]Q1s%gS%jWOY#4PYZ8bZ]#4P]^8b^r#4Prs#4{sw#4Pwx#6ox#O#4P#O#P#8c#P#o#4P#o#p#>i#p~#4PJP#Ex_Q1s%p7[%gS%m`%v!bOY!FkYZ'PZ]!Fk]^'P^r!Fkrs#Fwsw!Fkwx!Gyx#O!Fk#O#P#=u#P#o!Fk#o#p#Di#p#q!Fk#q#r#>i#r~!FkIw#GU]Q1s%p7[%gS%m`%v!bOY#FwYZDvZ]#Fw]^Dv^w#Fwwx!Mwx#O#Fw#O#P#G}#P#o#Fw#o#p#CZ#p#q#Fw#q#r#Aw#r~#FwIw#HUXQ1s%p7[OY#FwYZDvZ]#Fw]^Dv^#o#Fw#o#p#Aw#p#q#Fw#q#r#Aw#r~#FwMV#IO_Q1s%p7[%jW%sp%x#tOY#I}YZGQZ]#I}]^GQ^r#I}rs!J_sw#I}wx$%]x#O#I}#O#P#K_#P#o#I}#o#p$$Z#p#q#I}#q#r#LR#r~#I}MV#J`_Q1s%p7[%gS%jW%sp%v!b%x#tOY#I}YZGQZ]#I}]^GQ^r#I}rs!J_sw#I}wx#Hqx#O#I}#O#P#K_#P#o#I}#o#p$$Z#p#q#I}#q#r#LR#r~#I}MV#KfXQ1s%p7[OY#I}YZGQZ]#I}]^GQ^#o#I}#o#p#LR#p#q#I}#q#r#LR#r~#I}6y#Lb]Q1s%gS%jW%sp%v!b%x#tOY#LRYZHhZ]#LR]^Hh^r#LRrs#+ysw#LRwx#MZx#O#LR#O#P$#u#P#o#LR#o#p$$Z#p~#LR6y#Mf]Q1s%jW%sp%x#tOY#LRYZHhZ]#LR]^Hh^r#LRrs#+ysw#LRwx#N_x#O#LR#O#P$#u#P#o#LR#o#p$$Z#p~#LR6y#Nj]Q1s%jW%sp%x#tOY#LRYZHhZ]#LR]^Hh^r#LRrs#+ysw#LRwx$ cx#O#LR#O#P$#u#P#o#LR#o#p$$Z#p~#LR5c$ n]Q1s%jW%sp%x#tOY$ cYZJ|Z]$ c]^J|^r$ crs#0qsw$ cwx$ cx#O$ c#O#P$!g#P#o$ c#o#p$!{#p~$ c5c$!lTQ1sOY$ cYZJ|Z]$ c]^J|^~$ c5c$#SZQ1s%jWOY#/}YZ6ZZ]#/}]^6Z^r#/}rs#0qs#O#/}#O#P#2T#P#o#/}#o#p$ c#p~#/}6y$#zTQ1sOY#LRYZHhZ]#LR]^Hh^~#LR6y$$d]Q1s%gS%jWOY#4PYZ8bZ]#4P]^8b^r#4Prs#4{sw#4Pwx#6ox#O#4P#O#P#8c#P#o#4P#o#p#LR#p~#4PMV$%j_Q1s%p7[%jW%sp%x#tOY#I}YZGQZ]#I}]^GQ^r#I}rs!J_sw#I}wx$&ix#O#I}#O#P#K_#P#o#I}#o#p$$Z#p#q#I}#q#r#LR#r~#I}Ko$&v_Q1s%p7[%jW%sp%x#tOY$&iYZN[Z]$&i]^N[^r$&irs#;Rsw$&iwx$&ix#O$&i#O#P$'u#P#o$&i#o#p$!{#p#q$&i#q#r$ c#r~$&iKo$'|XQ1s%p7[OY$&iYZN[Z]$&i]^N[^#o$&i#o#p$ c#p#q$&i#q#r$ c#r~$&iMg$(pXQ1s%p7[OY!C{YZ$}Z]!C{]^$}^#o!C{#o#p$)]#p#q!C{#q#r$)]#r~!C{7Z$)n]Q1s%gS%jW%m`%sp%v!b%x#tOY$)]YZ!!SZ]$)]]^!!S^r$)]rs#?osw$)]wx#MZx#O$)]#O#P$*g#P#o$)]#o#p$*{#p~$)]7Z$*lTQ1sOY$)]YZ!!SZ]$)]]^!!S^~$)]7Z$+U]Q1s%gS%jWOY#4PYZ8bZ]#4P]^8b^r#4Prs#4{sw#4Pwx#6ox#O#4P#O#P#8c#P#o#4P#o#p$)]#p~#4PGz$,b]$}Q%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gz$-nZ!s,W%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gz$.t]$wQ%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{$/|_%q`%p7[%jW%e,X%sp%x#tOY$0{YZGQZ]$0{]^GQ^r$0{rs$2]sw$0{wx$Jex#O$0{#O#P$Fw#P#o$0{#o#p$Ic#p#q$0{#q#r$G]#r~$0{Gk$1^_%p7[%gS%jW%e,X%sp%v!b%x#tOY$0{YZGQZ]$0{]^GQ^r$0{rs$2]sw$0{wx$Ewx#O$0{#O#P$Fw#P#o$0{#o#p$Ic#p#q$0{#q#r$G]#r~$0{DT$2h_%p7[%gS%e,X%v!bOY$3gYZ(yZ]$3g]^(y^r$3grs$Basw$3gwx$4sx#O$3g#O#P$5o#P#o$3g#o#p$={#p#q$3g#q#r$6T#r~$3gDT$3t_%p7[%gS%jW%e,X%v!bOY$3gYZ(yZ]$3g]^(y^r$3grs$2]sw$3gwx$4sx#O$3g#O#P$5o#P#o$3g#o#p$={#p#q$3g#q#r$6T#r~$3gDT$4|Z%p7[%jW%e,XOr(yrs)wsw(ywx;bx#O(y#O#P2V#P#o(y#o#p7n#p#q(y#q#r2k#r~(yDT$5tT%p7[O#o$3g#o#p$6T#p#q$3g#q#r$6T#r~$3g-w$6`]%gS%jW%e,X%v!bOY$6TYZ2kZ]$6T]^2k^r$6Trs$7Xsw$6Twx$=Rx#O$6T#O#P$=u#P#o$6T#o#p$={#p~$6T-w$7b]%gS%e,X%v!bOY$6TYZ2kZ]$6T]^2k^r$6Trs$8Zsw$6Twx$=Rx#O$6T#O#P$=u#P#o$6T#o#p$={#p~$6T-w$8d]%gS%e,X%v!bOY$6TYZ2kZ]$6T]^2k^r$6Trs$9]sw$6Twx$=Rx#O$6T#O#P$=u#P#o$6T#o#p$={#p~$6T-o$9fZ%gS%e,X%v!bOY$9]YZ.kZ]$9]]^.k^w$9]wx$:Xx#O$9]#O#P$:s#P#o$9]#o#p$:y#p~$9]-o$:^V%e,XOw.kwx/qx#O.k#O#P0W#P#o.k#o#p0^#p~.k-o$:vPO~$9]-o$;QZ%gS%e,XOY$;sYZ0xZ]$;s]^0x^w$;swx$<gx#O$;s#O#P$<{#P#o$;s#o#p$9]#p~$;s,]$;zX%gS%e,XOY$;sYZ0xZ]$;s]^0x^w$;swx$<gx#O$;s#O#P$<{#P~$;s,]$<lT%e,XOw0xwx1px#O0x#O#P2P#P~0x,]$=OPO~$;s-w$=YX%jW%e,XOr2krs3asw2kwx5ix#O2k#O#P7h#P#o2k#o#p7n#p~2k-w$=xPO~$6T-w$>U]%gS%jW%e,XOY$>}YZ8bZ]$>}]^8b^r$>}rs$?ysw$>}wx$Amx#O$>}#O#P$BZ#P#o$>}#o#p$6T#p~$>},e$?WZ%gS%jW%e,XOY$>}YZ8bZ]$>}]^8b^r$>}rs$?ysw$>}wx$Amx#O$>}#O#P$BZ#P~$>},e$@QZ%gS%e,XOY$>}YZ8bZ]$>}]^8b^r$>}rs$@ssw$>}wx$Amx#O$>}#O#P$BZ#P~$>},e$@zZ%gS%e,XOY$>}YZ8bZ]$>}]^8b^r$>}rs$;ssw$>}wx$Amx#O$>}#O#P$BZ#P~$>},e$AtV%jW%e,XOr8brs9Osw8bwx:px#O8b#O#P;[#P~8b,e$B^PO~$>}DT$Bl_%p7[%gS%e,X%v!bOY$3gYZ(yZ]$3g]^(y^r$3grs$Cksw$3gwx$4sx#O$3g#O#P$5o#P#o$3g#o#p$={#p#q$3g#q#r$6T#r~$3gC{$Cv]%p7[%gS%e,X%v!bOY$CkYZ+oZ]$Ck]^+o^w$Ckwx$Dox#O$Ck#O#P$Ec#P#o$Ck#o#p$:y#p#q$Ck#q#r$9]#r~$CkC{$DvX%p7[%e,XOw+owx-Vx#O+o#O#P.V#P#o+o#o#p0^#p#q+o#q#r.k#r~+oC{$EhT%p7[O#o$Ck#o#p$9]#p#q$Ck#q#r$9]#r~$CkGk$FUZ%p7[%jW%e,X%sp%x#tOrGQrs)wswGQwxM^x#OGQ#O#PHS#P#oGQ#o#pLj#p#qGQ#q#rHh#r~GQGk$F|T%p7[O#o$0{#o#p$G]#p#q$0{#q#r$G]#r~$0{1_$Gl]%gS%jW%e,X%sp%v!b%x#tOY$G]YZHhZ]$G]]^Hh^r$G]rs$7Xsw$G]wx$Hex#O$G]#O#P$I]#P#o$G]#o#p$Ic#p~$G]1_$HpX%jW%e,X%sp%x#tOrHhrs3aswHhwxJWx#OHh#O#PLd#P#oHh#o#pLj#p~Hh1_$I`PO~$G]1_$Il]%gS%jW%e,XOY$>}YZ8bZ]$>}]^8b^r$>}rs$?ysw$>}wx$Amx#O$>}#O#P$BZ#P#o$>}#o#p$G]#p~$>}Gk$JrZ%p7[%jW%e,X%sp%x#tOrGQrs)wswGQwx$Kex#OGQ#O#PHS#P#oGQ#o#pLj#p#qGQ#q#rHh#r~GQGk$KtZ%h!f%p7[%jW%f,X%sp%x#tOrN[rs=OswN[wxN[x#ON[#O#P! Y#P#oN[#o#pKx#p#qN[#q#rJ|#r~N[G{$LzZf,X%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}<u$NQZ!OR%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{% W_T,X%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSxz$}z{%!V{!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{%!j]_R%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{%#v]$z,X%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}<u%%SZwR%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Mg%&Y^${,X%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`$-Z!`!a%'U!a#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}B^%'iZ&S&j%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{%(o_!dQ%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!O$}!O!P%)n!P!Q$}!Q![%,O![#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{%*P]%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!O$}!O!P%*x!P#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{%+]Z!m,X%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%,cg!f,V%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!Q$}!Q![%,O![!g$}!g!h%-z!h!l$}!l!m%2[!m#O$}#O#P! n#P#R$}#R#S%,O#S#X$}#X#Y%-z#Y#^$}#^#_%2[#_#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%.]a%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx{$}{|%/b|}$}}!O%/b!O!Q$}!Q![%0l![#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%/s]%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!Q$}!Q![%0l![#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%1Pc!f,V%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!Q$}!Q![%0l![!l$}!l!m%2[!m#O$}#O#P! n#P#R$}#R#S%0l#S#^$}#^#_%2[#_#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%2oZ!f,V%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{%3u_$|R%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!P$}!P!Q%4t!Q!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gz%5X]%OQ%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%6eu!f,V%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!O$}!O!P%8x!P!Q$}!Q![%:S![!d$}!d!e%<U!e!g$}!g!h%-z!h!l$}!l!m%2[!m!q$}!q!r%?O!r!z$}!z!{%Ar!{#O$}#O#P! n#P#R$}#R#S%:S#S#U$}#U#V%<U#V#X$}#X#Y%-z#Y#^$}#^#_%2[#_#c$}#c#d%?O#d#l$}#l#m%Ar#m#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%9Z]%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!Q$}!Q![%,O![#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%:gi!f,V%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!O$}!O!P%8x!P!Q$}!Q![%:S![!g$}!g!h%-z!h!l$}!l!m%2[!m#O$}#O#P! n#P#R$}#R#S%:S#S#X$}#X#Y%-z#Y#^$}#^#_%2[#_#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%<g`%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!Q$}!Q!R%=i!R!S%=i!S#O$}#O#P! n#P#R$}#R#S%=i#S#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%=|`!f,V%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!Q$}!Q!R%=i!R!S%=i!S#O$}#O#P! n#P#R$}#R#S%=i#S#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%?a_%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!Q$}!Q!Y%@`!Y#O$}#O#P! n#P#R$}#R#S%@`#S#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%@s_!f,V%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!Q$}!Q!Y%@`!Y#O$}#O#P! n#P#R$}#R#S%@`#S#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%BTc%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!Q$}!Q![%C`![!c$}!c!i%C`!i#O$}#O#P! n#P#R$}#R#S%C`#S#T$}#T#Z%C`#Z#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy%Csc!f,V%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!Q$}!Q![%C`![!c$}!c!i%C`!i#O$}#O#P! n#P#R$}#R#S%C`#S#T$}#T#Z%C`#Z#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Mg%Ec]x1s%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`%F[!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}<u%FoZ%WR%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{%GuZ#^,X%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{%H{_jR%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!^$}!^!_%Iz!_!`!'m!`!a!'m!a#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gz%J_]$xQ%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{%Kk]%V,X%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`!'m!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{%Lw^jR%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`!'m!`!a%Ms!a#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gz%NW]$yQ%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}G{& f]]Q#tP%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Mg&!tc%p7[%gS%jW%d&j%m`%sp%v!b%x#t%Q,XOr$}rs&Rsw$}wxFSx!Q$}!Q![&!_![!c$}!c!}&!_!}#O$}#O#P! n#P#R$}#R#S&!_#S#T$}#T#o&!_#o#p!#U#p#q$}#q#r!!S#r$g$}$g~&!_Mg&$fg%p7[%gS%jW%d&j%m`%sp%v!b%x#t%Q,XOr$}rs&%}sw$}wx&)Tx!Q$}!Q![&!_![!c$}!c!t&!_!t!u&,a!u!}&!_!}#O$}#O#P! n#P#R$}#R#S&!_#S#T$}#T#f&!_#f#g&,a#g#o&!_#o#p!#U#p#q$}#q#r!!S#r$g$}$g~&!_De&&[_%p7[%gS%e,X%m`%v!bOY!+XYZ'PZ]!+X]^'P^r!+Xrs&'Zsw!+Xwx!-gx#O!+X#O#P!>e#P#o!+X#o#p!@}#p#q!+X#q#r!>y#r~!+XDe&'hZ%p7[%gS%e,X%m`%v!bOr'Prs&(Zsw'Pwx(Px#O'P#O#P>v#P#o'P#o#pCU#p#q'P#q#r?[#r~'PD]&(hX%p7[%gS%i,X%m`%v!bOwDvwx,ex#ODv#O#PEn#P#oDv#o#pBd#p#qDv#q#rAn#r~DvGk&)b_%p7[%jW%e,X%sp%x#tOY$0{YZGQZ]$0{]^GQ^r$0{rs$2]sw$0{wx&*ax#O$0{#O#P$Fw#P#o$0{#o#p$Ic#p#q$0{#q#r$G]#r~$0{Gk&*nZ%p7[%jW%e,X%sp%x#tOrGQrs)wswGQwx&+ax#OGQ#O#PHS#P#oGQ#o#pLj#p#qGQ#q#rHh#r~GQFT&+nZ%p7[%jW%f,X%sp%x#tOrN[rs=OswN[wxN[x#ON[#O#P! Y#P#oN[#o#pKx#p#qN[#q#rJ|#r~N[Mg&,vc%p7[%gS%jW%d&j%m`%sp%v!b%x#t%Q,XOr$}rs&%}sw$}wx&)Tx!Q$}!Q![&!_![!c$}!c!}&!_!}#O$}#O#P! n#P#R$}#R#S&!_#S#T$}#T#o&!_#o#p!#U#p#q$}#q#r!!S#r$g$}$g~&!_Mg&.hg%p7[%gS%jW%d&j%m`%sp%v!b%x#t%Q,XOr$}rs&0Psw$}wx&2wx!Q$}!Q![&!_![!c$}!c!t&!_!t!u&5u!u!}&!_!}#O$}#O#P! n#P#R$}#R#S&!_#S#T$}#T#f&!_#f#g&5u#g#o&!_#o#p!#U#p#q$}#q#r!!S#r$g$}$g~&!_De&0^Z%p7[%gS%m`%v!b%r,XOr'Prs&1Psw'Pwx(Px#O'P#O#P>v#P#o'P#o#pCU#p#q'P#q#r?[#r~'PDe&1[Z%p7[%gS%m`%v!bOr'Prs&1}sw'Pwx(Px#O'P#O#P>v#P#o'P#o#pCU#p#q'P#q#r?[#r~'PD]&2[X%p7[%gS%w,X%m`%v!bOwDvwx,ex#ODv#O#PEn#P#oDv#o#pBd#p#qDv#q#rAn#r~DvGk&3UZ%p7[%jW%sp%x#t%l,XOrGQrs)wswGQwx&3wx#OGQ#O#PHS#P#oGQ#o#pLj#p#qGQ#q#rHh#r~GQGk&4SZ%p7[%jW%sp%x#tOrGQrs)wswGQwx&4ux#OGQ#O#PHS#P#oGQ#o#pLj#p#qGQ#q#rHh#r~GQFT&5SZ%p7[%jW%u,X%sp%x#tOrN[rs=OswN[wxN[x#ON[#O#P! Y#P#oN[#o#pKx#p#qN[#q#rJ|#r~N[Mg&6[c%p7[%gS%jW%d&j%m`%sp%v!b%x#t%Q,XOr$}rs&0Psw$}wx&2wx!Q$}!Q![&!_![!c$}!c!}&!_!}#O$}#O#P! n#P#R$}#R#S&!_#S#T$}#T#o&!_#o#p!#U#p#q$}#q#r!!S#r$g$}$g~&!_Mg&7|k%p7[%gS%jW%d&j%m`%sp%v!b%x#t%Q,XOr$}rs&%}sw$}wx&)Tx!Q$}!Q![&!_![!c$}!c!h&!_!h!i&5u!i!t&!_!t!u&,a!u!}&!_!}#O$}#O#P! n#P#R$}#R#S&!_#S#T$}#T#U&!_#U#V&,a#V#Y&!_#Y#Z&5u#Z#o&!_#o#p!#U#p#q$}#q#r!!S#r$g$}$g~&!_G{&:UZ!V,X%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}<u&;[Z!WR%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gz&<b]$vQ%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}Gy&=dX%gS%jW!ZGmOr8brs9Osw8bwx:Ux#O8b#O#P;[#P#o8b#o#p!!S#p~8bGz&>d]$uQ%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx!_$}!_!`$-Z!`#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}<u&?nX![7_%gS%jW%m`%sp%v!b%x#tOr!!Srs@Ssw!!SwxIbx#O!!S#O#P!#O#P#o!!S#o#p!#U#p~!!SGy&@nZ%P,V%p7[%gS%jW%m`%sp%v!b%x#tOr$}rs&Rsw$}wxFSx#O$}#O#P! n#P#o$}#o#p!#U#p#q$}#q#r!!S#r~$}",
                tokenizers: [legacyPrint, indentation, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, newlines],
                topRules: { "Script": [0, 3] },
                specialized: [{ term: 186, get: function (value) { return spec_identifier[value] || -1; } }],
                tokenPrec: 6594
            });
            exports.parser = parser;
            /***/ 
        }),
        /***/ "./node_modules/lezer-tree/dist/tree.cjs": 
        /*!***********************************************!*\
          !*** ./node_modules/lezer-tree/dist/tree.cjs ***!
          \***********************************************/
        /***/ (function (__unused_webpack_module, exports) {
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            /// The default maximum length of a `TreeBuffer` node.
            var DefaultBufferLength = 1024;
            var nextPropID = 0;
            var CachedNode = new WeakMap();
            /// Each [node type](#tree.NodeType) can have metadata associated with
            /// it in props. Instances of this class represent prop names.
            var NodeProp = /** @class */ (function () {
                /// Create a new node prop type. You can optionally pass a
                /// `deserialize` function.
                function NodeProp(_b) {
                    var _c = _b === void 0 ? {} : _b, deserialize = _c.deserialize;
                    this.id = nextPropID++;
                    this.deserialize = deserialize || (function () {
                        throw new Error("This node type doesn't define a deserialize function");
                    });
                }
                /// Create a string-valued node prop whose deserialize function is
                /// the identity function.
                NodeProp.string = function () { return new NodeProp({ deserialize: function (str) { return str; } }); };
                /// Create a number-valued node prop whose deserialize function is
                /// just `Number`.
                NodeProp.number = function () { return new NodeProp({ deserialize: Number }); };
                /// Creates a boolean-valued node prop whose deserialize function
                /// returns true for any input.
                NodeProp.flag = function () { return new NodeProp({ deserialize: function () { return true; } }); };
                /// Store a value for this prop in the given object. This can be
                /// useful when building up a prop object to pass to the
                /// [`NodeType`](#tree.NodeType) constructor. Returns its first
                /// argument.
                NodeProp.prototype.set = function (propObj, value) {
                    propObj[this.id] = value;
                    return propObj;
                };
                /// This is meant to be used with
                /// [`NodeSet.extend`](#tree.NodeSet.extend) or
                /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop
                /// values for each node type in the set. Takes a [match
                /// object](#tree.NodeType^match) or function that returns undefined
                /// if the node type doesn't get this prop, and the prop's value if
                /// it does.
                NodeProp.prototype.add = function (match) {
                    var _this = this;
                    if (typeof match != "function")
                        match = NodeType.match(match);
                    return function (type) {
                        var result = match(type);
                        return result === undefined ? null : [_this, result];
                    };
                };
                return NodeProp;
            }());
            /// Prop that is used to describe matching delimiters. For opening
            /// delimiters, this holds an array of node names (written as a
            /// space-separated string when declaring this prop in a grammar)
            /// for the node types of closing delimiters that match it.
            NodeProp.closedBy = new NodeProp({ deserialize: function (str) { return str.split(" "); } });
            /// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is
            /// attached to closing delimiters, holding an array of node names
            /// of types of matching opening delimiters.
            NodeProp.openedBy = new NodeProp({ deserialize: function (str) { return str.split(" "); } });
            /// Used to assign node types to groups (for example, all node
            /// types that represent an expression could be tagged with an
            /// `"Expression"` group).
            NodeProp.group = new NodeProp({ deserialize: function (str) { return str.split(" "); } });
            var noProps = Object.create(null);
            /// Each node in a syntax tree has a node type associated with it.
            var NodeType = /** @class */ (function () {
                /// @internal
                function NodeType(
                /// The name of the node type. Not necessarily unique, but if the
                /// grammar was written properly, different node types with the
                /// same name within a node set should play the same semantic
                /// role.
                name, 
                /// @internal
                props, 
                /// The id of this node in its set. Corresponds to the term ids
                /// used in the parser.
                id, 
                /// @internal
                flags) {
                    if (flags === void 0) { flags = 0; }
                    this.name = name;
                    this.props = props;
                    this.id = id;
                    this.flags = flags;
                }
                NodeType.define = function (spec) {
                    var props = spec.props && spec.props.length ? Object.create(null) : noProps;
                    var flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
                        (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
                    var type = new NodeType(spec.name || "", props, spec.id, flags);
                    if (spec.props)
                        for (var _b = 0, _c = spec.props; _b < _c.length; _b++) {
                            var src = _c[_b];
                            if (!Array.isArray(src))
                                src = src(type);
                            if (src)
                                src[0].set(props, src[1]);
                        }
                    return type;
                };
                /// Retrieves a node prop for this type. Will return `undefined` if
                /// the prop isn't present on this node.
                NodeType.prototype.prop = function (prop) { return this.props[prop.id]; };
                Object.defineProperty(NodeType.prototype, "isTop", {
                    /// True when this is the top node of a grammar.
                    get: function () { return (this.flags & 1 /* Top */) > 0; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(NodeType.prototype, "isSkipped", {
                    /// True when this node is produced by a skip rule.
                    get: function () { return (this.flags & 2 /* Skipped */) > 0; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(NodeType.prototype, "isError", {
                    /// Indicates whether this is an error node.
                    get: function () { return (this.flags & 4 /* Error */) > 0; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(NodeType.prototype, "isAnonymous", {
                    /// When true, this node type doesn't correspond to a user-declared
                    /// named node, for example because it is used to cache repetition.
                    get: function () { return (this.flags & 8 /* Anonymous */) > 0; },
                    enumerable: false,
                    configurable: true
                });
                /// Returns true when this node's name or one of its
                /// [groups](#tree.NodeProp^group) matches the given string.
                NodeType.prototype.is = function (name) {
                    if (typeof name == 'string') {
                        if (this.name == name)
                            return true;
                        var group = this.prop(NodeProp.group);
                        return group ? group.indexOf(name) > -1 : false;
                    }
                    return this.id == name;
                };
                /// Create a function from node types to arbitrary values by
                /// specifying an object whose property names are node or
                /// [group](#tree.NodeProp^group) names. Often useful with
                /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple
                /// names, separated by spaces, in a single property name to map
                /// multiple node names to a single value.
                NodeType.match = function (map) {
                    var direct = Object.create(null);
                    for (var prop in map)
                        for (var _b = 0, _c = prop.split(" "); _b < _c.length; _b++) {
                            var name_3 = _c[_b];
                            direct[name_3] = map[prop];
                        }
                    return function (node) {
                        for (var groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                            var found = direct[i < 0 ? node.name : groups[i]];
                            if (found)
                                return found;
                        }
                    };
                };
                return NodeType;
            }());
            /// An empty dummy node type to use when no actual type is available.
            NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
            /// A node set holds a collection of node types. It is used to
            /// compactly represent trees by storing their type ids, rather than a
            /// full pointer to the type object, in a number array. Each parser
            /// [has](#lezer.Parser.nodeSet) a node set, and [tree
            /// buffers](#tree.TreeBuffer) can only store collections of nodes
            /// from the same set. A set can have a maximum of 2**16 (65536)
            /// node types in it, so that the ids fit into 16-bit typed array
            /// slots.
            var NodeSet = /** @class */ (function () {
                /// Create a set with the given types. The `id` property of each
                /// type should correspond to its position within the array.
                function NodeSet(
                /// The node types in this set, by id.
                types) {
                    this.types = types;
                    for (var i = 0; i < types.length; i++)
                        if (types[i].id != i)
                            throw new RangeError("Node type ids should correspond to array positions when creating a node set");
                }
                /// Create a copy of this set with some node properties added. The
                /// arguments to this method should be created with
                /// [`NodeProp.add`](#tree.NodeProp.add).
                NodeSet.prototype.extend = function () {
                    var props = [];
                    for (var _b = 0; _b < arguments.length; _b++) {
                        props[_b] = arguments[_b];
                    }
                    var newTypes = [];
                    for (var _c = 0, _d = this.types; _c < _d.length; _c++) {
                        var type = _d[_c];
                        var newProps = null;
                        for (var _e = 0, props_1 = props; _e < props_1.length; _e++) {
                            var source = props_1[_e];
                            var add = source(type);
                            if (add) {
                                if (!newProps)
                                    newProps = Object.assign({}, type.props);
                                add[0].set(newProps, add[1]);
                            }
                        }
                        newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
                    }
                    return new NodeSet(newTypes);
                };
                return NodeSet;
            }());
            /// A piece of syntax tree. There are two ways to approach these
            /// trees: the way they are actually stored in memory, and the
            /// convenient way.
            ///
            /// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
            /// objects. By packing detail information into `TreeBuffer` leaf
            /// nodes, the representation is made a lot more memory-efficient.
            ///
            /// However, when you want to actually work with tree nodes, this
            /// representation is very awkward, so most client code will want to
            /// use the `TreeCursor` interface instead, which provides a view on
            /// some part of this data structure, and can be used to move around
            /// to adjacent nodes.
            var Tree = /** @class */ (function () {
                /// Construct a new tree. You usually want to go through
                /// [`Tree.build`](#tree.Tree^build) instead.
                function Tree(type, 
                /// The tree's child nodes. Children small enough to fit in a
                /// `TreeBuffer will be represented as such, other children can be
                /// further `Tree` instances with their own internal structure.
                children, 
                /// The positions (offsets relative to the start of this tree) of
                /// the children.
                positions, 
                /// The total length of this tree
                length) {
                    this.type = type;
                    this.children = children;
                    this.positions = positions;
                    this.length = length;
                }
                /// @internal
                Tree.prototype.toString = function () {
                    var children = this.children.map(function (c) { return c.toString(); }).join();
                    return !this.type.name ? children :
                        (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                            (children.length ? "(" + children + ")" : "");
                };
                /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When
                /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)
                /// to the given position and side.
                Tree.prototype.cursor = function (pos, side) {
                    if (side === void 0) { side = 0; }
                    var scope = (pos != null && CachedNode.get(this)) || this.topNode;
                    var cursor = new TreeCursor(scope);
                    if (pos != null) {
                        cursor.moveTo(pos, side);
                        CachedNode.set(this, cursor._tree);
                    }
                    return cursor;
                };
                /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular
                /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)
                /// nodes.
                Tree.prototype.fullCursor = function () {
                    return new TreeCursor(this.topNode, true);
                };
                Object.defineProperty(Tree.prototype, "topNode", {
                    /// Get a [syntax node](#tree.SyntaxNode) object for the top of the
                    /// tree.
                    get: function () {
                        return new TreeNode(this, 0, 0, null);
                    },
                    enumerable: false,
                    configurable: true
                });
                /// Get the [syntax node](#tree.SyntaxNode) at the given position.
                /// If `side` is -1, this will move into nodes that end at the
                /// position. If 1, it'll move into nodes that start at the
                /// position. With 0, it'll only enter nodes that cover the position
                /// from both sides.
                Tree.prototype.resolve = function (pos, side) {
                    if (side === void 0) { side = 0; }
                    return this.cursor(pos, side).node;
                };
                /// Iterate over the tree and its children, calling `enter` for any
                /// node that touches the `from`/`to` region (if given) before
                /// running over such a node's children, and `leave` (if given) when
                /// leaving the node. When `enter` returns `false`, the given node
                /// will not have its children iterated over (or `leave` called).
                Tree.prototype.iterate = function (spec) {
                    var enter = spec.enter, leave = spec.leave, _b = spec.from, from = _b === void 0 ? 0 : _b, _c = spec.to, to = _c === void 0 ? this.length : _c;
                    for (var c = this.cursor();;) {
                        var mustLeave = false;
                        if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {
                            if (c.firstChild())
                                continue;
                            if (!c.type.isAnonymous)
                                mustLeave = true;
                        }
                        for (;;) {
                            if (mustLeave && leave)
                                leave(c.type, c.from, c.to);
                            mustLeave = c.type.isAnonymous;
                            if (c.nextSibling())
                                break;
                            if (!c.parent())
                                return;
                            mustLeave = true;
                        }
                    }
                };
                /// Balance the direct children of this tree.
                Tree.prototype.balance = function (maxBufferLength) {
                    if (maxBufferLength === void 0) { maxBufferLength = DefaultBufferLength; }
                    return this.children.length <= BalanceBranchFactor ? this
                        : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length, 0);
                };
                /// Build a tree from a postfix-ordered buffer of node information,
                /// or a cursor over such a buffer.
                Tree.build = function (data) { return buildTree(data); };
                return Tree;
            }());
            /// The empty tree
            Tree.empty = new Tree(NodeType.none, [], [], 0);
            // For trees that need a context hash attached, we're using this
            // kludge which assigns an extra property directly after
            // initialization (creating a single new object shape).
            function withHash(tree, hash) {
                if (hash)
                    tree.contextHash = hash;
                return tree;
            }
            /// Tree buffers contain (type, start, end, endIndex) quads for each
            /// node. In such a buffer, nodes are stored in prefix order (parents
            /// before children, with the endIndex of the parent indicating which
            /// children belong to it)
            var TreeBuffer = /** @class */ (function () {
                /// Create a tree buffer @internal
                function TreeBuffer(
                /// @internal
                buffer, 
                // The total length of the group of nodes in the buffer.
                length, 
                /// @internal
                set, type) {
                    if (type === void 0) { type = NodeType.none; }
                    this.buffer = buffer;
                    this.length = length;
                    this.set = set;
                    this.type = type;
                }
                /// @internal
                TreeBuffer.prototype.toString = function () {
                    var result = [];
                    for (var index = 0; index < this.buffer.length;) {
                        result.push(this.childString(index));
                        index = this.buffer[index + 3];
                    }
                    return result.join(",");
                };
                /// @internal
                TreeBuffer.prototype.childString = function (index) {
                    var id = this.buffer[index], endIndex = this.buffer[index + 3];
                    var type = this.set.types[id], result = type.name;
                    if (/\W/.test(result) && !type.isError)
                        result = JSON.stringify(result);
                    index += 4;
                    if (endIndex == index)
                        return result;
                    var children = [];
                    while (index < endIndex) {
                        children.push(this.childString(index));
                        index = this.buffer[index + 3];
                    }
                    return result + "(" + children.join(",") + ")";
                };
                /// @internal
                TreeBuffer.prototype.findChild = function (startIndex, endIndex, dir, after) {
                    var buffer = this.buffer, pick = -1;
                    for (var i = startIndex; i != endIndex; i = buffer[i + 3]) {
                        if (after != -100000000 /* None */) {
                            var start = buffer[i + 1], end = buffer[i + 2];
                            if (dir > 0) {
                                if (end > after)
                                    pick = i;
                                if (end > after)
                                    break;
                            }
                            else {
                                if (start < after)
                                    pick = i;
                                if (end >= after)
                                    break;
                            }
                        }
                        else {
                            pick = i;
                            if (dir > 0)
                                break;
                        }
                    }
                    return pick;
                };
                return TreeBuffer;
            }());
            var TreeNode = /** @class */ (function () {
                function TreeNode(node, from, index, _parent) {
                    this.node = node;
                    this.from = from;
                    this.index = index;
                    this._parent = _parent;
                }
                Object.defineProperty(TreeNode.prototype, "type", {
                    get: function () { return this.node.type; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(TreeNode.prototype, "name", {
                    get: function () { return this.node.type.name; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(TreeNode.prototype, "to", {
                    get: function () { return this.from + this.node.length; },
                    enumerable: false,
                    configurable: true
                });
                TreeNode.prototype.nextChild = function (i, dir, after, full) {
                    if (full === void 0) { full = false; }
                    for (var parent_1 = this;;) {
                        for (var _b = parent_1.node, children = _b.children, positions = _b.positions, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                            var next = children[i], start = positions[i] + parent_1.from;
                            if (after != -100000000 /* None */ && (dir < 0 ? start >= after : start + next.length <= after))
                                continue;
                            if (next instanceof TreeBuffer) {
                                var index = next.findChild(0, next.buffer.length, dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - start);
                                if (index > -1)
                                    return new BufferNode(new BufferContext(parent_1, next, i, start), null, index);
                            }
                            else if (full || (!next.type.isAnonymous || hasChild(next))) {
                                var inner = new TreeNode(next, start, i, parent_1);
                                return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);
                            }
                        }
                        if (full || !parent_1.type.isAnonymous)
                            return null;
                        i = parent_1.index + dir;
                        parent_1 = parent_1._parent;
                        if (!parent_1)
                            return null;
                    }
                };
                Object.defineProperty(TreeNode.prototype, "firstChild", {
                    get: function () { return this.nextChild(0, 1, -100000000 /* None */); },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(TreeNode.prototype, "lastChild", {
                    get: function () { return this.nextChild(this.node.children.length - 1, -1, -100000000 /* None */); },
                    enumerable: false,
                    configurable: true
                });
                TreeNode.prototype.childAfter = function (pos) { return this.nextChild(0, 1, pos); };
                TreeNode.prototype.childBefore = function (pos) { return this.nextChild(this.node.children.length - 1, -1, pos); };
                TreeNode.prototype.nextSignificantParent = function () {
                    var val = this;
                    while (val.type.isAnonymous && val._parent)
                        val = val._parent;
                    return val;
                };
                Object.defineProperty(TreeNode.prototype, "parent", {
                    get: function () {
                        return this._parent ? this._parent.nextSignificantParent() : null;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(TreeNode.prototype, "nextSibling", {
                    get: function () {
                        return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(TreeNode.prototype, "prevSibling", {
                    get: function () {
                        return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(TreeNode.prototype, "cursor", {
                    get: function () { return new TreeCursor(this); },
                    enumerable: false,
                    configurable: true
                });
                TreeNode.prototype.resolve = function (pos, side) {
                    if (side === void 0) { side = 0; }
                    return this.cursor.moveTo(pos, side).node;
                };
                TreeNode.prototype.getChild = function (type, before, after) {
                    if (before === void 0) { before = null; }
                    if (after === void 0) { after = null; }
                    var r = getChildren(this, type, before, after);
                    return r.length ? r[0] : null;
                };
                TreeNode.prototype.getChildren = function (type, before, after) {
                    if (before === void 0) { before = null; }
                    if (after === void 0) { after = null; }
                    return getChildren(this, type, before, after);
                };
                /// @internal
                TreeNode.prototype.toString = function () { return this.node.toString(); };
                return TreeNode;
            }());
            function getChildren(node, type, before, after) {
                var cur = node.cursor, result = [];
                if (!cur.firstChild())
                    return result;
                if (before != null)
                    while (!cur.type.is(before))
                        if (!cur.nextSibling())
                            return result;
                for (;;) {
                    if (after != null && cur.type.is(after))
                        return result;
                    if (cur.type.is(type))
                        result.push(cur.node);
                    if (!cur.nextSibling())
                        return after == null ? result : [];
                }
            }
            var BufferContext = /** @class */ (function () {
                function BufferContext(parent, buffer, index, start) {
                    this.parent = parent;
                    this.buffer = buffer;
                    this.index = index;
                    this.start = start;
                }
                return BufferContext;
            }());
            var BufferNode = /** @class */ (function () {
                function BufferNode(context, _parent, index) {
                    this.context = context;
                    this._parent = _parent;
                    this.index = index;
                    this.type = context.buffer.set.types[context.buffer.buffer[index]];
                }
                Object.defineProperty(BufferNode.prototype, "name", {
                    get: function () { return this.type.name; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(BufferNode.prototype, "from", {
                    get: function () { return this.context.start + this.context.buffer.buffer[this.index + 1]; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(BufferNode.prototype, "to", {
                    get: function () { return this.context.start + this.context.buffer.buffer[this.index + 2]; },
                    enumerable: false,
                    configurable: true
                });
                BufferNode.prototype.child = function (dir, after) {
                    var buffer = this.context.buffer;
                    var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.context.start);
                    return index < 0 ? null : new BufferNode(this.context, this, index);
                };
                Object.defineProperty(BufferNode.prototype, "firstChild", {
                    get: function () { return this.child(1, -100000000 /* None */); },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(BufferNode.prototype, "lastChild", {
                    get: function () { return this.child(-1, -100000000 /* None */); },
                    enumerable: false,
                    configurable: true
                });
                BufferNode.prototype.childAfter = function (pos) { return this.child(1, pos); };
                BufferNode.prototype.childBefore = function (pos) { return this.child(-1, pos); };
                Object.defineProperty(BufferNode.prototype, "parent", {
                    get: function () {
                        return this._parent || this.context.parent.nextSignificantParent();
                    },
                    enumerable: false,
                    configurable: true
                });
                BufferNode.prototype.externalSibling = function (dir) {
                    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);
                };
                Object.defineProperty(BufferNode.prototype, "nextSibling", {
                    get: function () {
                        var buffer = this.context.buffer;
                        var after = buffer.buffer[this.index + 3];
                        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
                            return new BufferNode(this.context, this._parent, after);
                        return this.externalSibling(1);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(BufferNode.prototype, "prevSibling", {
                    get: function () {
                        var buffer = this.context.buffer;
                        var parentStart = this._parent ? this._parent.index + 4 : 0;
                        if (this.index == parentStart)
                            return this.externalSibling(-1);
                        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(BufferNode.prototype, "cursor", {
                    get: function () { return new TreeCursor(this); },
                    enumerable: false,
                    configurable: true
                });
                BufferNode.prototype.resolve = function (pos, side) {
                    if (side === void 0) { side = 0; }
                    return this.cursor.moveTo(pos, side).node;
                };
                /// @internal
                BufferNode.prototype.toString = function () { return this.context.buffer.childString(this.index); };
                BufferNode.prototype.getChild = function (type, before, after) {
                    if (before === void 0) { before = null; }
                    if (after === void 0) { after = null; }
                    var r = getChildren(this, type, before, after);
                    return r.length ? r[0] : null;
                };
                BufferNode.prototype.getChildren = function (type, before, after) {
                    if (before === void 0) { before = null; }
                    if (after === void 0) { after = null; }
                    return getChildren(this, type, before, after);
                };
                return BufferNode;
            }());
            /// A tree cursor object focuses on a given node in a syntax tree, and
            /// allows you to move to adjacent nodes.
            var TreeCursor = /** @class */ (function () {
                /// @internal
                function TreeCursor(node, full) {
                    if (full === void 0) { full = false; }
                    this.full = full;
                    this.buffer = null;
                    this.stack = [];
                    this.index = 0;
                    this.bufferNode = null;
                    if (node instanceof TreeNode) {
                        this.yieldNode(node);
                    }
                    else {
                        this._tree = node.context.parent;
                        this.buffer = node.context;
                        for (var n = node._parent; n; n = n._parent)
                            this.stack.unshift(n.index);
                        this.bufferNode = node;
                        this.yieldBuf(node.index);
                    }
                }
                Object.defineProperty(TreeCursor.prototype, "name", {
                    /// Shorthand for `.type.name`.
                    get: function () { return this.type.name; },
                    enumerable: false,
                    configurable: true
                });
                TreeCursor.prototype.yieldNode = function (node) {
                    if (!node)
                        return false;
                    this._tree = node;
                    this.type = node.type;
                    this.from = node.from;
                    this.to = node.to;
                    return true;
                };
                TreeCursor.prototype.yieldBuf = function (index, type) {
                    this.index = index;
                    var _b = this.buffer, start = _b.start, buffer = _b.buffer;
                    this.type = type || buffer.set.types[buffer.buffer[index]];
                    this.from = start + buffer.buffer[index + 1];
                    this.to = start + buffer.buffer[index + 2];
                    return true;
                };
                TreeCursor.prototype.yield = function (node) {
                    if (!node)
                        return false;
                    if (node instanceof TreeNode) {
                        this.buffer = null;
                        return this.yieldNode(node);
                    }
                    this.buffer = node.context;
                    return this.yieldBuf(node.index, node.type);
                };
                /// @internal
                TreeCursor.prototype.toString = function () {
                    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
                };
                /// @internal
                TreeCursor.prototype.enter = function (dir, after) {
                    if (!this.buffer)
                        return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));
                    var buffer = this.buffer.buffer;
                    var index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.buffer.start);
                    if (index < 0)
                        return false;
                    this.stack.push(this.index);
                    return this.yieldBuf(index);
                };
                /// Move the cursor to this node's first child. When this returns
                /// false, the node has no child, and the cursor has not been moved.
                TreeCursor.prototype.firstChild = function () { return this.enter(1, -100000000 /* None */); };
                /// Move the cursor to this node's last child.
                TreeCursor.prototype.lastChild = function () { return this.enter(-1, -100000000 /* None */); };
                /// Move the cursor to the first child that starts at or after `pos`.
                TreeCursor.prototype.childAfter = function (pos) { return this.enter(1, pos); };
                /// Move to the last child that ends at or before `pos`.
                TreeCursor.prototype.childBefore = function (pos) { return this.enter(-1, pos); };
                /// Move the node's parent node, if this isn't the top node.
                TreeCursor.prototype.parent = function () {
                    if (!this.buffer)
                        return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);
                    if (this.stack.length)
                        return this.yieldBuf(this.stack.pop());
                    var parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
                    this.buffer = null;
                    return this.yieldNode(parent);
                };
                /// @internal
                TreeCursor.prototype.sibling = function (dir) {
                    if (!this.buffer)
                        return !this._tree._parent ? false
                            : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000 /* None */, this.full));
                    var buffer = this.buffer.buffer, d = this.stack.length - 1;
                    if (dir < 0) {
                        var parentStart = d < 0 ? 0 : this.stack[d] + 4;
                        if (this.index != parentStart)
                            return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
                    }
                    else {
                        var after_1 = buffer.buffer[this.index + 3];
                        if (after_1 < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                            return this.yieldBuf(after_1);
                    }
                    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000 /* None */, this.full)) : false;
                };
                /// Move to this node's next sibling, if any.
                TreeCursor.prototype.nextSibling = function () { return this.sibling(1); };
                /// Move to this node's previous sibling, if any.
                TreeCursor.prototype.prevSibling = function () { return this.sibling(-1); };
                TreeCursor.prototype.atLastNode = function (dir) {
                    var _b, _c;
                    var index, parent, buffer = this.buffer;
                    if (buffer) {
                        if (dir > 0) {
                            if (this.index < buffer.buffer.buffer.length)
                                return false;
                        }
                        else {
                            for (var i = 0; i < this.index; i++)
                                if (buffer.buffer.buffer[i + 3] < this.index)
                                    return false;
                        }
                        (index = buffer.index, parent = buffer.parent);
                    }
                    else {
                        (_b = this._tree, index = _b.index, parent = _b._parent);
                    }
                    for (; parent; _c = parent, index = _c.index, parent = _c._parent) {
                        for (var i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                            var child = parent.node.children[i];
                            if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child))
                                return false;
                        }
                    }
                    return true;
                };
                TreeCursor.prototype.move = function (dir) {
                    if (this.enter(dir, -100000000 /* None */))
                        return true;
                    for (;;) {
                        if (this.sibling(dir))
                            return true;
                        if (this.atLastNode(dir) || !this.parent())
                            return false;
                    }
                };
                /// Move to the next node in a
                /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
                /// traversal, going from a node to its first child or, if the
                /// current node is empty, its next sibling or the next sibling of
                /// the first parent node that has one.
                TreeCursor.prototype.next = function () { return this.move(1); };
                /// Move to the next node in a last-to-first pre-order traveral. A
                /// node is followed by ist last child or, if it has none, its
                /// previous sibling or the previous sibling of the first parent
                /// node that has one.
                TreeCursor.prototype.prev = function () { return this.move(-1); };
                /// Move the cursor to the innermost node that covers `pos`. If
                /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
                /// it will enter nodes that start at `pos`.
                TreeCursor.prototype.moveTo = function (pos, side) {
                    if (side === void 0) { side = 0; }
                    // Move up to a node that actually holds the position, if possible
                    while (this.from == this.to ||
                        (side < 1 ? this.from >= pos : this.from > pos) ||
                        (side > -1 ? this.to <= pos : this.to < pos))
                        if (!this.parent())
                            break;
                    // Then scan down into child nodes as far as possible
                    for (;;) {
                        if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos))
                            break;
                        if (this.from == this.to ||
                            (side < 1 ? this.from >= pos : this.from > pos) ||
                            (side > -1 ? this.to <= pos : this.to < pos)) {
                            this.parent();
                            break;
                        }
                    }
                    return this;
                };
                Object.defineProperty(TreeCursor.prototype, "node", {
                    /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current
                    /// position.
                    get: function () {
                        if (!this.buffer)
                            return this._tree;
                        var cache = this.bufferNode, result = null, depth = 0;
                        if (cache && cache.context == this.buffer) {
                            scan: for (var index = this.index, d = this.stack.length; d >= 0;) {
                                for (var c = cache; c; c = c._parent)
                                    if (c.index == index) {
                                        if (index == this.index)
                                            return c;
                                        result = c;
                                        depth = d + 1;
                                        break scan;
                                    }
                                index = this.stack[--d];
                            }
                        }
                        for (var i = depth; i < this.stack.length; i++)
                            result = new BufferNode(this.buffer, result, this.stack[i]);
                        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(TreeCursor.prototype, "tree", {
                    /// Get the [tree](#tree.Tree) that represents the current node, if
                    /// any. Will return null when the node is in a [tree
                    /// buffer](#tree.TreeBuffer).
                    get: function () {
                        return this.buffer ? null : this._tree.node;
                    },
                    enumerable: false,
                    configurable: true
                });
                return TreeCursor;
            }());
            function hasChild(tree) {
                return tree.children.some(function (ch) { return !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch); });
            }
            var FlatBufferCursor = /** @class */ (function () {
                function FlatBufferCursor(buffer, index) {
                    this.buffer = buffer;
                    this.index = index;
                }
                Object.defineProperty(FlatBufferCursor.prototype, "id", {
                    get: function () { return this.buffer[this.index - 4]; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(FlatBufferCursor.prototype, "start", {
                    get: function () { return this.buffer[this.index - 3]; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(FlatBufferCursor.prototype, "end", {
                    get: function () { return this.buffer[this.index - 2]; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(FlatBufferCursor.prototype, "size", {
                    get: function () { return this.buffer[this.index - 1]; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(FlatBufferCursor.prototype, "pos", {
                    get: function () { return this.index; },
                    enumerable: false,
                    configurable: true
                });
                FlatBufferCursor.prototype.next = function () { this.index -= 4; };
                FlatBufferCursor.prototype.fork = function () { return new FlatBufferCursor(this.buffer, this.index); };
                return FlatBufferCursor;
            }());
            var BalanceBranchFactor = 8;
            function buildTree(data) {
                var _a;
                var buffer = data.buffer, nodeSet = data.nodeSet, _b = data.topID, topID = _b === void 0 ? 0 : _b, _c = data.maxBufferLength, maxBufferLength = _c === void 0 ? DefaultBufferLength : _c, _d = data.reused, reused = _d === void 0 ? [] : _d, _e = data.minRepeatType, minRepeatType = _e === void 0 ? nodeSet.types.length : _e;
                var cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
                var types = nodeSet.types;
                var contextHash = 0;
                function takeNode(parentStart, minPos, children, positions, inRepeat) {
                    var id = cursor.id, start = cursor.start, end = cursor.end, size = cursor.size;
                    var startPos = start - parentStart;
                    if (size < 0) {
                        if (size == -1) { // Reused node
                            children.push(reused[id]);
                            positions.push(startPos);
                        }
                        else { // Context change
                            contextHash = id;
                        }
                        cursor.next();
                        return;
                    }
                    var type = types[id], node, buffer;
                    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
                        // Small enough for a buffer, and no reused nodes inside
                        var data_1 = new Uint16Array(buffer.size - buffer.skip);
                        var endPos = cursor.pos - buffer.size, index = data_1.length;
                        while (cursor.pos > endPos)
                            index = copyToBuffer(buffer.start, data_1, index, inRepeat);
                        node = new TreeBuffer(data_1, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);
                        startPos = buffer.start - parentStart;
                    }
                    else { // Make it a node
                        var endPos = cursor.pos - size;
                        cursor.next();
                        var localChildren = [], localPositions = [];
                        var localInRepeat = id >= minRepeatType ? id : -1;
                        while (cursor.pos > endPos) {
                            if (cursor.id == localInRepeat)
                                cursor.next();
                            else
                                takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                        }
                        localChildren.reverse();
                        localPositions.reverse();
                        if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)
                            node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start, contextHash);
                        else
                            node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash);
                    }
                    children.push(node);
                    positions.push(startPos);
                }
                function findBufferSize(maxSize, inRepeat) {
                    // Scan through the buffer to find previous siblings that fit
                    // together in a TreeBuffer, and don't contain any reused nodes
                    // (which can't be stored in a buffer).
                    // If `inRepeat` is > -1, ignore node boundaries of that type for
                    // nesting, but make sure the end falls either at the start
                    // (`maxSize`) or before such a node.
                    var fork = cursor.fork();
                    var size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
                    var result = { size: 0, start: 0, skip: 0 };
                    scan: for (var minPos = fork.pos - maxSize; fork.pos > minPos;) {
                        // Pretend nested repeat nodes of the same type don't exist
                        if (fork.id == inRepeat) {
                            // Except that we store the current state as a valid return
                            // value.
                            result.size = size;
                            result.start = start;
                            result.skip = skip;
                            skip += 4;
                            size += 4;
                            fork.next();
                            continue;
                        }
                        var nodeSize = fork.size, startPos = fork.pos - nodeSize;
                        if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                            break;
                        var localSkipped = fork.id >= minRepeatType ? 4 : 0;
                        var nodeStart = fork.start;
                        fork.next();
                        while (fork.pos > startPos) {
                            if (fork.size < 0)
                                break scan;
                            if (fork.id >= minRepeatType)
                                localSkipped += 4;
                            fork.next();
                        }
                        start = nodeStart;
                        size += nodeSize;
                        skip += localSkipped;
                    }
                    if (inRepeat < 0 || size == maxSize) {
                        result.size = size;
                        result.start = start;
                        result.skip = skip;
                    }
                    return result.size > 4 ? result : undefined;
                }
                function copyToBuffer(bufferStart, buffer, index, inRepeat) {
                    var id = cursor.id, start = cursor.start, end = cursor.end, size = cursor.size;
                    cursor.next();
                    if (id == inRepeat)
                        return index;
                    var startIndex = index;
                    if (size > 4) {
                        var endPos = cursor.pos - (size - 4);
                        while (cursor.pos > endPos)
                            index = copyToBuffer(bufferStart, buffer, index, inRepeat);
                    }
                    if (id < minRepeatType) { // Don't copy repeat nodes into buffers
                        buffer[--index] = startIndex;
                        buffer[--index] = end - bufferStart;
                        buffer[--index] = start - bufferStart;
                        buffer[--index] = id;
                    }
                    return index;
                }
                var children = [], positions = [];
                while (cursor.pos > 0)
                    takeNode(data.start || 0, 0, children, positions, -1);
                var length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
                return new Tree(types[topID], children.reverse(), positions.reverse(), length);
            }
            function balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length, contextHash) {
                var localChildren = [], localPositions = [];
                if (length <= maxBufferLength) {
                    for (var i = from; i < to; i++) {
                        localChildren.push(children[i]);
                        localPositions.push(positions[i] - start);
                    }
                }
                else {
                    var maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));
                    for (var i = from; i < to;) {
                        var groupFrom = i, groupStart = positions[i];
                        i++;
                        for (; i < to; i++) {
                            var nextEnd = positions[i] + children[i].length;
                            if (nextEnd - groupStart > maxChild)
                                break;
                        }
                        if (i == groupFrom + 1) {
                            var only = children[groupFrom];
                            if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse
                                for (var j = 0; j < only.children.length; j++) {
                                    localChildren.push(only.children[j]);
                                    localPositions.push(only.positions[j] + groupStart - start);
                                }
                                continue;
                            }
                            localChildren.push(only);
                        }
                        else if (i == groupFrom + 1) {
                            localChildren.push(children[groupFrom]);
                        }
                        else {
                            var inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash);
                            if (innerType != NodeType.none && !containsType(inner.children, innerType))
                                inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash);
                            localChildren.push(inner);
                        }
                        localPositions.push(groupStart - start);
                    }
                }
                return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash);
            }
            function containsType(nodes, type) {
                for (var _b = 0, nodes_1 = nodes; _b < nodes_1.length; _b++) {
                    var elt = nodes_1[_b];
                    if (elt.type == type)
                        return true;
                }
                return false;
            }
            /// Tree fragments are used during [incremental
            /// parsing](#lezer.ParseOptions.fragments) to track parts of old
            /// trees that can be reused in a new parse. An array of fragments is
            /// used to track regions of an old tree whose nodes might be reused
            /// in new parses. Use the static
            /// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update
            /// fragments for document changes.
            var TreeFragment = /** @class */ (function () {
                function TreeFragment(
                /// The start of the unchanged range pointed to by this fragment.
                /// This refers to an offset in the _updated_ document (as opposed
                /// to the original tree).
                from, 
                /// The end of the unchanged range.
                to, 
                /// The tree that this fragment is based on.
                tree, 
                /// The offset between the fragment's tree and the document that
                /// this fragment can be used against. Add this when going from
                /// document to tree positions, subtract it to go from tree to
                /// document positions.
                offset, open) {
                    this.from = from;
                    this.to = to;
                    this.tree = tree;
                    this.offset = offset;
                    this.open = open;
                }
                Object.defineProperty(TreeFragment.prototype, "openStart", {
                    get: function () { return (this.open & 1 /* Start */) > 0; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(TreeFragment.prototype, "openEnd", {
                    get: function () { return (this.open & 2 /* End */) > 0; },
                    enumerable: false,
                    configurable: true
                });
                /// Apply a set of edits to an array of fragments, removing or
                /// splitting fragments as necessary to remove edited ranges, and
                /// adjusting offsets for fragments that moved.
                TreeFragment.applyChanges = function (fragments, changes, minGap) {
                    if (minGap === void 0) { minGap = 128; }
                    if (!changes.length)
                        return fragments;
                    var result = [];
                    var fI = 1, nextF = fragments.length ? fragments[0] : null;
                    var cI = 0, pos = 0, off = 0;
                    for (;;) {
                        var nextC = cI < changes.length ? changes[cI++] : null;
                        var nextPos = nextC ? nextC.fromA : 1e9;
                        if (nextPos - pos >= minGap)
                            while (nextF && nextF.from < nextPos) {
                                var cut = nextF;
                                if (pos >= cut.from || nextPos <= cut.to || off) {
                                    var fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                                    cut = fFrom >= fTo ? null :
                                        new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 /* Start */ : 0) | (nextC ? 2 /* End */ : 0));
                                }
                                if (cut)
                                    result.push(cut);
                                if (nextF.to > nextPos)
                                    break;
                                nextF = fI < fragments.length ? fragments[fI++] : null;
                            }
                        if (!nextC)
                            break;
                        pos = nextC.toA;
                        off = nextC.toA - nextC.toB;
                    }
                    return result;
                };
                /// Create a set of fragments from a freshly parsed tree, or update
                /// an existing set of fragments by replacing the ones that overlap
                /// with a tree with content from the new tree. When `partial` is
                /// true, the parse is treated as incomplete, and the token at its
                /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).
                TreeFragment.addTree = function (tree, fragments, partial) {
                    if (fragments === void 0) { fragments = []; }
                    if (partial === void 0) { partial = false; }
                    var result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 /* End */ : 0)];
                    for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {
                        var f = fragments_1[_b];
                        if (f.to > tree.length)
                            result.push(f);
                    }
                    return result;
                };
                return TreeFragment;
            }());
            // Creates an `Input` that is backed by a single, flat string.
            function stringInput(input) { return new StringInput(input); }
            var StringInput = /** @class */ (function () {
                function StringInput(string, length) {
                    if (length === void 0) { length = string.length; }
                    this.string = string;
                    this.length = length;
                }
                StringInput.prototype.get = function (pos) {
                    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);
                };
                StringInput.prototype.lineAfter = function (pos) {
                    if (pos < 0)
                        return "";
                    var end = this.string.indexOf("\n", pos);
                    return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));
                };
                StringInput.prototype.read = function (from, to) { return this.string.slice(from, Math.min(this.length, to)); };
                StringInput.prototype.clip = function (at) { return new StringInput(this.string, at); };
                return StringInput;
            }());
            exports.DefaultBufferLength = DefaultBufferLength;
            exports.NodeProp = NodeProp;
            exports.NodeSet = NodeSet;
            exports.NodeType = NodeType;
            exports.Tree = Tree;
            exports.TreeBuffer = TreeBuffer;
            exports.TreeCursor = TreeCursor;
            exports.TreeFragment = TreeFragment;
            exports.stringInput = stringInput;
            //# sourceMappingURL=tree.cjs.map
            /***/ 
        }),
        /***/ "./node_modules/lezer/dist/index.cjs": 
        /*!*******************************************!*\
          !*** ./node_modules/lezer/dist/index.cjs ***!
          \*******************************************/
        /***/ (function (__unused_webpack_module, exports, __webpack_require__) {
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var lezerTree = __webpack_require__(/*! lezer-tree */ "./node_modules/lezer-tree/dist/tree.cjs");
            /// A parse stack. These are used internally by the parser to track
            /// parsing progress. They also provide some properties and methods
            /// that external code such as a tokenizer can use to get information
            /// about the parse state.
            var Stack = /** @class */ (function () {
                /// @internal
                function Stack(
                /// A the parse that this stack is part of @internal
                p, 
                /// Holds state, pos, value stack pos (15 bits array index, 15 bits
                /// buffer index) triplets for all but the top state
                /// @internal
                stack, 
                /// The current parse state @internal
                state, 
                // The position at which the next reduce should take place. This
                // can be less than `this.pos` when skipped expressions have been
                // added to the stack (which should be moved outside of the next
                // reduction)
                /// @internal
                reducePos, 
                /// The input position up to which this stack has parsed.
                pos, 
                /// The dynamic score of the stack, including dynamic precedence
                /// and error-recovery penalties
                /// @internal
                score, 
                // The output buffer. Holds (type, start, end, size) quads
                // representing nodes created by the parser, where `size` is
                // amount of buffer array entries covered by this node.
                /// @internal
                buffer, 
                // The base offset of the buffer. When stacks are split, the split
                // instance shared the buffer history with its parent up to
                // `bufferBase`, which is the absolute offset (including the
                // offset of previous splits) into the buffer at which this stack
                // starts writing.
                /// @internal
                bufferBase, 
                /// @internal
                curContext, 
                // A parent stack from which this was split off, if any. This is
                // set up so that it always points to a stack that has some
                // additional buffer content, never to a stack with an equal
                // `bufferBase`.
                /// @internal
                parent) {
                    this.p = p;
                    this.stack = stack;
                    this.state = state;
                    this.reducePos = reducePos;
                    this.pos = pos;
                    this.score = score;
                    this.buffer = buffer;
                    this.bufferBase = bufferBase;
                    this.curContext = curContext;
                    this.parent = parent;
                }
                /// @internal
                Stack.prototype.toString = function () {
                    return "[" + this.stack.filter(function (_, i) { return i % 3 == 0; }).concat(this.state) + "]@" + this.pos + (this.score ? "!" + this.score : "");
                };
                // Start an empty stack
                /// @internal
                Stack.start = function (p, state, pos) {
                    if (pos === void 0) { pos = 0; }
                    var cx = p.parser.context;
                    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, null);
                };
                Object.defineProperty(Stack.prototype, "context", {
                    /// The stack's current [context](#lezer.ContextTracker) value, if
                    /// any. Its type will depend on the context tracker's type
                    /// parameter, or it will be `null` if there is no context
                    /// tracker.
                    get: function () { return this.curContext ? this.curContext.context : null; },
                    enumerable: false,
                    configurable: true
                });
                // Push a state onto the stack, tracking its start position as well
                // as the buffer base at that point.
                /// @internal
                Stack.prototype.pushState = function (state, start) {
                    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
                    this.state = state;
                };
                // Apply a reduce action
                /// @internal
                Stack.prototype.reduce = function (action) {
                    var depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
                    var parser = this.p.parser;
                    var dPrec = parser.dynamicPrecedence(type);
                    if (dPrec)
                        this.score += dPrec;
                    if (depth == 0) {
                        // Zero-depth reductions are a special caseâ€”they add stuff to
                        // the stack without popping anything off.
                        if (type < parser.minRepeatTerm)
                            this.storeNode(type, this.reducePos, this.reducePos, 4, true);
                        this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
                        this.reduceContext(type);
                        return;
                    }
                    // Find the base index into `this.stack`, content after which will
                    // be dropped. Note that with `StayFlag` reductions we need to
                    // consume two extra frames (the dummy parent node for the skipped
                    // expression and the state that we'll be staying in, which should
                    // be moved to `this.state`).
                    var base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
                    var start = this.stack[base - 2];
                    var bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
                    // Store normal terms or `R -> R R` repeat reductions
                    if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
                        var pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
                        this.storeNode(type, start, pos, count + 4, true);
                    }
                    if (action & 262144 /* StayFlag */) {
                        this.state = this.stack[base];
                    }
                    else {
                        var baseStateID = this.stack[base - 3];
                        this.state = parser.getGoto(baseStateID, type, true);
                    }
                    while (this.stack.length > base)
                        this.stack.pop();
                    this.reduceContext(type);
                };
                // Shift a value into the buffer
                /// @internal
                Stack.prototype.storeNode = function (term, start, end, size, isReduce) {
                    if (size === void 0) { size = 4; }
                    if (isReduce === void 0) { isReduce = false; }
                    if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
                        var cur = this, top_1 = this.buffer.length;
                        if (top_1 == 0 && cur.parent) {
                            top_1 = cur.bufferBase - cur.parent.bufferBase;
                            cur = cur.parent;
                        }
                        if (top_1 > 0 && cur.buffer[top_1 - 4] == 0 /* Err */ && cur.buffer[top_1 - 1] > -1) {
                            if (start == end)
                                return;
                            if (cur.buffer[top_1 - 2] >= start) {
                                cur.buffer[top_1 - 2] = end;
                                return;
                            }
                        }
                    }
                    if (!isReduce || this.pos == end) { // Simple case, just append
                        this.buffer.push(term, start, end, size);
                    }
                    else { // There may be skipped nodes that have to be moved forward
                        var index = this.buffer.length;
                        if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                            while (index > 0 && this.buffer[index - 2] > end) {
                                // Move this record forward
                                this.buffer[index] = this.buffer[index - 4];
                                this.buffer[index + 1] = this.buffer[index - 3];
                                this.buffer[index + 2] = this.buffer[index - 2];
                                this.buffer[index + 3] = this.buffer[index - 1];
                                index -= 4;
                                if (size > 4)
                                    size -= 4;
                            }
                        this.buffer[index] = term;
                        this.buffer[index + 1] = start;
                        this.buffer[index + 2] = end;
                        this.buffer[index + 3] = size;
                    }
                };
                // Apply a shift action
                /// @internal
                Stack.prototype.shift = function (action, next, nextEnd) {
                    if (action & 131072 /* GotoFlag */) {
                        this.pushState(action & 65535 /* ValueMask */, this.pos);
                    }
                    else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
                        var start = this.pos, nextState = action, parser = this.p.parser;
                        if (nextEnd > this.pos || next <= parser.maxNode) {
                            this.pos = nextEnd;
                            if (!parser.stateFlag(nextState, 1 /* Skipped */))
                                this.reducePos = nextEnd;
                        }
                        this.pushState(nextState, start);
                        if (next <= parser.maxNode)
                            this.buffer.push(next, start, nextEnd, 4);
                        this.shiftContext(next);
                    }
                    else { // Shift-and-stay, which means this is a skipped token
                        if (next <= this.p.parser.maxNode)
                            this.buffer.push(next, this.pos, nextEnd, 4);
                        this.pos = nextEnd;
                    }
                };
                // Apply an action
                /// @internal
                Stack.prototype.apply = function (action, next, nextEnd) {
                    if (action & 65536 /* ReduceFlag */)
                        this.reduce(action);
                    else
                        this.shift(action, next, nextEnd);
                };
                // Add a prebuilt node into the buffer. This may be a reused node or
                // the result of running a nested parser.
                /// @internal
                Stack.prototype.useNode = function (value, next) {
                    var index = this.p.reused.length - 1;
                    if (index < 0 || this.p.reused[index] != value) {
                        this.p.reused.push(value);
                        index++;
                    }
                    var start = this.pos;
                    this.reducePos = this.pos = start + value.length;
                    this.pushState(next, start);
                    this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */);
                    if (this.curContext)
                        this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this.p.input, this));
                };
                // Split the stack. Due to the buffer sharing and the fact
                // that `this.stack` tends to stay quite shallow, this isn't very
                // expensive.
                /// @internal
                Stack.prototype.split = function () {
                    var parent = this;
                    var off = parent.buffer.length;
                    // Because the top of the buffer (after this.pos) may be mutated
                    // to reorder reductions and skipped tokens, and shared buffers
                    // should be immutable, this copies any outstanding skipped tokens
                    // to the new buffer, and puts the base pointer before them.
                    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
                        off -= 4;
                    var buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
                    // Make sure parent points to an actual parent with content, if there is such a parent.
                    while (parent && base == parent.bufferBase)
                        parent = parent.parent;
                    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, parent);
                };
                // Try to recover from an error by 'deleting' (ignoring) one token.
                /// @internal
                Stack.prototype.recoverByDelete = function (next, nextEnd) {
                    var isNode = next <= this.p.parser.maxNode;
                    if (isNode)
                        this.storeNode(next, this.pos, nextEnd);
                    this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
                    this.pos = this.reducePos = nextEnd;
                    this.score -= 200 /* Token */;
                };
                /// Check if the given term would be able to be shifted (optionally
                /// after some reductions) on this stack. This can be useful for
                /// external tokenizers that want to make sure they only provide a
                /// given token when it applies.
                Stack.prototype.canShift = function (term) {
                    for (var sim = new SimulatedStack(this);;) {
                        var action = this.p.parser.stateSlot(sim.top, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.top, term);
                        if ((action & 65536 /* ReduceFlag */) == 0)
                            return true;
                        if (action == 0)
                            return false;
                        sim.reduce(action);
                    }
                };
                Object.defineProperty(Stack.prototype, "ruleStart", {
                    /// Find the start position of the rule that is currently being parsed.
                    get: function () {
                        for (var state = this.state, base = this.stack.length;;) {
                            var force = this.p.parser.stateSlot(state, 5 /* ForcedReduce */);
                            if (!(force & 65536 /* ReduceFlag */))
                                return 0;
                            base -= 3 * (force >> 19 /* ReduceDepthShift */);
                            if ((force & 65535 /* ValueMask */) < this.p.parser.minRepeatTerm)
                                return this.stack[base + 1];
                            state = this.stack[base];
                        }
                    },
                    enumerable: false,
                    configurable: true
                });
                /// Find the start position of an instance of any of the given term
                /// types, or return `null` when none of them are found.
                ///
                /// **Note:** this is only reliable when there is at least some
                /// state that unambiguously matches the given rule on the stack.
                /// I.e. if you have a grammar like this, where the difference
                /// between `a` and `b` is only apparent at the third token:
                ///
                ///     a { b | c }
                ///     b { "x" "y" "x" }
                ///     c { "x" "y" "z" }
                ///
                /// Then a parse state after `"x"` will not reliably tell you that
                /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check
                /// for either of those two rules (assuming that `a` isn't part of
                /// some rule that includes other things starting with `"x"`).
                ///
                /// When `before` is given, this keeps scanning up the stack until
                /// it finds a match that starts before that position.
                ///
                /// Note that you have to be careful when using this in tokenizers,
                /// since it's relatively easy to introduce data dependencies that
                /// break incremental parsing by using this method.
                Stack.prototype.startOf = function (types, before) {
                    var state = this.state, frame = this.stack.length, parser = this.p.parser;
                    for (;;) {
                        var force = parser.stateSlot(state, 5 /* ForcedReduce */);
                        var depth = force >> 19 /* ReduceDepthShift */, term = force & 65535 /* ValueMask */;
                        if (types.indexOf(term) > -1) {
                            var base = frame - (3 * (force >> 19 /* ReduceDepthShift */)), pos = this.stack[base + 1];
                            if (before == null || before > pos)
                                return pos;
                        }
                        if (frame == 0)
                            return null;
                        if (depth == 0) {
                            frame -= 3;
                            state = this.stack[frame];
                        }
                        else {
                            frame -= 3 * (depth - 1);
                            state = parser.getGoto(this.stack[frame - 3], term, true);
                        }
                    }
                };
                // Apply up to Recover.MaxNext recovery actions that conceptually
                // inserts some missing token or rule.
                /// @internal
                Stack.prototype.recoverByInsert = function (next) {
                    if (this.stack.length >= 300 /* MaxInsertStackDepth */)
                        return [];
                    var nextStates = this.p.parser.nextStates(this.state);
                    if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {
                        var best = [];
                        for (var i = 0, s = void 0; i < nextStates.length; i += 2) {
                            if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                                best.push(nextStates[i], s);
                        }
                        if (this.stack.length < 120 /* DampenInsertStackDepth */) {
                            var _loop_1 = function (i) {
                                var s = nextStates[i + 1];
                                if (!best.some(function (v, i) { return (i & 1) && v == s; }))
                                    best.push(nextStates[i], s);
                            };
                            for (var i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {
                                _loop_1(i);
                            }
                        }
                        nextStates = best;
                    }
                    var result = [];
                    for (var i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {
                        var s = nextStates[i + 1];
                        if (s == this.state)
                            continue;
                        var stack = this.split();
                        stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
                        stack.pushState(s, this.pos);
                        stack.shiftContext(nextStates[i]);
                        stack.score -= 200 /* Token */;
                        result.push(stack);
                    }
                    return result;
                };
                // Force a reduce, if possible. Return false if that can't
                // be done.
                /// @internal
                Stack.prototype.forceReduce = function () {
                    var reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);
                    if ((reduce & 65536 /* ReduceFlag */) == 0)
                        return false;
                    if (!this.p.parser.validAction(this.state, reduce)) {
                        this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
                        this.score -= 100 /* Reduce */;
                    }
                    this.reduce(reduce);
                    return true;
                };
                /// @internal
                Stack.prototype.forceAll = function () {
                    while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }
                    return this;
                };
                Object.defineProperty(Stack.prototype, "deadEnd", {
                    /// Check whether this state has no further actions (assumed to be a direct descendant of the
                    /// top state, since any other states must be able to continue
                    /// somehow). @internal
                    get: function () {
                        if (this.stack.length != 3)
                            return false;
                        var parser = this.p.parser;
                        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
                            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
                    },
                    enumerable: false,
                    configurable: true
                });
                /// Restart the stack (put it back in its start state). Only safe
                /// when this.stack.length == 3 (state is directly below the top
                /// state). @internal
                Stack.prototype.restart = function () {
                    this.state = this.stack[0];
                    this.stack.length = 0;
                };
                /// @internal
                Stack.prototype.sameState = function (other) {
                    if (this.state != other.state || this.stack.length != other.stack.length)
                        return false;
                    for (var i = 0; i < this.stack.length; i += 3)
                        if (this.stack[i] != other.stack[i])
                            return false;
                    return true;
                };
                Object.defineProperty(Stack.prototype, "parser", {
                    /// Get the parser used by this stack.
                    get: function () { return this.p.parser; },
                    enumerable: false,
                    configurable: true
                });
                /// Test whether a given dialect (by numeric ID, as exported from
                /// the terms file) is enabled.
                Stack.prototype.dialectEnabled = function (dialectID) { return this.p.parser.dialect.flags[dialectID]; };
                Stack.prototype.shiftContext = function (term) {
                    if (this.curContext)
                        this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this.p.input, this));
                };
                Stack.prototype.reduceContext = function (term) {
                    if (this.curContext)
                        this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this.p.input, this));
                };
                /// @internal
                Stack.prototype.emitContext = function () {
                    var cx = this.curContext;
                    if (!cx.tracker.strict)
                        return;
                    var last = this.buffer.length - 1;
                    if (last < 0 || this.buffer[last] != -2)
                        this.buffer.push(cx.hash, this.reducePos, this.reducePos, -2);
                };
                Stack.prototype.updateContext = function (context) {
                    if (context != this.curContext.context) {
                        var newCx = new StackContext(this.curContext.tracker, context);
                        if (newCx.hash != this.curContext.hash)
                            this.emitContext();
                        this.curContext = newCx;
                    }
                };
                return Stack;
            }());
            var StackContext = /** @class */ (function () {
                function StackContext(tracker, context) {
                    this.tracker = tracker;
                    this.context = context;
                    this.hash = tracker.hash(context);
                }
                return StackContext;
            }());
            var Recover;
            (function (Recover) {
                Recover[Recover["Token"] = 200] = "Token";
                Recover[Recover["Reduce"] = 100] = "Reduce";
                Recover[Recover["MaxNext"] = 4] = "MaxNext";
                Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
                Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
            })(Recover || (Recover = {}));
            // Used to cheaply run some reductions to scan ahead without mutating
            // an entire stack
            var SimulatedStack = /** @class */ (function () {
                function SimulatedStack(stack) {
                    this.stack = stack;
                    this.top = stack.state;
                    this.rest = stack.stack;
                    this.offset = this.rest.length;
                }
                SimulatedStack.prototype.reduce = function (action) {
                    var term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
                    if (depth == 0) {
                        if (this.rest == this.stack.stack)
                            this.rest = this.rest.slice();
                        this.rest.push(this.top, 0, 0);
                        this.offset += 3;
                    }
                    else {
                        this.offset -= (depth - 1) * 3;
                    }
                    var goto = this.stack.p.parser.getGoto(this.rest[this.offset - 3], term, true);
                    this.top = goto;
                };
                return SimulatedStack;
            }());
            // This is given to `Tree.build` to build a buffer, and encapsulates
            // the parent-stack-walking necessary to read the nodes.
            var StackBufferCursor = /** @class */ (function () {
                function StackBufferCursor(stack, pos, index) {
                    this.stack = stack;
                    this.pos = pos;
                    this.index = index;
                    this.buffer = stack.buffer;
                    if (this.index == 0)
                        this.maybeNext();
                }
                StackBufferCursor.create = function (stack) {
                    return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);
                };
                StackBufferCursor.prototype.maybeNext = function () {
                    var next = this.stack.parent;
                    if (next != null) {
                        this.index = this.stack.bufferBase - next.bufferBase;
                        this.stack = next;
                        this.buffer = next.buffer;
                    }
                };
                Object.defineProperty(StackBufferCursor.prototype, "id", {
                    get: function () { return this.buffer[this.index - 4]; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(StackBufferCursor.prototype, "start", {
                    get: function () { return this.buffer[this.index - 3]; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(StackBufferCursor.prototype, "end", {
                    get: function () { return this.buffer[this.index - 2]; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(StackBufferCursor.prototype, "size", {
                    get: function () { return this.buffer[this.index - 1]; },
                    enumerable: false,
                    configurable: true
                });
                StackBufferCursor.prototype.next = function () {
                    this.index -= 4;
                    this.pos -= 4;
                    if (this.index == 0)
                        this.maybeNext();
                };
                StackBufferCursor.prototype.fork = function () {
                    return new StackBufferCursor(this.stack, this.pos, this.index);
                };
                return StackBufferCursor;
            }());
            /// Tokenizers write the tokens they read into instances of this class.
            var Token = /** @class */ (function () {
                function Token() {
                    /// The start of the token. This is set by the parser, and should not
                    /// be mutated by the tokenizer.
                    this.start = -1;
                    /// This starts at -1, and should be updated to a term id when a
                    /// matching token is found.
                    this.value = -1;
                    /// When setting `.value`, you should also set `.end` to the end
                    /// position of the token. (You'll usually want to use the `accept`
                    /// method.)
                    this.end = -1;
                }
                /// Accept a token, setting `value` and `end` to the given values.
                Token.prototype.accept = function (value, end) {
                    this.value = value;
                    this.end = end;
                };
                return Token;
            }());
            /// @internal
            var TokenGroup = /** @class */ (function () {
                function TokenGroup(data, id) {
                    this.data = data;
                    this.id = id;
                }
                TokenGroup.prototype.token = function (input, token, stack) { readToken(this.data, input, token, stack, this.id); };
                return TokenGroup;
            }());
            TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
            /// Exports that are used for `@external tokens` in the grammar should
            /// export an instance of this class.
            var ExternalTokenizer = /** @class */ (function () {
                /// Create a tokenizer. The first argument is the function that,
                /// given an input stream and a token object,
                /// [fills](#lezer.Token.accept) the token object if it recognizes a
                /// token. `token.start` should be used as the start position to
                /// scan from.
                function ExternalTokenizer(
                /// @internal
                token, options) {
                    if (options === void 0) { options = {}; }
                    this.token = token;
                    this.contextual = !!options.contextual;
                    this.fallback = !!options.fallback;
                    this.extend = !!options.extend;
                }
                return ExternalTokenizer;
            }());
            // Tokenizer data is stored a big uint16 array containing, for each
            // state:
            //
            //  - A group bitmask, indicating what token groups are reachable from
            //    this state, so that paths that can only lead to tokens not in
            //    any of the current groups can be cut off early.
            //
            //  - The position of the end of the state's sequence of accepting
            //    tokens
            //
            //  - The number of outgoing edges for the state
            //
            //  - The accepting tokens, as (token id, group mask) pairs
            //
            //  - The outgoing edges, as (start character, end character, state
            //    index) triples, with end character being exclusive
            //
            // This function interprets that data, running through a stream as
            // long as new states with the a matching group mask can be reached,
            // and updating `token` when it matches a token.
            function readToken(data, input, token, stack, group) {
                var state = 0, groupMask = 1 << group, dialect = stack.p.parser.dialect;
                scan: for (var pos = token.start;;) {
                    if ((groupMask & data[state]) == 0)
                        break;
                    var accEnd = data[state + 1];
                    // Check whether this state can lead to a token in the current group
                    // Accept tokens in this state, possibly overwriting
                    // lower-precedence / shorter tokens
                    for (var i = state + 3; i < accEnd; i += 2)
                        if ((data[i + 1] & groupMask) > 0) {
                            var term = data[i];
                            if (dialect.allows(term) &&
                                (token.value == -1 || token.value == term || stack.p.parser.overrides(term, token.value))) {
                                token.accept(term, pos);
                                break;
                            }
                        }
                    var next = input.get(pos++);
                    // Do a binary search on the state's edges
                    for (var low = 0, high = data[state + 2]; low < high;) {
                        var mid = (low + high) >> 1;
                        var index = accEnd + mid + (mid << 1);
                        var from = data[index], to = data[index + 1];
                        if (next < from)
                            high = mid;
                        else if (next >= to)
                            low = mid + 1;
                        else {
                            state = data[index + 2];
                            continue scan;
                        }
                    }
                    break;
                }
            }
            // See lezer-generator/src/encode.ts for comments about the encoding
            // used here
            function decodeArray(input, Type) {
                if (Type === void 0) { Type = Uint16Array; }
                if (typeof input != "string")
                    return input;
                var array = null;
                for (var pos = 0, out = 0; pos < input.length;) {
                    var value = 0;
                    for (;;) {
                        var next = input.charCodeAt(pos++), stop_1 = false;
                        if (next == 126 /* BigValCode */) {
                            value = 65535 /* BigVal */;
                            break;
                        }
                        if (next >= 92 /* Gap2 */)
                            next--;
                        if (next >= 34 /* Gap1 */)
                            next--;
                        var digit = next - 32 /* Start */;
                        if (digit >= 46 /* Base */) {
                            digit -= 46 /* Base */;
                            stop_1 = true;
                        }
                        value += digit;
                        if (stop_1)
                            break;
                        value *= 46 /* Base */;
                    }
                    if (array)
                        array[out++] = value;
                    else
                        array = new Type(value);
                }
                return array;
            }
            // FIXME find some way to reduce recovery work done when the input
            // doesn't match the grammar at all.
            // Environment variable used to control console output
            var verbose = typeof process != "undefined" && /\bparse\b/.test(process.env.LOG);
            var stackIDs = null;
            function cutAt(tree, pos, side) {
                var cursor = tree.cursor(pos);
                for (;;) {
                    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
                        for (;;) {
                            if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                                return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 5)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 5));
                            if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                                break;
                            if (!cursor.parent())
                                return side < 0 ? 0 : tree.length;
                        }
                }
            }
            var FragmentCursor = /** @class */ (function () {
                function FragmentCursor(fragments) {
                    this.fragments = fragments;
                    this.i = 0;
                    this.fragment = null;
                    this.safeFrom = -1;
                    this.safeTo = -1;
                    this.trees = [];
                    this.start = [];
                    this.index = [];
                    this.nextFragment();
                }
                FragmentCursor.prototype.nextFragment = function () {
                    var fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
                    if (fr) {
                        this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
                        this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
                        while (this.trees.length) {
                            this.trees.pop();
                            this.start.pop();
                            this.index.pop();
                        }
                        this.trees.push(fr.tree);
                        this.start.push(-fr.offset);
                        this.index.push(0);
                        this.nextStart = this.safeFrom;
                    }
                    else {
                        this.nextStart = 1e9;
                    }
                };
                // `pos` must be >= any previously given `pos` for this cursor
                FragmentCursor.prototype.nodeAt = function (pos) {
                    if (pos < this.nextStart)
                        return null;
                    while (this.fragment && this.safeTo <= pos)
                        this.nextFragment();
                    if (!this.fragment)
                        return null;
                    for (;;) {
                        var last = this.trees.length - 1;
                        if (last < 0) { // End of tree
                            this.nextFragment();
                            return null;
                        }
                        var top_2 = this.trees[last], index = this.index[last];
                        if (index == top_2.children.length) {
                            this.trees.pop();
                            this.start.pop();
                            this.index.pop();
                            continue;
                        }
                        var next = top_2.children[index];
                        var start = this.start[last] + top_2.positions[index];
                        if (start > pos) {
                            this.nextStart = start;
                            return null;
                        }
                        else if (start == pos && start + next.length <= this.safeTo) {
                            return start == pos && start >= this.safeFrom ? next : null;
                        }
                        if (next instanceof lezerTree.TreeBuffer) {
                            this.index[last]++;
                            this.nextStart = start + next.length;
                        }
                        else {
                            this.index[last]++;
                            if (start + next.length >= pos) { // Enter this node
                                this.trees.push(next);
                                this.start.push(start);
                                this.index.push(0);
                            }
                        }
                    }
                };
                return FragmentCursor;
            }());
            var CachedToken = /** @class */ (function (_super) {
                __extends(CachedToken, _super);
                function CachedToken() {
                    var _this = _super.apply(this, arguments) || this;
                    _this.extended = -1;
                    _this.mask = 0;
                    _this.context = 0;
                    return _this;
                }
                CachedToken.prototype.clear = function (start) {
                    this.start = start;
                    this.value = this.extended = -1;
                };
                return CachedToken;
            }(Token));
            var dummyToken = new Token;
            var TokenCache = /** @class */ (function () {
                function TokenCache(parser) {
                    this.tokens = [];
                    this.mainToken = dummyToken;
                    this.actions = [];
                    this.tokens = parser.tokenizers.map(function (_) { return new CachedToken; });
                }
                TokenCache.prototype.getActions = function (stack, input) {
                    var actionIndex = 0;
                    var main = null;
                    var parser = stack.p.parser, tokenizers = parser.tokenizers;
                    var mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
                    var context = stack.curContext ? stack.curContext.hash : 0;
                    for (var i = 0; i < tokenizers.length; i++) {
                        if (((1 << i) & mask) == 0)
                            continue;
                        var tokenizer = tokenizers[i], token = this.tokens[i];
                        if (main && !tokenizer.fallback)
                            continue;
                        if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                            this.updateCachedToken(token, tokenizer, stack, input);
                            token.mask = mask;
                            token.context = context;
                        }
                        if (token.value != 0 /* Err */) {
                            var startIndex = actionIndex;
                            if (token.extended > -1)
                                actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                            actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                            if (!tokenizer.extend) {
                                main = token;
                                if (actionIndex > startIndex)
                                    break;
                            }
                        }
                    }
                    while (this.actions.length > actionIndex)
                        this.actions.pop();
                    if (!main) {
                        main = dummyToken;
                        main.start = stack.pos;
                        if (stack.pos == input.length)
                            main.accept(stack.p.parser.eofTerm, stack.pos);
                        else
                            main.accept(0 /* Err */, stack.pos + 1);
                    }
                    this.mainToken = main;
                    return this.actions;
                };
                TokenCache.prototype.updateCachedToken = function (token, tokenizer, stack, input) {
                    token.clear(stack.pos);
                    tokenizer.token(input, token, stack);
                    if (token.value > -1) {
                        var parser = stack.p.parser;
                        for (var i = 0; i < parser.specialized.length; i++)
                            if (parser.specialized[i] == token.value) {
                                var result = parser.specializers[i](input.read(token.start, token.end), stack);
                                if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                                    if ((result & 1) == 0 /* Specialize */)
                                        token.value = result >> 1;
                                    else
                                        token.extended = result >> 1;
                                    break;
                                }
                            }
                    }
                    else if (stack.pos == input.length) {
                        token.accept(stack.p.parser.eofTerm, stack.pos);
                    }
                    else {
                        token.accept(0 /* Err */, stack.pos + 1);
                    }
                };
                TokenCache.prototype.putAction = function (action, token, end, index) {
                    // Don't add duplicate actions
                    for (var i = 0; i < index; i += 3)
                        if (this.actions[i] == action)
                            return index;
                    this.actions[index++] = action;
                    this.actions[index++] = token;
                    this.actions[index++] = end;
                    return index;
                };
                TokenCache.prototype.addActions = function (stack, token, end, index) {
                    var state = stack.state, parser = stack.p.parser, data = parser.data;
                    for (var set = 0; set < 2; set++) {
                        for (var i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                            if (data[i] == 65535 /* End */) {
                                if (data[i + 1] == 1 /* Next */) {
                                    i = pair(data, i + 2);
                                }
                                else {
                                    if (index == 0 && data[i + 1] == 2 /* Other */)
                                        index = this.putAction(pair(data, i + 1), token, end, index);
                                    break;
                                }
                            }
                            if (data[i] == token)
                                index = this.putAction(pair(data, i + 1), token, end, index);
                        }
                    }
                    return index;
                };
                return TokenCache;
            }());
            var Rec;
            (function (Rec) {
                Rec[Rec["Distance"] = 5] = "Distance";
                Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
                Rec[Rec["MinBufferLengthPrune"] = 200] = "MinBufferLengthPrune";
                Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
            })(Rec || (Rec = {}));
            /// A parse context can be used for step-by-step parsing. After
            /// creating it, you repeatedly call `.advance()` until it returns a
            /// tree to indicate it has reached the end of the parse.
            var Parse = /** @class */ (function () {
                function Parse(parser, input, startPos, context) {
                    this.parser = parser;
                    this.input = input;
                    this.startPos = startPos;
                    this.context = context;
                    // The position to which the parse has advanced.
                    this.pos = 0;
                    this.recovering = 0;
                    this.nextStackID = 0x2654;
                    this.nested = null;
                    this.nestEnd = 0;
                    this.nestWrap = null;
                    this.reused = [];
                    this.tokens = new TokenCache(parser);
                    this.topTerm = parser.top[1];
                    this.stacks = [Stack.start(this, parser.top[0], this.startPos)];
                    var fragments = context === null || context === void 0 ? void 0 : context.fragments;
                    this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null;
                }
                // Move the parser forward. This will process all parse stacks at
                // `this.pos` and try to advance them to a further position. If no
                // stack for such a position is found, it'll start error-recovery.
                //
                // When the parse is finished, this will return a syntax tree. When
                // not, it returns `null`.
                Parse.prototype.advance = function () {
                    if (this.nested) {
                        var result = this.nested.advance();
                        this.pos = this.nested.pos;
                        if (result) {
                            this.finishNested(this.stacks[0], result);
                            this.nested = null;
                        }
                        return null;
                    }
                    var stacks = this.stacks, pos = this.pos;
                    // This will hold stacks beyond `pos`.
                    var newStacks = this.stacks = [];
                    var stopped, stoppedTokens;
                    var maybeNest;
                    // Keep advancing any stacks at `pos` until they either move
                    // forward or can't be advanced. Gather stacks that can't be
                    // advanced further in `stopped`.
                    for (var i = 0; i < stacks.length; i++) {
                        var stack = stacks[i], nest = void 0;
                        for (;;) {
                            if (stack.pos > pos) {
                                newStacks.push(stack);
                            }
                            else if (nest = this.checkNest(stack)) {
                                if (!maybeNest || maybeNest.stack.score < stack.score)
                                    maybeNest = nest;
                            }
                            else if (this.advanceStack(stack, newStacks, stacks)) {
                                continue;
                            }
                            else {
                                if (!stopped) {
                                    stopped = [];
                                    stoppedTokens = [];
                                }
                                stopped.push(stack);
                                var tok = this.tokens.mainToken;
                                stoppedTokens.push(tok.value, tok.end);
                            }
                            break;
                        }
                    }
                    if (maybeNest) {
                        this.startNested(maybeNest);
                        return null;
                    }
                    if (!newStacks.length) {
                        var finished = stopped && findFinished(stopped);
                        if (finished)
                            return this.stackToTree(finished);
                        if (this.parser.strict) {
                            if (verbose && stopped)
                                console.log("Stuck with token " + this.parser.getName(this.tokens.mainToken.value));
                            throw new SyntaxError("No parse at " + pos);
                        }
                        if (!this.recovering)
                            this.recovering = 5 /* Distance */;
                    }
                    if (this.recovering && stopped) {
                        var finished = this.runRecovery(stopped, stoppedTokens, newStacks);
                        if (finished)
                            return this.stackToTree(finished.forceAll());
                    }
                    if (this.recovering) {
                        var maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
                        if (newStacks.length > maxRemaining) {
                            newStacks.sort(function (a, b) { return b.score - a.score; });
                            while (newStacks.length > maxRemaining)
                                newStacks.pop();
                        }
                        if (newStacks.some(function (s) { return s.reducePos > pos; }))
                            this.recovering--;
                    }
                    else if (newStacks.length > 1) {
                        // Prune stacks that are in the same state, or that have been
                        // running without splitting for a while, to avoid getting stuck
                        // with multiple successful stacks running endlessly on.
                        outer: for (var i = 0; i < newStacks.length - 1; i++) {
                            var stack = newStacks[i];
                            for (var j = i + 1; j < newStacks.length; j++) {
                                var other = newStacks[j];
                                if (stack.sameState(other) ||
                                    stack.buffer.length > 200 /* MinBufferLengthPrune */ && other.buffer.length > 200 /* MinBufferLengthPrune */) {
                                    if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                                        newStacks.splice(j--, 1);
                                    }
                                    else {
                                        newStacks.splice(i--, 1);
                                        continue outer;
                                    }
                                }
                            }
                        }
                    }
                    this.pos = newStacks[0].pos;
                    for (var i = 1; i < newStacks.length; i++)
                        if (newStacks[i].pos < this.pos)
                            this.pos = newStacks[i].pos;
                    return null;
                };
                // Returns an updated version of the given stack, or null if the
                // stack can't advance normally. When `split` and `stacks` are
                // given, stacks split off by ambiguous operations will be pushed to
                // `split`, or added to `stacks` if they move `pos` forward.
                Parse.prototype.advanceStack = function (stack, stacks, split) {
                    var start = stack.pos, _b = this, input = _b.input, parser = _b.parser;
                    var base = verbose ? this.stackID(stack) + " -> " : "";
                    if (this.fragments) {
                        var strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
                        for (var cached = this.fragments.nodeAt(start); cached;) {
                            var match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                            if (match > -1 && cached.length && (!strictCx || (cached.contextHash || 0) == cxHash)) {
                                stack.useNode(cached, match);
                                if (verbose)
                                    console.log(base + this.stackID(stack) + (" (via reuse of " + parser.getName(cached.type.id) + ")"));
                                return true;
                            }
                            if (!(cached instanceof lezerTree.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                                break;
                            var inner = cached.children[0];
                            if (inner instanceof lezerTree.Tree)
                                cached = inner;
                            else
                                break;
                        }
                    }
                    var defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
                    if (defaultReduce > 0) {
                        stack.reduce(defaultReduce);
                        if (verbose)
                            console.log(base + this.stackID(stack) + (" (via always-reduce " + parser.getName(defaultReduce & 65535 /* ValueMask */) + ")"));
                        return true;
                    }
                    var actions = this.tokens.getActions(stack, input);
                    for (var i = 0; i < actions.length;) {
                        var action = actions[i++], term = actions[i++], end = actions[i++];
                        var last = i == actions.length || !split;
                        var localStack = last ? stack : stack.split();
                        localStack.apply(action, term, end);
                        if (verbose)
                            console.log(base + this.stackID(localStack) + (" (via " + ((action & 65536 /* ReduceFlag */) == 0 ? "shift"
                                : "reduce of " + parser.getName(action & 65535 /* ValueMask */)) + " for " + parser.getName(term) + " @ " + start + (localStack == stack ? "" : ", split") + ")"));
                        if (last)
                            return true;
                        else if (localStack.pos > start)
                            stacks.push(localStack);
                        else
                            split.push(localStack);
                    }
                    return false;
                };
                // Advance a given stack forward as far as it will go. Returns the
                // (possibly updated) stack if it got stuck, or null if it moved
                // forward and was given to `pushStackDedup`.
                Parse.prototype.advanceFully = function (stack, newStacks) {
                    var pos = stack.pos;
                    for (;;) {
                        var nest = this.checkNest(stack);
                        if (nest)
                            return nest;
                        if (!this.advanceStack(stack, null, null))
                            return false;
                        if (stack.pos > pos) {
                            pushStackDedup(stack, newStacks);
                            return true;
                        }
                    }
                };
                Parse.prototype.runRecovery = function (stacks, tokens, newStacks) {
                    var finished = null, restarted = false;
                    var maybeNest;
                    for (var i = 0; i < stacks.length; i++) {
                        var stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
                        var base = verbose ? this.stackID(stack) + " -> " : "";
                        if (stack.deadEnd) {
                            if (restarted)
                                continue;
                            restarted = true;
                            stack.restart();
                            if (verbose)
                                console.log(base + this.stackID(stack) + " (restarted)");
                            var done = this.advanceFully(stack, newStacks);
                            if (done) {
                                if (done !== true)
                                    maybeNest = done;
                                continue;
                            }
                        }
                        var force = stack.split(), forceBase = base;
                        for (var j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                            if (verbose)
                                console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                            var done = this.advanceFully(force, newStacks);
                            if (done) {
                                if (done !== true)
                                    maybeNest = done;
                                break;
                            }
                            if (verbose)
                                forceBase = this.stackID(force) + " -> ";
                        }
                        for (var _b = 0, _c = stack.recoverByInsert(token); _b < _c.length; _b++) {
                            var insert = _c[_b];
                            if (verbose)
                                console.log(base + this.stackID(insert) + " (via recover-insert)");
                            this.advanceFully(insert, newStacks);
                        }
                        if (this.input.length > stack.pos) {
                            if (tokenEnd == stack.pos) {
                                tokenEnd++;
                                token = 0 /* Err */;
                            }
                            stack.recoverByDelete(token, tokenEnd);
                            if (verbose)
                                console.log(base + this.stackID(stack) + (" (via recover-delete " + this.parser.getName(token) + ")"));
                            pushStackDedup(stack, newStacks);
                        }
                        else if (!finished || finished.score < stack.score) {
                            finished = stack;
                        }
                    }
                    if (finished)
                        return finished;
                    if (maybeNest)
                        for (var _d = 0, _e = this.stacks; _d < _e.length; _d++) {
                            var s = _e[_d];
                            if (s.score > maybeNest.stack.score) {
                                maybeNest = undefined;
                                break;
                            }
                        }
                    if (maybeNest)
                        this.startNested(maybeNest);
                    return null;
                };
                Parse.prototype.forceFinish = function () {
                    var stack = this.stacks[0].split();
                    if (this.nested)
                        this.finishNested(stack, this.nested.forceFinish());
                    return this.stackToTree(stack.forceAll());
                };
                // Convert the stack's buffer to a syntax tree.
                Parse.prototype.stackToTree = function (stack, pos) {
                    if (pos === void 0) { pos = stack.pos; }
                    if (this.parser.context)
                        stack.emitContext();
                    return lezerTree.Tree.build({ buffer: StackBufferCursor.create(stack),
                        nodeSet: this.parser.nodeSet,
                        topID: this.topTerm,
                        maxBufferLength: this.parser.bufferLength,
                        reused: this.reused,
                        start: this.startPos,
                        length: pos - this.startPos,
                        minRepeatType: this.parser.minRepeatTerm });
                };
                Parse.prototype.checkNest = function (stack) {
                    var info = this.parser.findNested(stack.state);
                    if (!info)
                        return null;
                    var spec = info.value;
                    if (typeof spec == "function")
                        spec = spec(this.input, stack);
                    return spec ? { stack: stack, info: info, spec: spec } : null;
                };
                Parse.prototype.startNested = function (nest) {
                    var stack = nest.stack, info = nest.info, spec = nest.spec;
                    this.stacks = [stack];
                    this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd);
                    this.nestWrap = typeof spec.wrapType == "number" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null;
                    if (spec.startParse) {
                        this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context);
                    }
                    else {
                        this.finishNested(stack);
                    }
                };
                Parse.prototype.scanForNestEnd = function (stack, endToken, filter) {
                    for (var pos = stack.pos; pos < this.input.length; pos++) {
                        dummyToken.start = pos;
                        dummyToken.value = -1;
                        endToken.token(this.input, dummyToken, stack);
                        if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end))))
                            return pos;
                    }
                    return this.input.length;
                };
                Parse.prototype.finishNested = function (stack, tree) {
                    if (this.nestWrap)
                        tree = new lezerTree.Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos);
                    else if (!tree)
                        tree = new lezerTree.Tree(lezerTree.NodeType.none, [], [], this.nestEnd - stack.pos);
                    var info = this.parser.findNested(stack.state);
                    stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true));
                    if (verbose)
                        console.log(this.stackID(stack) + " (via unnest)");
                };
                Parse.prototype.stackID = function (stack) {
                    var id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
                    if (!id)
                        stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
                    return id + stack;
                };
                return Parse;
            }());
            function pushStackDedup(stack, newStacks) {
                for (var i = 0; i < newStacks.length; i++) {
                    var other = newStacks[i];
                    if (other.pos == stack.pos && other.sameState(stack)) {
                        if (newStacks[i].score < stack.score)
                            newStacks[i] = stack;
                        return;
                    }
                }
                newStacks.push(stack);
            }
            var Dialect = /** @class */ (function () {
                function Dialect(source, flags, disabled) {
                    this.source = source;
                    this.flags = flags;
                    this.disabled = disabled;
                }
                Dialect.prototype.allows = function (term) { return !this.disabled || this.disabled[term] == 0; };
                return Dialect;
            }());
            var id = function (x) { return x; };
            /// Context trackers are used to track stateful context (such as
            /// indentation in the Python grammar, or parent elements in the XML
            /// grammar) needed by external tokenizers. You declare them in a
            /// grammar file as `@context exportName from "module"`.
            ///
            /// Context values should be immutable, and can be updated (replaced)
            /// on shift or reduce actions.
            var ContextTracker = /** @class */ (function () {
                /// The export used in a `@context` declaration should be of this
                /// type.
                function ContextTracker(spec) {
                    this.start = spec.start;
                    this.shift = spec.shift || id;
                    this.reduce = spec.reduce || id;
                    this.reuse = spec.reuse || id;
                    this.hash = spec.hash;
                    this.strict = spec.strict !== false;
                }
                return ContextTracker;
            }());
            /// A parser holds the parse tables for a given grammar, as generated
            /// by `lezer-generator`.
            var Parser = /** @class */ (function () {
                /// @internal
                function Parser(spec) {
                    var _this = this;
                    /// @internal
                    this.bufferLength = lezerTree.DefaultBufferLength;
                    /// @internal
                    this.strict = false;
                    this.cachedDialect = null;
                    if (spec.version != 13 /* Version */)
                        throw new RangeError("Parser version (" + spec.version + ") doesn't match runtime version (" + 13 /* Version */ + ")");
                    var tokenArray = decodeArray(spec.tokenData);
                    var nodeNames = spec.nodeNames.split(" ");
                    this.minRepeatTerm = nodeNames.length;
                    this.context = spec.context;
                    for (var i = 0; i < spec.repeatNodeCount; i++)
                        nodeNames.push("");
                    var nodeProps = [];
                    for (var i = 0; i < nodeNames.length; i++)
                        nodeProps.push([]);
                    function setProp(nodeID, prop, value) {
                        nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
                    }
                    if (spec.nodeProps)
                        for (var _b = 0, _c = spec.nodeProps; _b < _c.length; _b++) {
                            var propSpec = _c[_b];
                            var prop = propSpec[0];
                            for (var i = 1; i < propSpec.length;) {
                                var next = propSpec[i++];
                                if (next >= 0) {
                                    setProp(next, prop, propSpec[i++]);
                                }
                                else {
                                    var value = propSpec[i + -next];
                                    for (var j = -next; j > 0; j--)
                                        setProp(propSpec[i++], prop, value);
                                    i++;
                                }
                            }
                        }
                    this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
                    this.specializers = [];
                    if (spec.specialized)
                        for (var i = 0; i < spec.specialized.length; i++) {
                            this.specialized[i] = spec.specialized[i].term;
                            this.specializers[i] = spec.specialized[i].get;
                        }
                    this.states = decodeArray(spec.states, Uint32Array);
                    this.data = decodeArray(spec.stateData);
                    this.goto = decodeArray(spec.goto);
                    var topTerms = Object.keys(spec.topRules).map(function (r) { return spec.topRules[r][1]; });
                    this.nodeSet = new lezerTree.NodeSet(nodeNames.map(function (name, i) { return lezerTree.NodeType.define({
                        name: i >= _this.minRepeatTerm ? undefined : name,
                        id: i,
                        props: nodeProps[i],
                        top: topTerms.indexOf(i) > -1,
                        error: i == 0,
                        skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
                    }); }));
                    this.maxTerm = spec.maxTerm;
                    this.tokenizers = spec.tokenizers.map(function (value) { return typeof value == "number" ? new TokenGroup(tokenArray, value) : value; });
                    this.topRules = spec.topRules;
                    this.nested = (spec.nested || []).map(function (_b) {
                        var name = _b[0], value = _b[1], endToken = _b[2], placeholder = _b[3];
                        return { name: name, value: value, end: new TokenGroup(decodeArray(endToken), 0), placeholder: placeholder };
                    });
                    this.dialects = spec.dialects || {};
                    this.dynamicPrecedences = spec.dynamicPrecedences || null;
                    this.tokenPrecTable = spec.tokenPrec;
                    this.termNames = spec.termNames || null;
                    this.maxNode = this.nodeSet.types.length - 1;
                    this.dialect = this.parseDialect();
                    this.top = this.topRules[Object.keys(this.topRules)[0]];
                }
                /// Parse a given string or stream.
                Parser.prototype.parse = function (input, startPos, context) {
                    if (startPos === void 0) { startPos = 0; }
                    if (context === void 0) { context = {}; }
                    if (typeof input == "string")
                        input = lezerTree.stringInput(input);
                    var cx = new Parse(this, input, startPos, context);
                    for (;;) {
                        var done = cx.advance();
                        if (done)
                            return done;
                    }
                };
                /// Start an incremental parse.
                Parser.prototype.startParse = function (input, startPos, context) {
                    if (startPos === void 0) { startPos = 0; }
                    if (context === void 0) { context = {}; }
                    if (typeof input == "string")
                        input = lezerTree.stringInput(input);
                    return new Parse(this, input, startPos, context);
                };
                /// Get a goto table entry @internal
                Parser.prototype.getGoto = function (state, term, loose) {
                    if (loose === void 0) { loose = false; }
                    var table = this.goto;
                    if (term >= table[0])
                        return -1;
                    for (var pos = table[term + 1];;) {
                        var groupTag = table[pos++], last = groupTag & 1;
                        var target = table[pos++];
                        if (last && loose)
                            return target;
                        for (var end = pos + (groupTag >> 1); pos < end; pos++)
                            if (table[pos] == state)
                                return target;
                        if (last)
                            return -1;
                    }
                };
                /// Check if this state has an action for a given terminal @internal
                Parser.prototype.hasAction = function (state, terminal) {
                    var data = this.data;
                    for (var set = 0; set < 2; set++) {
                        for (var i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next = void 0;; i += 3) {
                            if ((next = data[i]) == 65535 /* End */) {
                                if (data[i + 1] == 1 /* Next */)
                                    next = data[i = pair(data, i + 2)];
                                else if (data[i + 1] == 2 /* Other */)
                                    return pair(data, i + 2);
                                else
                                    break;
                            }
                            if (next == terminal || next == 0 /* Err */)
                                return pair(data, i + 1);
                        }
                    }
                    return 0;
                };
                /// @internal
                Parser.prototype.stateSlot = function (state, slot) {
                    return this.states[(state * 6 /* Size */) + slot];
                };
                /// @internal
                Parser.prototype.stateFlag = function (state, flag) {
                    return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
                };
                /// @internal
                Parser.prototype.findNested = function (state) {
                    var flags = this.stateSlot(state, 0 /* Flags */);
                    return flags & 4 /* StartNest */ ? this.nested[flags >> 10 /* NestShift */] : null;
                };
                /// @internal
                Parser.prototype.validAction = function (state, action) {
                    if (action == this.stateSlot(state, 4 /* DefaultReduce */))
                        return true;
                    for (var i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
                        if (this.data[i] == 65535 /* End */) {
                            if (this.data[i + 1] == 1 /* Next */)
                                i = pair(this.data, i + 2);
                            else
                                return false;
                        }
                        if (action == pair(this.data, i + 1))
                            return true;
                    }
                };
                /// Get the states that can follow this one through shift actions or
                /// goto jumps. @internal
                Parser.prototype.nextStates = function (state) {
                    var result = [];
                    var _loop_2 = function (i) {
                        if (this_1.data[i] == 65535 /* End */) {
                            if (this_1.data[i + 1] == 1 /* Next */)
                                i = pair(this_1.data, i + 2);
                            else
                                return out_i_1 = i, "break";
                        }
                        if ((this_1.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {
                            var value_1 = this_1.data[i + 1];
                            if (!result.some(function (v, i) { return (i & 1) && v == value_1; }))
                                result.push(this_1.data[i], value_1);
                        }
                        out_i_1 = i;
                    };
                    var this_1 = this, out_i_1;
                    for (var i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
                        var state_1 = _loop_2(i);
                        i = out_i_1;
                        if (state_1 === "break")
                            break;
                    }
                    return result;
                };
                /// @internal
                Parser.prototype.overrides = function (token, prev) {
                    var iPrev = findOffset(this.data, this.tokenPrecTable, prev);
                    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
                };
                /// Configure the parser. Returns a new parser instance that has the
                /// given settings modified. Settings not provided in `config` are
                /// kept from the original parser.
                Parser.prototype.configure = function (config) {
                    var _b;
                    // Hideous reflection-based kludge to make it easy to create a
                    // slightly modified copy of a parser.
                    var copy = Object.assign(Object.create(Parser.prototype), this);
                    if (config.props)
                        copy.nodeSet = (_b = this.nodeSet).extend.apply(_b, config.props);
                    if (config.top) {
                        var info = this.topRules[config.top];
                        if (!info)
                            throw new RangeError("Invalid top rule name " + config.top);
                        copy.top = info;
                    }
                    if (config.tokenizers)
                        copy.tokenizers = this.tokenizers.map(function (t) {
                            var found = config.tokenizers.find(function (r) { return r.from == t; });
                            return found ? found.to : t;
                        });
                    if (config.dialect)
                        copy.dialect = this.parseDialect(config.dialect);
                    if (config.nested)
                        copy.nested = this.nested.map(function (obj) {
                            if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name))
                                return obj;
                            return { name: obj.name, value: config.nested[obj.name], end: obj.end, placeholder: obj.placeholder };
                        });
                    if (config.strict != null)
                        copy.strict = config.strict;
                    if (config.bufferLength != null)
                        copy.bufferLength = config.bufferLength;
                    return copy;
                };
                /// Returns the name associated with a given term. This will only
                /// work for all terms when the parser was generated with the
                /// `--names` option. By default, only the names of tagged terms are
                /// stored.
                Parser.prototype.getName = function (term) {
                    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
                };
                Object.defineProperty(Parser.prototype, "eofTerm", {
                    /// The eof term id is always allocated directly after the node
                    /// types. @internal
                    get: function () { return this.maxNode + 1; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Parser.prototype, "hasNested", {
                    /// Tells you whether this grammar has any nested grammars.
                    get: function () { return this.nested.length > 0; },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(Parser.prototype, "topNode", {
                    /// The type of top node produced by the parser.
                    get: function () { return this.nodeSet.types[this.top[1]]; },
                    enumerable: false,
                    configurable: true
                });
                /// @internal
                Parser.prototype.dynamicPrecedence = function (term) {
                    var prec = this.dynamicPrecedences;
                    return prec == null ? 0 : prec[term] || 0;
                };
                /// @internal
                Parser.prototype.parseDialect = function (dialect) {
                    if (this.cachedDialect && this.cachedDialect.source == dialect)
                        return this.cachedDialect;
                    var values = Object.keys(this.dialects), flags = values.map(function () { return false; });
                    if (dialect)
                        for (var _b = 0, _c = dialect.split(" "); _b < _c.length; _b++) {
                            var part = _c[_b];
                            var id_1 = values.indexOf(part);
                            if (id_1 >= 0)
                                flags[id_1] = true;
                        }
                    var disabled = null;
                    for (var i = 0; i < values.length; i++)
                        if (!flags[i]) {
                            for (var j = this.dialects[values[i]], id_2; (id_2 = this.data[j++]) != 65535 /* End */;)
                                (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id_2] = 1;
                        }
                    return this.cachedDialect = new Dialect(dialect, flags, disabled);
                };
                /// (used by the output of the parser generator) @internal
                Parser.deserialize = function (spec) {
                    return new Parser(spec);
                };
                return Parser;
            }());
            function pair(data, off) { return data[off] | (data[off + 1] << 16); }
            function findOffset(data, start, term) {
                for (var i = start, next = void 0; (next = data[i]) != 65535 /* End */; i++)
                    if (next == term)
                        return i - start;
                return -1;
            }
            function findFinished(stacks) {
                var best = null;
                for (var _b = 0, stacks_1 = stacks; _b < stacks_1.length; _b++) {
                    var stack = stacks_1[_b];
                    if (stack.pos == stack.p.input.length &&
                        stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&
                        (!best || best.score < stack.score))
                        best = stack;
                }
                return best;
            }
            exports.NodeProp = lezerTree.NodeProp;
            exports.NodeSet = lezerTree.NodeSet;
            exports.NodeType = lezerTree.NodeType;
            exports.Tree = lezerTree.Tree;
            exports.TreeCursor = lezerTree.TreeCursor;
            exports.ContextTracker = ContextTracker;
            exports.ExternalTokenizer = ExternalTokenizer;
            exports.Parser = Parser;
            exports.Stack = Stack;
            exports.Token = Token;
            //# sourceMappingURL=index.cjs.map
            /***/ 
        }),
        /***/ "./ast.ts": 
        /*!****************!*\
          !*** ./ast.ts ***!
          \****************/
        /***/ (function (__unused_webpack_module, exports) {
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.isUop = exports.isOp = exports.isLiteral = void 0;
            function isLiteral(maybeLit) {
                var tag = maybeLit.tag;
                if (tag === "number" || tag === "true" || tag === "false" || tag === "none") {
                    return true;
                }
                else {
                    return false;
                }
            }
            exports.isLiteral = isLiteral;
            var ops = { "+": true, "-": true, "*": true, "//": true, "%": true, "==": true, "!=": true,
                "<=": true, ">=": true, "<": true, ">": true, "is": true };
            function isOp(maybeOp) {
                return maybeOp in ops;
            }
            exports.isOp = isOp;
            var uops = { "not": true, "-": true };
            function isUop(maybeUop) {
                return maybeUop in uops;
            }
            exports.isUop = isUop;
            /***/ 
        }),
        /***/ "./compiler.ts": 
        /*!*********************!*\
          !*** ./compiler.ts ***!
          \*********************/
        /***/ (function (__unused_webpack_module, exports, __webpack_require__) {
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __generator = (this && this.__generator) || function (thisArg, body) {
                var _ = { label: 0, sent: function () { if (t[0] & 1)
                        throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
                return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
                function verb(n) { return function (v) { return step([n, v]); }; }
                function step(op) {
                    if (f)
                        throw new TypeError("Generator is already executing.");
                    while (_)
                        try {
                            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                                return t;
                            if (y = 0, t)
                                op = [op[0] & 2, t.value];
                            switch (op[0]) {
                                case 0:
                                case 1:
                                    t = op;
                                    break;
                                case 4:
                                    _.label++;
                                    return { value: op[1], done: false };
                                case 5:
                                    _.label++;
                                    y = op[1];
                                    op = [0];
                                    continue;
                                case 7:
                                    op = _.ops.pop();
                                    _.trys.pop();
                                    continue;
                                default:
                                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                        _ = 0;
                                        continue;
                                    }
                                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                        _.label = op[1];
                                        break;
                                    }
                                    if (op[0] === 6 && _.label < t[1]) {
                                        _.label = t[1];
                                        t = op;
                                        break;
                                    }
                                    if (t && _.label < t[2]) {
                                        _.label = t[2];
                                        _.ops.push(op);
                                        break;
                                    }
                                    if (t[2])
                                        _.ops.pop();
                                    _.trys.pop();
                                    continue;
                            }
                            op = body.call(thisArg, _);
                        }
                        catch (e) {
                            op = [6, e];
                            y = 0;
                        }
                        finally {
                            f = t = 0;
                        }
                    if (op[0] & 5)
                        throw op[1];
                    return { value: op[0] ? op[1] : void 0, done: true };
                }
            };
            var __spreadArrays = (this && this.__spreadArrays) || function () {
                for (var s = 0, i = 0, il = arguments.length; i < il; i++)
                    s += arguments[i].length;
                for (var r = Array(s), k = 0, i = 0; i < il; i++)
                    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                        r[k] = a[j];
                return r;
            };
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.compile = exports.codeGenStmt = exports.codeGenExpr = exports.uopStmts = exports.opStmts = exports.run = void 0;
            var wabt_1 = __importDefault(__webpack_require__(/*! wabt */ "wabt"));
            var parser_1 = __webpack_require__(/*! ./parser */ "./parser.ts");
            var tc_1 = __webpack_require__(/*! ./tc */ "./tc.ts");
            var LoopLabel = 1;
            function variableNames(stmts) {
                var vars = [];
                stmts.forEach(function (stmt) {
                    if (stmt.tag === "vardef") {
                        vars.push(stmt.name);
                    }
                });
                return vars;
            }
            function funs(stmts) {
                return stmts.filter(function (stmt) { return stmt.tag === "define"; });
            }
            function nonFuns(stmts) {
                return stmts.filter(function (stmt) { return stmt.tag !== "define"; });
            }
            function varsFunsStmts(stmts) {
                return [variableNames(stmts), funs(stmts), nonFuns(stmts)];
            }
            function run(watSource, config) {
                return __awaiter(this, void 0, void 0, function () {
                    var wabtApi, parsed, binary, wasmModule;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, wabt_1.default()];
                            case 1:
                                wabtApi = _a.sent();
                                parsed = wabtApi.parseWat("example", watSource);
                                binary = parsed.toBinary({});
                                return [4 /*yield*/, WebAssembly.instantiate(binary.buffer, config)];
                            case 2:
                                wasmModule = _a.sent();
                                return [2 /*return*/, wasmModule.instance.exports._start()];
                        }
                    });
                });
            }
            exports.run = run;
            function opStmts(op) {
                //+ | - | * | // | % | == | != | <= | >= | < | > | is  
                switch (op) {
                    case "+": return ["i32.add"];
                    case "-": return ["i32.sub"];
                    case "*": return ["i32.mul"];
                    case "//": return ["i32.div_s"];
                    case "%": return ["i32.rem_s"];
                    case "==": return ["i32.eq"];
                    case "!=": return ["i32.ne"];
                    case "<=": return ["i32.le_s"];
                    case ">=": return ["i32.ge_s"];
                    case "<": return ["i32.lt_s"];
                    case ">": return ["i32.gt_s"];
                    default:
                        throw new Error("Unhandled or unknown op: " + op);
                }
            }
            exports.opStmts = opStmts;
            function uopStmts(uop, oprdCode) {
                switch (uop) {
                    case "not": return __spreadArrays(oprdCode, ["i32.eqz"]);
                    case "-": return __spreadArrays(["(i32.const 0)"], oprdCode, ["i32.sub"]);
                }
            }
            exports.uopStmts = uopStmts;
            function codeGenExpr(expr, locals) {
                switch (expr.tag) {
                    case "number": return ["(i32.const " + expr.value + ")"];
                    case "true": return ["(i32.const 1)"];
                    case "false": return ["(i32.const 0)"];
                    case "id":
                        // Since we type-checked for making sure all variable exist, here we
                        // just check if it's a local variable and assume it is global if not
                        if (locals.has(expr.name)) {
                            return ["(local.get $" + expr.name + ")"];
                        }
                        else {
                            return ["(global.get $" + expr.name + ")"];
                        }
                    case "binop": {
                        var lhsExprs = codeGenExpr(expr.lhs, locals);
                        var rhsExprs = codeGenExpr(expr.rhs, locals);
                        var opstmts = opStmts(expr.op);
                        return __spreadArrays(lhsExprs, rhsExprs, opstmts);
                    }
                    case "uniop": {
                        var oprdExprs = codeGenExpr(expr.oprd, locals);
                        var uopstmts = uopStmts(expr.uop, oprdExprs);
                        return uopstmts;
                    }
                    case "parenthesized": {
                        var contExpr = codeGenExpr(expr.content, locals);
                        return contExpr;
                    }
                    case "call":
                        var valStmts = expr.args.map(function (e) { return codeGenExpr(e, locals); }).flat();
                        var toCall = expr.name;
                        if (expr.name === "print") {
                            switch (expr.args[0].a) {
                                case "bool":
                                    toCall = "print_bool";
                                    break;
                                case "int":
                                    toCall = "print_num";
                                    break;
                                case "none":
                                    toCall = "print_none";
                                    break;
                            }
                        }
                        valStmts.push("(call $" + toCall + ")");
                        return valStmts;
                }
            }
            exports.codeGenExpr = codeGenExpr;
            function codeGenStmt(stmt, locals) {
                switch (stmt.tag) {
                    case "define":
                        var withParamsAndVariables_1 = new Map(locals.entries());
                        // Construct the environment for the function body
                        var variables = variableNames(stmt.body);
                        variables.forEach(function (v) { return withParamsAndVariables_1.set(v, true); });
                        stmt.params.forEach(function (p) { return withParamsAndVariables_1.set(p.name, true); });
                        // Construct the code for params and variable declarations in the body
                        var params = stmt.params.map(function (p) { return "(param $" + p.name + " i32)"; }).join(" ");
                        var varDecls = variables.map(function (v) { return "(local $" + v + " i32)"; }).join("\n");
                        var stmts = stmt.body.map(function (s) { return codeGenStmt(s, withParamsAndVariables_1); }).flat();
                        var stmtsBody = stmts.join("\n");
                        return ["(func $" + stmt.name + " " + params + " (result i32)\n        (local $scratch i32)\n        " + varDecls + "\n        " + stmtsBody + "\n        (i32.const 0))"];
                    case "if":
                        var ifCode = "";
                        for (var i = 0; i < stmt.ifs.length; i++) {
                            if (i == 0) {
                                var cond = codeGenExpr(stmt.ifs[i].condition, locals).flat();
                                var condCode = cond.join("\n");
                                var ifbody = stmt.ifs[i].body.map(function (s) { return codeGenStmt(s, withParamsAndVariables_1); }).flat();
                                var bodyCode = ifbody.join("\n");
                                var exifCode = ("\n          " + condCode + "\n          (if\n\n            (then\n\n              " + bodyCode + "\n            )\n          ");
                                ifCode = [ifCode, exifCode].flat().join("\n");
                            }
                            else {
                                var cond = codeGenExpr(stmt.ifs[i].condition, locals).flat();
                                var condCode = cond.join("\n");
                                var ifbody = stmt.ifs[i].body.map(function (s) { return codeGenStmt(s, withParamsAndVariables_1); }).flat();
                                var bodyCode = ifbody.join("\n");
                                var exifCode = ("\n          (else\n          " + condCode + "\n          (if\n          (then\n            " + bodyCode + "\n          )\n          ");
                                ifCode = [ifCode, exifCode].flat().join("\n");
                            }
                        }
                        if ("else" in stmt) {
                            var elsebody = stmt.else.map(function (s) { return codeGenStmt(s, withParamsAndVariables_1); }).flat();
                            var bodyCode = elsebody.join("\n");
                            var exifCode = ("\n        (else\n          " + bodyCode + "\n        )\n        ");
                            ifCode = [ifCode, exifCode].flat().join("\n");
                        }
                        ifCode = [ifCode, ")".repeat(stmt.ifs.length * 2 - 2), ")"].flat().join("");
                        return [ifCode];
                    case "while":
                        var looplabel = "loop" + LoopLabel.toString();
                        var blocklabel = "block" + LoopLabel.toString();
                        var whilecond = codeGenExpr(stmt.condition, locals).flat();
                        var whilecondCode = whilecond.join("\n");
                        var whilebody = stmt.body.map(function (s) { return codeGenStmt(s, locals); }).flat();
                        var whilebodyCode = whilebody.join("\n");
                        var whileCode = "\n      (block $" + blocklabel + "\n        (loop $" + looplabel + "\n          " + whilecondCode + "\n          i32.eqz\n          br_if $" + blocklabel + "\n          " + whilebodyCode + "\n          br $" + looplabel + "\n        )\n      )\n      ";
                        return [whileCode];
                    case "return":
                        var valStmts = codeGenExpr(stmt.value, locals);
                        valStmts.push("return");
                        return valStmts;
                    case "assign":
                        var valStmts = codeGenExpr(stmt.value, locals);
                        if (locals.has(stmt.name)) {
                            valStmts.push("(local.set $" + stmt.name + ")");
                        }
                        else {
                            valStmts.push("(global.set $" + stmt.name + ")");
                        }
                        return valStmts;
                    case "vardef":
                        var valStmts = codeGenExpr(stmt.value, locals);
                        if (locals.has(stmt.name)) {
                            valStmts.push("(local.set $" + stmt.name + ")");
                        }
                        else {
                            valStmts.push("(global.set $" + stmt.name + ")");
                        }
                        return valStmts;
                    case "expr":
                        var result = codeGenExpr(stmt.expr, locals);
                        result.push("(local.set $scratch)");
                        return result;
                }
            }
            exports.codeGenStmt = codeGenStmt;
            function compile(source) {
                var ast = parser_1.parseProgram(source);
                ast = tc_1.tcProgram(ast);
                var emptyEnv = new Map();
                var _a = varsFunsStmts(ast), vars = _a[0], funs = _a[1], stmts = _a[2];
                var funsCode = funs.map(function (f) { return codeGenStmt(f, emptyEnv); }).map(function (f) { return f.join("\n"); });
                var allFuns = funsCode.join("\n\n");
                var varDecls = vars.map(function (v) { return "(global $" + v + " (mut i32) (i32.const 0))"; }).join("\n");
                var allStmts = stmts.map(function (s) { return codeGenStmt(s, emptyEnv); }).flat();
                var main = __spreadArrays(["(local $scratch i32)"], allStmts).join("\n");
                var lastStmt = ast[ast.length - 1];
                var isExpr = lastStmt.tag === "expr";
                var retType = "";
                var retVal = "";
                if (isExpr) {
                    retType = "(result i32)";
                    retVal = "(local.get $scratch)";
                }
                return "\n    (module\n      (func $print_num (import \"imports\" \"print_num\") (param i32) (result i32))\n      (func $print_bool (import \"imports\" \"print_bool\") (param i32) (result i32))\n      (func $print_none (import \"imports\" \"print_none\")  (result i32))\n      " + varDecls + "\n      " + allFuns + "\n      (func (export \"_start\") " + retType + "\n        " + main + "\n        " + retVal + "\n      )\n    ) \n  ";
            }
            exports.compile = compile;
            /***/ 
        }),
        /***/ "./parser.ts": 
        /*!*******************!*\
          !*** ./parser.ts ***!
          \*******************/
        /***/ (function (__unused_webpack_module, exports, __webpack_require__) {
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.traverseArguments = exports.traverseExpr = exports.traverseParameters = exports.traverseType = exports.traverseAssignment = exports.traverseBody = exports.traverseIf = exports.traverseStmt = exports.traverseStmts = exports.parseProgram = void 0;
            var lezer_python_1 = __webpack_require__(/*! lezer-python */ "./node_modules/lezer-python/dist/index.cjs");
            var ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
            function parseProgram(source) {
                var t = lezer_python_1.parser.parse(source).cursor();
                return traverseStmts(source, t);
            }
            exports.parseProgram = parseProgram;
            function traverseStmts(s, t) {
                // The top node in the program is a Script node with a list of children
                // that are various statements
                t.firstChild();
                var stmts = [];
                do {
                    stmts.push(traverseStmt(s, t));
                } while (t.nextSibling()); // t.nextSibling() returns false when it reaches
                //  the end of the list of children
                return stmts;
            }
            exports.traverseStmts = traverseStmts;
            /*
              Invariant â€“ t must focus on the same node at the end of the traversal
            */
            function traverseStmt(s, t) {
                switch (t.type.name) {
                    case "ReturnStatement":
                        t.firstChild(); // Focus return keyword
                        t.nextSibling(); // Focus expression
                        var value = traverseExpr(s, t);
                        t.parent();
                        return { tag: "return", value: value };
                    case "AssignStatement":
                        return traverseAssignment(s, t);
                    case "IfStatement":
                        return traverseIf(s, t);
                    case "WhileStatement":
                        t.firstChild(); //while
                        t.nextSibling(); //condition
                        var whilecondition = traverseExpr(s, t);
                        t.nextSibling(); //body
                        t.firstChild(); //:
                        var whilebody = traverseBody(s, t);
                        return { tag: "while", condition: whilecondition, body: whilebody };
                    case "ExpressionStatement":
                        t.firstChild(); // The child is some kind of expression, the
                        // ExpressionStatement is just a wrapper with no information
                        var expr = traverseExpr(s, t);
                        t.parent();
                        return { tag: "expr", expr: expr };
                    case "FunctionDefinition":
                        t.firstChild(); // Focus on def
                        t.nextSibling(); // Focus on name of function
                        var name = s.substring(t.from, t.to);
                        t.nextSibling(); // Focus on ParamList
                        var params = traverseParameters(s, t);
                        t.nextSibling(); // Focus on Body or TypeDef
                        var ret = "none";
                        var maybeTD = t;
                        if (maybeTD.type.name === "TypeDef") {
                            t.firstChild();
                            ret = traverseType(s, t);
                            t.parent();
                        }
                        t.nextSibling(); // Focus on single statement (for now)
                        t.firstChild(); // Focus on :
                        var body = [];
                        while (t.nextSibling()) {
                            body.push(traverseStmt(s, t));
                        }
                        t.parent(); // Pop to Body
                        t.parent(); // Pop to FunctionDefinition
                        return {
                            tag: "define",
                            name: name, params: params, body: body, ret: ret
                        };
                }
            }
            exports.traverseStmt = traverseStmt;
            function traverseIf(s, t) {
                var vifs = [];
                t.firstChild();
                do {
                    if (t.type.name == "else") {
                        t.nextSibling();
                        var ebody = traverseBody(s, t);
                        t.parent();
                        return { tag: "if", ifs: vifs, else: ebody };
                    }
                    else if (t.type.name == "elif" || t.type.name == "if") {
                        t.nextSibling();
                        var cond = traverseExpr(s, t);
                        t.nextSibling();
                        var body = traverseBody(s, t);
                        var curif = { tag: "subif", condition: cond, body: body };
                        vifs.push(curif);
                    }
                } while (t.nextSibling());
                t.parent();
                return { tag: "if", ifs: vifs };
            }
            exports.traverseIf = traverseIf;
            function traverseBody(s, t) {
                t.firstChild();
                t.nextSibling();
                var stmts = [];
                do {
                    stmts.push(traverseStmt(s, t));
                } while (t.nextSibling()); // t.nextSibling() returns false when it reaches
                //  the end of the list of children
                t.parent();
                return stmts;
            }
            exports.traverseBody = traverseBody;
            function traverseAssignment(s, t) {
                t.firstChild(); // focused on name (the first child)
                var name = s.substring(t.from, t.to);
                t.nextSibling();
                if (t.type.name === "TypeDef") {
                    t.firstChild();
                    t.nextSibling();
                    var type = traverseType(s, t);
                    t.parent();
                    t.nextSibling();
                    t.nextSibling();
                    var value = traverseExpr(s, t);
                    t.parent();
                    return { tag: "vardef", name: name, value: value, type: type };
                }
                t.nextSibling(); // focused on the value expression
                var value = traverseExpr(s, t);
                t.parent();
                return { tag: "assign", name: name, value: value };
            }
            exports.traverseAssignment = traverseAssignment;
            function traverseType(s, t) {
                switch (t.type.name) {
                    case "VariableName":
                        var name_1 = s.substring(t.from, t.to);
                        if (name_1 != "int" && name_1 != "bool") {
                            throw new Error("Unknown type: " + name_1);
                        }
                        return name_1;
                    default:
                        throw new Error("Unknown type: " + t.type.name);
                }
            }
            exports.traverseType = traverseType;
            function traverseParameters(s, t) {
                t.firstChild(); // Focuses on open paren
                var parameters = [];
                t.nextSibling(); // Focuses on a VariableName
                while (t.type.name !== ")") {
                    var name_2 = s.substring(t.from, t.to);
                    t.nextSibling(); // Focuses on "TypeDef", hopefully, or "," if mistake
                    var nextTagName = t.type.name; // NOTE(joe): a bit of a hack so the next line doesn't if-split
                    if (nextTagName !== "TypeDef") {
                        throw new Error("Missed type annotation for parameter " + name_2);
                    }
                    ;
                    t.firstChild(); // Enter TypeDef
                    t.nextSibling(); // Focuses on type itself
                    var typ = traverseType(s, t);
                    t.parent();
                    t.nextSibling(); // Move on to comma or ")"
                    parameters.push({ name: name_2, typ: typ });
                    t.nextSibling(); // Focuses on a VariableName
                }
                t.parent(); // Pop to ParamList
                return parameters;
            }
            exports.traverseParameters = traverseParameters;
            function traverseExpr(s, t) {
                switch (t.type.name) {
                    case "Boolean":
                        if (s.substring(t.from, t.to) === "True") {
                            return { tag: "true" };
                        }
                        else {
                            return { tag: "false" };
                        }
                    case "Number":
                        return { tag: "number", value: Number(s.substring(t.from, t.to)) };
                    case "None":
                        return { tag: "none" };
                    case "VariableName":
                        return { tag: "id", name: s.substring(t.from, t.to) };
                    case "CallExpression":
                        t.firstChild(); // Focus name
                        var name = s.substring(t.from, t.to);
                        t.nextSibling(); // Focus ArgList
                        t.firstChild(); // Focus open paren
                        var args = traverseArguments(t, s);
                        var result = { tag: "call", name: name, args: args };
                        t.parent();
                        return result;
                    case "BinaryExpression":
                        t.firstChild(); // go to lhs
                        var lhsExpr = traverseExpr(s, t);
                        t.nextSibling(); // go to op
                        var opStr = s.substring(t.from, t.to);
                        if (!ast_1.isOp(opStr)) {
                            throw new Error("Unknown or unhandled binary op: " + opStr);
                        }
                        t.nextSibling(); // go to rhs
                        var rhsExpr = traverseExpr(s, t);
                        t.parent();
                        return {
                            tag: "binop",
                            op: opStr,
                            lhs: lhsExpr,
                            rhs: rhsExpr
                        };
                    case "ParenthesizedExpression":
                        t.firstChild();
                        t.nextSibling();
                        var cont = traverseExpr(s, t);
                        t.parent();
                        return {
                            tag: "parenthesized",
                            content: cont
                        };
                    case "UnaryExpression":
                        t.firstChild(); // go to op
                        var uopStr = s.substring(t.from, t.to);
                        if (!ast_1.isUop(uopStr)) {
                            throw new Error("Unknown or unhandled unary op: " + uopStr);
                        }
                        t.nextSibling(); // go to operand
                        var operand = traverseExpr(s, t);
                        t.parent();
                        return {
                            tag: "uniop",
                            uop: uopStr,
                            oprd: operand
                        };
                }
            }
            exports.traverseExpr = traverseExpr;
            function traverseArguments(c, s) {
                c.firstChild(); // Focuses on open paren
                var args = [];
                c.nextSibling();
                while (c.type.name !== ")") {
                    var expr = traverseExpr(s, c);
                    args.push(expr);
                    c.nextSibling(); // Focuses on either "," or ")"
                    c.nextSibling(); // Focuses on a VariableName
                }
                c.parent(); // Pop to ArgList
                return args;
            }
            exports.traverseArguments = traverseArguments;
            /***/ 
        }),
        /***/ "./tc.ts": 
        /*!***************!*\
          !*** ./tc.ts ***!
          \***************/
        /***/ (function (__unused_webpack_module, exports, __webpack_require__) {
            var __assign = (this && this.__assign) || function () {
                __assign = Object.assign || function (t) {
                    for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p in s)
                            if (Object.prototype.hasOwnProperty.call(s, p))
                                t[p] = s[p];
                    }
                    return t;
                };
                return __assign.apply(this, arguments);
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            exports.tcProgram = exports.tcSubif = exports.tcStmt = exports.tcExpr = void 0;
            var ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
            function tcExpr(e, functions, variables) {
                switch (e.tag) {
                    case "number": return __assign(__assign({}, e), { a: "int" });
                    case "true": return __assign(__assign({}, e), { a: "bool" });
                    case "false": return __assign(__assign({}, e), { a: "bool" });
                    case "none": return __assign(__assign({}, e), { a: "none" });
                    case "binop": {
                        e.lhs = tcExpr(e.lhs, functions, variables);
                        e.rhs = tcExpr(e.rhs, functions, variables);
                        switch (e.op) {
                            case "+":
                                if (e.lhs.a != "int" || e.rhs.a != "int") {
                                    throw new Error("Invalid Operands for " + e.op);
                                }
                                return __assign(__assign({}, e), { a: "int" });
                            case "-":
                                if (e.lhs.a != "int" || e.rhs.a != "int") {
                                    throw new Error("Invalid Operands for " + e.op);
                                }
                                return __assign(__assign({}, e), { a: "int" });
                            case "*":
                                if (e.lhs.a != "int" || e.rhs.a != "int") {
                                    throw new Error("Invalid Operands for " + e.op);
                                }
                                return __assign(__assign({}, e), { a: "int" });
                            case "//":
                                if (e.lhs.a != "int" || e.rhs.a != "int") {
                                    throw new Error("Invalid Operands for " + e.op);
                                }
                                return __assign(__assign({}, e), { a: "int" });
                            case "%":
                                if (e.lhs.a != "int" || e.rhs.a != "int") {
                                    throw new Error("Invalid Operands for " + e.op);
                                }
                                return __assign(__assign({}, e), { a: "int" });
                            case "==":
                                if (!((e.lhs.a == "int" && e.rhs.a == "int") || (e.lhs.a == "bool" && e.rhs.a == "bool"))) {
                                    throw new Error("Invalid Operands for " + e.op);
                                }
                                return __assign(__assign({}, e), { a: "bool" });
                            case "!=":
                                if (!((e.lhs.a == "int" && e.rhs.a == "int") || (e.lhs.a == "bool" && e.rhs.a == "bool"))) {
                                    throw new Error("Invalid Operands for " + e.op);
                                }
                                return __assign(__assign({}, e), { a: "bool" });
                            case "<=":
                                if (!(e.lhs.a == "int" && e.rhs.a == "int")) {
                                    throw new Error("Invalid Operands for " + e.op);
                                }
                                return __assign(__assign({}, e), { a: "bool" });
                            case ">=":
                                if (!(e.lhs.a == "int" && e.rhs.a == "int")) {
                                    throw new Error("Invalid Operands for " + e.op);
                                }
                                return __assign(__assign({}, e), { a: "bool" });
                            case "<":
                                if (!(e.lhs.a == "int" && e.rhs.a == "int")) {
                                    throw new Error("Invalid Operands for " + e.op);
                                }
                                return __assign(__assign({}, e), { a: "bool" });
                            case ">":
                                if (!(e.lhs.a == "int" && e.rhs.a == "int")) {
                                    throw new Error("Invalid Operands for " + e.op);
                                }
                                return __assign(__assign({}, e), { a: "bool" });
                            default: throw new Error("Unhandled op " + e.op);
                        }
                    }
                    case "uniop": {
                        e.oprd = tcExpr(e.oprd, functions, variables);
                        switch (e.uop) {
                            case "not":
                                if (e.oprd.a != "bool") {
                                    throw new Error("Invalid Operand for " + e.uop);
                                }
                                return __assign(__assign({}, e), { a: "bool" });
                            case "-":
                                if (e.oprd.a != "int") {
                                    throw new Error("Invalid Operand for " + e.uop);
                                }
                                return __assign(__assign({}, e), { a: "int" });
                        }
                    }
                    case "parenthesized": {
                        e.content = tcExpr(e.content, functions, variables);
                        return __assign(__assign({}, e), { a: e.content.a });
                    }
                    case "id": return __assign(__assign({}, e), { a: variables.get(e.name) });
                    case "call":
                        if (e.name === "print") {
                            if (e.args.length !== 1) {
                                throw new Error("print expects a single argument");
                            }
                            var newArgs_1 = [tcExpr(e.args[0], functions, variables)];
                            var res = __assign(__assign({}, e), { a: "none", args: newArgs_1 });
                            return res;
                        }
                        if (!functions.has(e.name)) {
                            throw new Error("function " + e.name + " not found");
                        }
                        var _a = functions.get(e.name), args = _a[0], ret = _a[1];
                        if (args.length !== e.args.length) {
                            throw new Error("Expected " + args.length + " arguments but got " + e.args.length);
                        }
                        var newArgs = args.map(function (a, i) {
                            var argtyp = tcExpr(e.args[i], functions, variables);
                            if (a !== argtyp.a) {
                                throw new Error("Got " + argtyp + " as argument " + (i + 1) + ", expected " + a);
                            }
                            return argtyp;
                        });
                        return __assign(__assign({}, e), { a: ret, args: newArgs });
                }
            }
            exports.tcExpr = tcExpr;
            function tcStmt(s, functions, variables, currentReturn) {
                var localvariables = new Map();
                switch (s.tag) {
                    case "vardef": {
                        if (!ast_1.isLiteral(s.value)) {
                            throw new Error("Cannot assign non literal in variable definition");
                        }
                        var rhs = tcExpr(s.value, functions, variables);
                        if (rhs.a != s.type) {
                            throw new Error("Cannot assign " + rhs + " to type " + s.type);
                        }
                        else {
                            if (localvariables.has(s.name)) {
                                throw new Error("Duplicate definition of " + s.name + " in same scope");
                            }
                            localvariables.set(s.name, s.type);
                            variables.set(s.name, s.type);
                        }
                        return __assign(__assign({}, s), { value: rhs });
                    }
                    case "assign": {
                        var rhs = tcExpr(s.value, functions, variables);
                        if (variables.has(s.name) && variables.get(s.name) !== rhs.a) {
                            throw new Error("Cannot assign " + rhs + " to " + variables.get(s.name));
                        }
                        else if (!variables.has(s.name)) {
                            throw new Error("Assignment before definition " + s.name);
                        }
                        return __assign(__assign({}, s), { value: rhs });
                    }
                    case "define": {
                        var bodyvars_1 = new Map(variables.entries());
                        s.params.forEach(function (p) { bodyvars_1.set(p.name, p.typ); });
                        var newStmts = s.body.map(function (bs) { return tcStmt(bs, functions, bodyvars_1, s.ret); });
                        return __assign(__assign({}, s), { body: newStmts });
                    }
                    case "if": {
                        var newifs = [];
                        for (var _i = 0, _a = s.ifs; _i < _a.length; _i++) {
                            var i = _a[_i];
                            newifs.push(tcSubif(i, functions, variables, currentReturn));
                        }
                        if ('else' in s) {
                            var newelse = s.else.map(function (bs) { return tcStmt(bs, functions, variables, currentReturn); });
                            return __assign(__assign({}, s), { ifs: newifs, else: newelse });
                        }
                        return __assign(__assign({}, s), { ifs: newifs });
                    }
                    case "while": {
                        var newbody = s.body.map(function (bs) { return tcStmt(bs, functions, variables, currentReturn); });
                        return __assign(__assign({}, s), { condition: tcExpr(s.condition, functions, variables), body: newbody });
                    }
                    case "expr": {
                        var ret = tcExpr(s.expr, functions, variables);
                        return __assign(__assign({}, s), { expr: ret });
                    }
                    case "return": {
                        var valTyp = tcExpr(s.value, functions, variables);
                        if (valTyp.a !== currentReturn) {
                            throw new Error(valTyp + " returned but " + currentReturn + " expected.");
                        }
                        return __assign(__assign({}, s), { value: valTyp });
                    }
                }
            }
            exports.tcStmt = tcStmt;
            function tcSubif(i, functions, variables, currentReturn) {
                i.condition = tcExpr(i.condition, functions, variables);
                if (i.condition.a != "bool") {
                    throw new Error("Conditional statement not typed boolean");
                }
                var newbody = i.body.map(function (bs) { return tcStmt(bs, functions, variables, currentReturn); });
                for (var _i = 0, _a = i.body; _i < _a.length; _i++) {
                    var istmt = _a[_i];
                    if (istmt.tag == "vardef") {
                        throw new Error("Variable definition in If block");
                    }
                }
                return __assign(__assign({}, i), { body: newbody });
            }
            exports.tcSubif = tcSubif;
            function tcProgram(p) {
                var functions = new Map();
                p.forEach(function (s) {
                    if (s.tag === "define") {
                        functions.set(s.name, [s.params.map(function (p) { return p.typ; }), s.ret]);
                    }
                });
                var globals = new Map();
                return p.map(function (s) {
                    if (s.tag === "vardef") {
                        if (!ast_1.isLiteral(s.value)) {
                            throw new Error("Cannot assign non literal in variable definition");
                        }
                        var rhs = tcExpr(s.value, functions, globals);
                        if (rhs.a != s.type) {
                            throw new Error("Cannot assign " + rhs + " to type " + s.type);
                        }
                        else {
                            if (globals.has(s.name)) {
                                throw new Error("Duplicate definition of " + s.name + " in same scope");
                            }
                        }
                        globals.set(s.name, rhs.a);
                        return __assign(__assign({}, s), { value: rhs });
                    }
                    else {
                        var res = tcStmt(s, functions, globals, "none");
                        return res;
                    }
                });
            }
            exports.tcProgram = tcProgram;
            /***/ 
        }),
        /***/ "./webstart.ts": 
        /*!*********************!*\
          !*** ./webstart.ts ***!
          \*********************/
        /***/ (function (__unused_webpack_module, exports, __webpack_require__) {
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __generator = (this && this.__generator) || function (thisArg, body) {
                var _ = { label: 0, sent: function () { if (t[0] & 1)
                        throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
                return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
                function verb(n) { return function (v) { return step([n, v]); }; }
                function step(op) {
                    if (f)
                        throw new TypeError("Generator is already executing.");
                    while (_)
                        try {
                            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                                return t;
                            if (y = 0, t)
                                op = [op[0] & 2, t.value];
                            switch (op[0]) {
                                case 0:
                                case 1:
                                    t = op;
                                    break;
                                case 4:
                                    _.label++;
                                    return { value: op[1], done: false };
                                case 5:
                                    _.label++;
                                    y = op[1];
                                    op = [0];
                                    continue;
                                case 7:
                                    op = _.ops.pop();
                                    _.trys.pop();
                                    continue;
                                default:
                                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                        _ = 0;
                                        continue;
                                    }
                                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                        _.label = op[1];
                                        break;
                                    }
                                    if (op[0] === 6 && _.label < t[1]) {
                                        _.label = t[1];
                                        t = op;
                                        break;
                                    }
                                    if (t && _.label < t[2]) {
                                        _.label = t[2];
                                        _.ops.push(op);
                                        break;
                                    }
                                    if (t[2])
                                        _.ops.pop();
                                    _.trys.pop();
                                    continue;
                            }
                            op = body.call(thisArg, _);
                        }
                        catch (e) {
                            op = [6, e];
                            y = 0;
                        }
                        finally {
                            f = t = 0;
                        }
                    if (op[0] & 5)
                        throw op[1];
                    return { value: op[0] ? op[1] : void 0, done: true };
                }
            };
            Object.defineProperty(exports, "__esModule", ({ value: true }));
            var compiler_1 = __webpack_require__(/*! ./compiler */ "./compiler.ts");
            document.addEventListener("DOMContentLoaded", function () {
                return __awaiter(void 0, void 0, void 0, function () {
                    function display(arg) {
                        var elt = document.createElement("pre");
                        document.getElementById("output").innerText = arg;
                        console.log("Logging from WASM: ", arg);
                    }
                    var importObject, runButton, userCode;
                    return __generator(this, function (_a) {
                        importObject = {
                            imports: {
                                print_num: function (arg) {
                                    console.log("Logging from WASM: ", arg);
                                    display(String(arg));
                                    return arg;
                                },
                                print_bool: function (arg) {
                                    if (arg === 0) {
                                        display("False");
                                    }
                                    else {
                                        display("True");
                                    }
                                    return arg;
                                },
                                print_none: function (arg) {
                                    display("None");
                                    return arg;
                                }
                            },
                        };
                        runButton = document.getElementById("run");
                        userCode = document.getElementById("user-code");
                        runButton.addEventListener("click", function () {
                            return __awaiter(void 0, void 0, void 0, function () {
                                var program, output, wat, code, result, e_1;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            program = userCode.value;
                                            output = document.getElementById("output");
                                            _a.label = 1;
                                        case 1:
                                            _a.trys.push([1, 3, , 4]);
                                            wat = compiler_1.compile(program);
                                            code = document.getElementById("generated-code");
                                            code.textContent = wat;
                                            return [4 /*yield*/, compiler_1.run(wat, importObject)];
                                        case 2:
                                            result = _a.sent();
                                            output.textContent += String(result);
                                            output.setAttribute("style", "color: black");
                                            return [3 /*break*/, 4];
                                        case 3:
                                            e_1 = _a.sent();
                                            console.error(e_1);
                                            output.textContent = String(e_1);
                                            output.setAttribute("style", "color: red");
                                            return [3 /*break*/, 4];
                                        case 4: return [2 /*return*/];
                                    }
                                });
                            });
                        });
                        userCode.value = localStorage.getItem("program");
                        userCode.addEventListener("keypress", function () {
                            return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    localStorage.setItem("program", userCode.value);
                                    return [2 /*return*/];
                                });
                            });
                        });
                        return [2 /*return*/];
                    });
                });
            });
            /***/ 
        }),
        /***/ "wabt": 
        /*!***********************!*\
          !*** external "wabt" ***!
          \***********************/
        /***/ (function (module) {
            module.exports = wabt;
            /***/ 
        })
        /******/ 
    });
    /************************************************************************/
    /******/ // The module cache
    /******/ var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/ function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/ if (__webpack_module_cache__[moduleId]) {
            /******/ return __webpack_module_cache__[moduleId].exports;
            /******/ }
        /******/ // Create a new module (and put it into the cache)
        /******/ var module = __webpack_module_cache__[moduleId] = {
            /******/ // no module.id needed
            /******/ // no module.loaded needed
            /******/ exports: {}
            /******/ 
        };
        /******/
        /******/ // Execute the module function
        /******/ __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/ return module.exports;
        /******/ 
    }
    /******/
    /************************************************************************/
    /******/ // startup
    /******/ // Load entry module
    /******/ // This entry module is referenced by other modules so it can't be inlined
    /******/ __webpack_require__("./webstart.ts");
    /******/ 
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9sZXplci1weXRob24vZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvbGV6ZXItdHJlZS9kaXN0L3RyZWUuY2pzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL2xlemVyL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vYXN0LnRzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vY29tcGlsZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9wYXJzZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi90Yy50cyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL3dlYnN0YXJ0LnRzIiwid2VicGFjazovL3dlYi1hc20taml0L2V4dGVybmFsIFwid2FidFwiIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxZQUFZLG1CQUFPLENBQUMsa0RBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzREFBc0Q7QUFDekQ7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FB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a0NBQWtDLFFBQVEsTUFBTSxHQUFHLE1BQU0sR0FBRyxXQUFXLGFBQWEsYUFBYSxhQUFhLFlBQVksa0NBQWtDLFFBQVEsU0FBUyxhQUFhLGFBQWEsYUFBYSxZQUFZLHNDQUFzQyxRQUFRLFNBQVMsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsWUFBWSxzQ0FBc0MsUUFBUSxTQUFTLGFBQWEsYUFBYSxZQUFZLEVBQUUsbUNBQW1DLFFBQVEsU0FBUyxhQUFhLGFBQWEsYUFBYSxhQUFhLFlBQVkscUNBQXFDLFFBQVEsU0FBUyxhQUFhLGFBQWEsYUFBYSxZQUFZLHNDQUFzQyxRQUFRLFNBQVMsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsSUFBSSxLQUFLLElBQUksYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLFlBQVksa0NBQWtDLFFBQVEsU0FBUyxhQUFhLGFBQWEsYUFBYSxZQUFZLHNDQUFzQyxRQUFRLFNBQVMsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsWUFBWSxrQ0FBa0MsUUFBUSxTQUFTLG9CQUFvQixhQUFhLGFBQWEsYUFBYSxZQUFZLHNDQUFzQyxRQUFRLFNBQVMsb0JBQW9CLGFBQWEsYUFBYSxhQUFhLFlBQVksa0NBQWtDLFFBQVEsU0FBUyxhQUFhLGFBQWEsYUFBYSxhQUFhLFlBQVksc0NBQXNDLFFBQVEsU0FBUyxhQUFhLGFBQWEsYUFBYSxhQUFhLFlBQVksa0NBQWtDLFFBQVEsU0FBUyxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxZQUFZLHNDQUFzQyxRQUFRLFNBQVMsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsWUFBWSxxQ0FBcUMsUUFBUSxTQUFTLGFBQWEsYUFBYSxhQUFhLFlBQVkscUNBQXFDLFFBQVEsU0FBUyxhQUFhLGFBQWEsWUFBWSxFQUFFLG9DQUFvQyxRQUFRLFNBQVMsYUFBYSxhQUFhLFlBQVksRUFBRSxHQUFHLCtCQUErQixRQUFRLFNBQVMsMkJBQTJCLGFBQWEsYUFBYSxZ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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxhQUFh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cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbGV6ZXIgPSByZXF1aXJlKCdsZXplcicpO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHByaW50S2V5d29yZCA9IDEsXG4gIGluZGVudCA9IDE2MixcbiAgZGVkZW50ID0gMTYzLFxuICBuZXdsaW5lJDEgPSAxNjQsXG4gIG5ld2xpbmVCcmFja2V0ZWQgPSAxNjUsXG4gIG5ld2xpbmVFbXB0eSA9IDE2NixcbiAgZW9mID0gMTY3LFxuICBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IDIxLFxuICBUdXBsZUV4cHJlc3Npb24gPSA0NyxcbiAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA0OCxcbiAgQXJyYXlFeHByZXNzaW9uID0gNTIsXG4gIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA1NSxcbiAgRGljdGlvbmFyeUV4cHJlc3Npb24gPSA1NixcbiAgRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uID0gNTksXG4gIFNldEV4cHJlc3Npb24gPSA2MCxcbiAgU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA2MSxcbiAgQXJnTGlzdCA9IDYzLFxuICBQYXJhbUxpc3QgPSAxMjE7XG5cbmNvbnN0IG5ld2xpbmUgPSAxMCwgY2FycmlhZ2VSZXR1cm4gPSAxMywgc3BhY2UgPSAzMiwgdGFiID0gOSwgaGFzaCA9IDM1LCBwYXJlbk9wZW4gPSA0MCwgZG90ID0gNDY7XG5cbmNvbnN0IGJyYWNrZXRlZCA9IFtcbiAgUGFyZW50aGVzaXplZEV4cHJlc3Npb24sIFR1cGxlRXhwcmVzc2lvbiwgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24sIEFycmF5RXhwcmVzc2lvbiwgQXJyYXlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbixcbiAgRGljdGlvbmFyeUV4cHJlc3Npb24sIERpY3Rpb25hcnlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiwgU2V0RXhwcmVzc2lvbiwgU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24sIEFyZ0xpc3QsIFBhcmFtTGlzdFxuXTtcblxubGV0IGNhY2hlZEluZGVudCA9IDAsIGNhY2hlZElucHV0ID0gbnVsbCwgY2FjaGVkUG9zID0gMDtcbmZ1bmN0aW9uIGdldEluZGVudChpbnB1dCwgcG9zKSB7XG4gIGlmIChwb3MgPT0gY2FjaGVkUG9zICYmIGlucHV0ID09IGNhY2hlZElucHV0KSByZXR1cm4gY2FjaGVkSW5kZW50XG4gIGNhY2hlZElucHV0ID0gaW5wdXQ7IGNhY2hlZFBvcyA9IHBvcztcbiAgcmV0dXJuIGNhY2hlZEluZGVudCA9IGdldEluZGVudElubmVyKGlucHV0LCBwb3MpXG59XG5cbmZ1bmN0aW9uIGdldEluZGVudElubmVyKGlucHV0LCBwb3MpIHtcbiAgZm9yIChsZXQgaW5kZW50ID0gMDs7IHBvcysrKSB7XG4gICAgbGV0IGNoID0gaW5wdXQuZ2V0KHBvcyk7XG4gICAgaWYgKGNoID09IHNwYWNlKSBpbmRlbnQrKztcbiAgICBlbHNlIGlmIChjaCA9PSB0YWIpIGluZGVudCArPSA4IC0gKGluZGVudCAlIDgpO1xuICAgIGVsc2UgaWYgKGNoID09IG5ld2xpbmUgfHwgY2ggPT0gY2FycmlhZ2VSZXR1cm4gfHwgY2ggPT0gaGFzaCkgcmV0dXJuIC0xXG4gICAgZWxzZSByZXR1cm4gaW5kZW50XG4gIH1cbn1cblxuY29uc3QgbmV3bGluZXMgPSBuZXcgbGV6ZXIuRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCB0b2tlbiwgc3RhY2spID0+IHtcbiAgbGV0IG5leHQgPSBpbnB1dC5nZXQodG9rZW4uc3RhcnQpO1xuICBpZiAobmV4dCA8IDApIHtcbiAgICB0b2tlbi5hY2NlcHQoZW9mLCB0b2tlbi5zdGFydCk7XG4gIH0gZWxzZSBpZiAobmV4dCAhPSBuZXdsaW5lICYmIG5leHQgIT0gY2FycmlhZ2VSZXR1cm4pIDsgZWxzZSBpZiAoc3RhY2suc3RhcnRPZihicmFja2V0ZWQpICE9IG51bGwpIHtcbiAgICB0b2tlbi5hY2NlcHQobmV3bGluZUJyYWNrZXRlZCwgdG9rZW4uc3RhcnQgKyAxKTtcbiAgfSBlbHNlIGlmIChnZXRJbmRlbnQoaW5wdXQsIHRva2VuLnN0YXJ0ICsgMSkgPCAwKSB7XG4gICAgdG9rZW4uYWNjZXB0KG5ld2xpbmVFbXB0eSwgdG9rZW4uc3RhcnQgKyAxKTtcbiAgfSBlbHNlIHtcbiAgICB0b2tlbi5hY2NlcHQobmV3bGluZSQxLCB0b2tlbi5zdGFydCArIDEpO1xuICB9XG59LCB7Y29udGV4dHVhbDogdHJ1ZSwgZmFsbGJhY2s6IHRydWV9KTtcblxuY29uc3QgaW5kZW50YXRpb24gPSBuZXcgbGV6ZXIuRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCB0b2tlbiwgc3RhY2spID0+IHtcbiAgbGV0IHByZXYgPSBpbnB1dC5nZXQodG9rZW4uc3RhcnQgLSAxKSwgZGVwdGg7XG4gIGlmICgocHJldiA9PSBuZXdsaW5lIHx8IHByZXYgPT0gY2FycmlhZ2VSZXR1cm4pICYmXG4gICAgICAoZGVwdGggPSBnZXRJbmRlbnQoaW5wdXQsIHRva2VuLnN0YXJ0KSkgPj0gMCAmJlxuICAgICAgZGVwdGggIT0gc3RhY2suY29udGV4dC5kZXB0aCAmJlxuICAgICAgc3RhY2suc3RhcnRPZihicmFja2V0ZWQpID09IG51bGwpXG4gICAgdG9rZW4uYWNjZXB0KGRlcHRoIDwgc3RhY2suY29udGV4dC5kZXB0aCA/IGRlZGVudCA6IGluZGVudCwgdG9rZW4uc3RhcnQpO1xufSk7XG5cbmZ1bmN0aW9uIEluZGVudExldmVsKHBhcmVudCwgZGVwdGgpIHtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgdGhpcy5oYXNoID0gKHBhcmVudCA/IHBhcmVudC5oYXNoICsgcGFyZW50Lmhhc2ggPDwgOCA6IDApICsgZGVwdGggKyAoZGVwdGggPDwgNCk7XG59XG5cbmNvbnN0IHRvcEluZGVudCA9IG5ldyBJbmRlbnRMZXZlbChudWxsLCAwKTtcblxuY29uc3QgdHJhY2tJbmRlbnQgPSBuZXcgbGV6ZXIuQ29udGV4dFRyYWNrZXIoe1xuICBzdGFydDogdG9wSW5kZW50LFxuICBzaGlmdChjb250ZXh0LCB0ZXJtLCBpbnB1dCwgc3RhY2spIHtcbiAgICByZXR1cm4gdGVybSA9PSBpbmRlbnQgPyBuZXcgSW5kZW50TGV2ZWwoY29udGV4dCwgZ2V0SW5kZW50KGlucHV0LCBzdGFjay5wb3MpKSA6XG4gICAgICB0ZXJtID09IGRlZGVudCA/IGNvbnRleHQucGFyZW50IDogY29udGV4dFxuICB9LFxuICBoYXNoKGNvbnRleHQpIHsgcmV0dXJuIGNvbnRleHQuaGFzaCB9XG59KTtcblxuY29uc3QgbGVnYWN5UHJpbnQgPSBuZXcgbGV6ZXIuRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCB0b2tlbikgPT4ge1xuICBsZXQgcG9zID0gdG9rZW4uc3RhcnQ7XG4gIGZvciAobGV0IHByaW50ID0gXCJwcmludFwiLCBpID0gMDsgaSA8IHByaW50Lmxlbmd0aDsgaSsrLCBwb3MrKylcbiAgICBpZiAoaW5wdXQuZ2V0KHBvcykgIT0gcHJpbnQuY2hhckNvZGVBdChpKSkgcmV0dXJuXG4gIGxldCBlbmQgPSBwb3M7XG4gIGlmICgvXFx3Ly50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoaW5wdXQuZ2V0KHBvcykpKSkgcmV0dXJuXG4gIGZvciAoOzsgcG9zKyspIHtcbiAgICBsZXQgbmV4dCA9IGlucHV0LmdldChwb3MpO1xuICAgIGlmIChuZXh0ID09IHNwYWNlIHx8IG5leHQgPT0gdGFiKSBjb250aW51ZVxuICAgIGlmIChuZXh0ICE9IHBhcmVuT3BlbiAmJiBuZXh0ICE9IGRvdCAmJiBuZXh0ICE9IG5ld2xpbmUgJiYgbmV4dCAhPSBjYXJyaWFnZVJldHVybiAmJiBuZXh0ICE9IGhhc2gpXG4gICAgICB0b2tlbi5hY2NlcHQocHJpbnRLZXl3b3JkLCBlbmQpO1xuICAgIHJldHVyblxuICB9XG59KTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX2lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsYXdhaXQ6NDAsIG9yOjQ4LCBhbmQ6NTAsIGluOjU0LCBub3Q6NTYsIGlzOjU4LCBpZjo2NCwgZWxzZTo2NiwgbGFtYmRhOjcwLCB5aWVsZDo4OCwgZnJvbTo5MCwgYXN5bmM6OTgsIGZvcjoxMDAsIE5vbmU6MTUyLCBUcnVlOjE1NCwgRmFsc2U6MTU0LCBkZWw6MTY4LCBwYXNzOjE3MiwgYnJlYWs6MTc2LCBjb250aW51ZToxODAsIHJldHVybjoxODQsIHJhaXNlOjE5MiwgaW1wb3J0OjE5NiwgYXM6MTk4LCBnbG9iYWw6MjAyLCBub25sb2NhbDoyMDQsIGFzc2VydDoyMDgsIGVsaWY6MjE4LCB3aGlsZToyMjIsIHRyeToyMjgsIGV4Y2VwdDoyMzAsIGZpbmFsbHk6MjMyLCB3aXRoOjIzNiwgZGVmOjI0MCwgY2xhc3M6MjUwfTtcbmNvbnN0IHBhcnNlciA9IGxlemVyLlBhcnNlci5kZXNlcmlhbGl6ZSh7XG4gIHZlcnNpb246IDEzLFxuICBzdGF0ZXM6IFwiIT98T2BRJElYT09PJWNRJElbTycjR2FPT1EkSVMnI0NtJyNDbU9PUSRJUycjQ24nI0NuTydSUSRJV08nI0NsTyh0USRJW08nI0dgT09RJElTJyNHYScjR2FPT1EkSVMnI0RSJyNEUk9PUSRJUycjR2AnI0dgTyliUSRJV08nI0NxTylyUSRJV08nI0RiTypTUSRJV08nI0RmT09RJElTJyNEcycjRHNPKmdPYE8nI0RzTypvT3BPJyNEc08qd08hYk8nI0R0TytTTyN0TycjRHRPK19PJmpPJyNEdE8rak8sVU8nI0R0Ty1sUSRJW08nI0dRT09RJElTJyNHUScjR1FPJ1JRJElXTycjR1BPL09RJElbTycjR1BPT1EkSVMnI0VdJyNFXU8vZ1EkSVdPJyNFXk9PUSRJUycjR08nI0dPTy9xUSRJV08nI0Z9T09RJElWJyNGfScjRn1PL3xRJElXTycjRlBPT1EkSVMnI0ZyJyNGck8wUlEkSVdPJyNGT09PUSRJVicjSFonI0haT09RJElWJyNGfCcjRnxPT1EkSVQnI0ZSJyNGUlFgUSRJWE9PTydSUSRJV08nI0NvTzBhUSRJV08nI0N6TzBoUSRJV08nI0RPTzB2USRJV08nI0dlTzFXUSRJW08nI0VRTydSUSRJV08nI0VST09RJElTJyNFVCcjRVRPT1EkSVMnI0VWJyNFVk9PUSRJUycjRVgnI0VYTzFsUSRJV08nI0VaTzJTUSRJV08nI0VfTy98USRJV08nI0VhTzJnUSRJW08nI0VhTy98USRJV08nI0VkTy9nUSRJV08nI0VnTy9nUSRJV08nI0VrTy9nUSRJV08nI0VuTzJyUSRJV08nI0VwTzJ5USRJV08nI0V1TzNVUSRJV08nI0VxTy9nUSRJV08nI0V1Ty98USRJV08nI0V3Ty98USRJV08nI0V8T09RJElTJyNDYycjQ2NPT1EkSVMnI0NkJyNDZE9PUSRJUycjQ2UnI0NlT09RJElTJyNDZicjQ2ZPT1EkSVMnI0NnJyNDZ09PUSRJUycjQ2gnI0NoT09RJElTJyNDaicjQ2pPJ1JRJElXTyw1OHxPJ1JRJElXTyw1OHxPJ1JRJElXTyw1OHxPJ1JRJElXTyw1OHxPJ1JRJElXTyw1OHxPJ1JRJElXTyw1OHxPM1pRJElXTycjRG1PT1EkSVMsNTpXLDU6V08zblEkSVdPLDU6Wk8ze1ElMWBPLDU6Wk80UVEkSVtPLDU5V08wYVEkSVdPLDU5X08wYVEkSVdPLDU5X08wYVEkSVdPLDU5X082cFEkSVdPLDU5X082dVEkSVdPLDU5X082fFEkSVdPLDU5Z083VFEkSVdPJyNHYE84WlEkSVdPJyNHX09PUSRJUycjR18nI0dfT09RJElTJyNEWCcjRFhPOHJRJElXTyw1OV1PJ1JRJElXTyw1OV1POVFRJElXTyw1OV1POVZRJElXTyw1OlBPJ1JRJElXTyw1OlBPT1EkSVMsNTl8LDU5fE85ZVEkSVdPLDU5fE85alEkSVdPLDU6Vk8nUlEkSVdPLDU6Vk8nUlEkSVdPLDU6VE9PUSRJUyw1OlEsNTpRTzl7USRJV08sNTpRTzpRUSRJV08sNTpVT09PTycjRlonI0ZaTzpWT2BPLDU6X09PUSRJUyw1Ol8sNTpfT09PTycjRlsnI0ZbTzpfT3BPLDU6X086Z1EkSVdPJyNEdU9PT08nI0ZdJyNGXU86d08hYk8sNTpgT09RJElTLDU6YCw1OmBPT09PJyNGYCcjRmBPO1NPI3RPLDU6YE9PT08nI0ZhJyNGYU87X08mak8sNTpgT09PTycjRmInI0ZiTztqTyxVTyw1OmBPT1EkSVMnI0ZjJyNGY087dVEkSVtPLDU6ZE8+Z1EkSVtPLDU8a08/UVElR2xPLDU8a08/cVEkSVtPLDU8a09PUSRJUyw1OngsNTp4T0BZUSRJWE8nI0ZrT0FpUSRJV08sNTtUT09RJElWLDU8aSw1PGlPQXRRJElbTycjSFdPQl1RJElXTyw1O2tPT1EkSVMtRTlwLUU5cE9PUSRJViw1O2osNTtqTzNQUSRJV08nI0V3T09RJElULUU5UC1FOVBPQmVRJElbTyw1OVpPRGxRJElbTyw1OWZPRVZRJElXTycjR2JPRWJRJElXTycjR2JPL3xRJElXTycjR2JPRW1RJElXTycjRFFPRXVRJElXTyw1OWpPRXpRJElXTycjR2ZPJ1JRJElXTycjR2ZPL2dRJElXTyw1PVBPT1EkSVMsNT1QLDU9UE8vZ1EkSVdPJyNEfE9PUSRJUycjRH0nI0R9T0ZpUSRJV08nI0ZlT0Z5USRJV08sNTh6T0dYUSRJV08sNTh6TyllUSRJV08sNTpqT0deUSRJW08nI0doT09RJElTLDU6bSw1Om1PT1EkSVMsNTp1LDU6dU9HcVEkSVdPLDU6eU9IU1EkSVdPLDU6e09PUSRJUycjRmgnI0ZoT0hiUSRJW08sNTp7T0hwUSRJV08sNTp7T0h1USRJV08nI0hZT09RJElTLDU7Tyw1O09PSVRRJElXTycjSFZPT1EkSVMsNTtSLDU7Uk8zVVEkSVdPLDU7Vk8zVVEkSVdPLDU7WU9JZlEkSVtPJyNIW08nUlEkSVdPJyNIW09JcFEkSVdPLDU7W08yclEkSVdPLDU7W08vZ1EkSVdPLDU7YU8vfFEkSVdPLDU7Y09JdVEkSVhPJyNFbE9LT1EkSVpPLDU7XU9OYVEkSVdPJyNIXU8zVVEkSVdPLDU7YU9ObFEkSVdPLDU7Y09OcVEkSVdPLDU7aE8hI2ZRJElbTzFHLmhPISNtUSRJW08xRy5oTyEmXlEkSVtPMUcuaE8hJmhRJElbTzFHLmhPISlSUSRJW08xRy5oTyEpZlEkSVtPMUcuaE8hKXlRJElXTycjR25PISpYUSRJW08nI0dRTy9nUSRJV08nI0duTyEqY1EkSVdPJyNHbU9PUSRJUyw1OlgsNTpYTyEqa1EkSVdPLDU6WE8hKnBRJElXTycjR29PISp7USRJV08nI0dvTyErYFEkSVdPMUcvdU9PUSRJUycjRHEnI0RxT09RJElTMUcvdTFHL3VPT1EkSVMxRy55MUcueU8hLGBRJElbTzFHLnlPISxnUSRJW08xRy55TzBhUSRJV08xRy55TyEtU1EkSVdPMUcvUk9PUSRJUycjRFcnI0RXTy9nUSRJV08sNTlxT09RJElTMUcudzFHLndPIS1aUSRJV08xRy9jTyEta1EkSVdPMUcvY08hLXNRJElXTzFHL2RPJ1JRJElXTycjR2dPIS14USRJV08nI0dnTyEtfVEkSVtPMUcud08hLl9RJElXTyw1OWZPIS9lUSRJV08sNT1WTyEvdVEkSVdPLDU9Vk8hL31RJElXTzFHL2tPITBTUSRJW08xRy9rT09RJElTMUcvaDFHL2hPITBkUSRJV08sNT1RTyExWlEkSVdPLDU9UU8vZ1EkSVdPMUcvb08hMXhRJElXTzFHL3FPITF9USRJW08xRy9xTyEyX1EkSVtPMUcvb09PUSRJUzFHL2wxRy9sT09RJElTMUcvcDFHL3BPT09PLUU5WC1FOVhPT1EkSVMxRy95MUcveU9PT08tRTlZLUU5WU8hMm9RJElXTycjR3pPL2dRJElXTycjR3pPITJ9USRJV08sNTphT09PTy1FOVotRTlaT09RJElTMUcvejFHL3pPT09PLUU5Xi1FOV5PT09PLUU5Xy1FOV9PT09PLUU5YC1FOWBPT1EkSVMtRTlhLUU5YU8hM1lRJUdsTzFHMlZPITN5USRJW08xRzJWTydSUSRJV08sNTxPT09RJElTLDU8Tyw1PE9PT1EkSVMtRTliLUU5Yk9PUSRJUyw1PFYsNTxWT09RJElTLUU5aS1FOWlPT1EkSVYxRzBvMUcwb08vfFEkSVdPJyNGZ08hNGJRJElbTyw1PXJPT1EkSVMxRzFWMUcxVk8hNHlRJElXTzFHMVZPT1EkSVMnI0RTJyNEU08vZ1EkSVdPLDU8fE9PUSRJUyw1PHwsNTx8TyE1T1EkSVdPJyNGU08hNVpRJElXTyw1OWxPITVjUSRJV08xRy9VTyE1bVEkSVtPLDU9UU9PUSRJUzFHMmsxRzJrT09RJElTLDU6aCw1OmhPITZeUSRJV08nI0dQT09RJElTLDU8UCw1PFBPT1EkSVMtRTljLUU5Y08hNm9RJElXTzFHLmZPT1EkSVMxRzBVMUcwVU8hNn1RJElXTyw1PVNPITdfUSRJV08sNT1TTy9nUSRJV08xRzBlTy9nUSRJV08xRzBlTy98USRJV08xRzBnT09RJElTLUU5Zi1FOWZPITdwUSRJV08xRzBnTyE3e1EkSVdPMUcwZ08hOFFRJElXTyw1PXRPIThgUSRJV08sNT10TyE4blEkSVdPLDU9cU8hOVVRJElXTyw1PXFPITlnUSRJWk8xRzBxTyE8dVEkSVpPMUcwdE8hQFFRJElXTyw1PXZPIUBbUSRJV08sNT12TyFAZFEkSVtPLDU9dk8vZ1EkSVdPMUcwdk8hQG5RJElXTzFHMHZPM1VRJElXTzFHMHtPTmxRJElXTzFHMH1PT1EkSVYsNTtXLDU7V08hQHNRJElZTyw1O1dPIUB4USRJWk8xRzB3TyFEWlEkSVdPJyNGb08zVVEkSVdPMUcwd08zVVEkSVdPMUcwd08hRGhRJElXTyw1PXdPIUR1USRJV08sNT13Ty98USRJV08sNT13T09RJElWMUcwezFHMHtPIUR9USRJV08nI0V5TyFFYFElMWBPMUcwfU9PUSRJVjFHMVMxRzFTTzNVUSRJV08xRzFTT09RJElTLDU9WSw1PVlPT1EkSVMnI0RuJyNEbk8vZ1EkSVdPLDU9WU8hRWhRJElXTyw1PVhPIUV7USRJV08sNT1YT09RJElTMUcvczFHL3NPIUZUUSRJV08sNT1aTyFGZVEkSVdPLDU9Wk8hRm1RJElXTyw1PVpPIUdRUSRJV08sNT1aTyFHYlEkSVdPLDU9Wk9PUSRJUzcrJWE3KyVhT09RJElTNyskZTcrJGVPITVjUSRJV083KyRtTyFJVFEkSVdPMUcueU8hSVtRJElXTzFHLnlPT1EkSVMxRy9dMUcvXU9PUSRJUyw1O3AsNTtwTydSUSRJV08sNTtwT09RJElTNyskfTcrJH1PIUljUSRJV083KyR9T09RJElTLUU5Uy1FOVNPT1EkSVM3KyVPNyslT08hSXNRJElXTyw1PVJPJ1JRJElXTyw1PVJPT1EkSVM3KyRjNyskY08hSXhRJElXTzcrJH1PIUpRUSRJV083KyVPTyFKVlEkSVdPMUcycU9PUSRJUzcrJVY3KyVWTyFKZ1EkSVdPMUcycU8hSm9RJElXTzcrJVZPT1EkSVMsNTtvLDU7b08nUlEkSVdPLDU7b08hSnRRJElXTzFHMmxPT1EkSVMtRTlSLUU5Uk8hS2tRJElXTzcrJVpPT1EkSVM3KyVdNyslXU8hS3lRJElXTzFHMmxPIUxoUSRJV083KyVdTyFMbVEkSVdPMUcyck8hTH1RJElXTzFHMnJPIU1WUSRJV083KyVaTyFNW1EkSVdPLDU9Zk8hTXJRJElXTyw1PWZPIU1yUSRJV08sNT1mTyFOUU8hTFFPJyNEd08hTl1PU08nI0d7T09PTzFHL3sxRy97TyFOYlEkSVdPMUcve08hTmpRJUdsTzcrJ3FPIyBaUSRJW08xRzFqUCMgdFEkSVdPJyNGZE9PUSRJUyw1PFIsNTxST09RJElTLUU5ZS1FOWVPT1EkSVM3KyZxNysmcU9PUSRJUzFHMmgxRzJoT09RJElTLDU7biw1O25PT1EkSVMtRTlRLUU5UU9PUSRJUzcrJHA3KyRwTyMhUlEkSVdPLDU8a08jIWxRJElXTyw1PGtPIyF9USRJW08sNTtxTyMjYlEkSVdPMUcybk9PUSRJUy1FOVQtRTlUT09RJElTNysmUDcrJlBPIyNyUSRJV083KyZQT09RJElTNysmUjcrJlJPIyRRUSRJV08nI0hYTy98USRJV083KyZSTyMkZlEkSVdPNysmUk9PUSRJUyw1PFUsNTxVTyMkcVEkSVdPMUczYE9PUSRJUy1FOWgtRTloT09RJElTLDU8USw1PFFPIyVQUSRJV08xRzNdT09RJElTLUU5ZC1FOWRPIyVnUSRJWk83KyZdTyFEWlEkSVdPJyNGbU8zVVEkSVdPNysmXU8zVVEkSVdPNysmYE8jKHVRJElbTyw1PFlPJ1JRJElXTyw1PFlPIylQUSRJV08xRzNiT09RJElTLUU5bC1FOWxPIylaUSRJV08xRzNiTzNVUSRJV083KyZiTy9nUSRJV083KyZiT09RJElWNysmZzcrJmdPIUVgUSUxYE83KyZpTyMpY1EkSVhPMUcwck9PUSRJVi1FOW0tRTltTzNVUSRJV083KyZjTzNVUSRJV083KyZjT09RJElWLDU8Wiw1PFpPIytVUSRJV08sNTxaT09RJElWNysmYzcrJmNPIythUSRJWk83KyZjTyMubFEkSVdPLDU8W08jLndRJElXTzFHM2NPT1EkSVMtRTluLUU5bk8jL1VRJElXTzFHM2NPIy9eUSRJV08nI0hfTyMvbFEkSVdPJyNIX08vfFEkSVdPJyNIX09PUSRJUycjSF8nI0hfTyMvd1EkSVdPJyNIXk9PUSRJUyw1O2UsNTtlTyMwUFEkSVdPLDU7ZU8vZ1EkSVdPJyNFe09PUSRJVjcrJmk3KyZpTzNVUSRJV083KyZpT09RJElWNysmbjcrJm5PT1EkSVMxRzJ0MUcydE9PUSRJUyw1O3MsNTtzTyMwVVEkSVdPMUcyc09PUSRJUy1FOVYtRTlWTyMwaVEkSVdPLDU7dE8jMHRRJElXTyw1O3RPIzFYUSRJV08xRzJ1T09RJElTLUU5Vy1FOVdPIzFpUSRJV08xRzJ1TyMxcVEkSVdPMUcydU8jMlJRJElXTzFHMnVPIzFpUSRJV08xRzJ1T09RJElTPDxIWDw8SFhPIzJeUSRJW08xRzFbT09RJElTPDxIaTw8SGlQIzJrUSRJV08nI0ZVTzZ8USRJV08xRzJtTyMyeFEkSVdPMUcybU8jMn1RJElXTzw8SGlPT1EkSVM8PEhqPDxIak8jM19RJElXTzcrKF1PT1EkSVM8PEhxPDxIcU8jM29RJElbTzFHMVpQIzRgUSRJV08nI0ZUTyM0bVEkSVdPNysoXk8jNH1RJElXTzcrKF5PIzVWUSRJV088PEh1TyM1W1EkSVdPNysoV09PUSRJUzw8SHc8PEh3TyM2UlEkSVdPLDU7ck8nUlEkSVdPLDU7ck9PUSRJUy1FOVUtRTlVT09RJElTPDxIdTw8SHVPT1EkSVMsNTt4LDU7eE8vZ1EkSVdPLDU7eE8jNldRJElXTzFHM1FPT1EkSVMtRTlbLUU5W08jNm5RJElXTzFHM1FPT09PJyNGXycjRl9PIzZ8TyFMUU8sNTpjT09PTyw1PWcsNT1nT09PTzcrJWc3KyVnTyM3WFEkSVdPMUcyVk8jN3JRJElXTzFHMlZQJ1JRJElXTycjRlZPL2dRJElXTzw8SWtPIzhUUSRJV08sNT1zTyM4ZlEkSVdPLDU9c08vfFEkSVdPLDU9c08jOHdRJElXTzw8SW1PT1EkSVM8PEltPDxJbU8vfFEkSVdPPDxJbVAvfFEkSVdPJyNGalAvZ1EkSVdPJyNGZk9PUSRJVi1FOWstRTlrTzNVUSRJV088PEl3T09RJElWLDU8WCw1PFhPM1VRJElXTyw1PFhPT1EkSVY8PEl3PDxJd09PUSRJVjw8SXo8PEl6TyM4fFEkSVtPMUcxdFAjOVdRJElXTycjRm5PIzlfUSRJV083Kyh8TyM5aVEkSVpPPDxJfE8zVVEkSVdPPDxJfE9PUSRJVjw8SlQ8PEpUTzNVUSRJV088PEpUT09RJElWJyNGbCcjRmxPIzx0USRJWk83KyZeT09RJElWPDxJfTw8SX1PIz5tUSRJWk88PEl9T09RJElWMUcxdTFHMXVPL3xRJElXTzFHMXVPM1VRJElXTzw8SX1PL3xRJElXTzFHMXZQL2dRJElXTycjRnBPI0F4USRJV083Kyh9TyNCVlEkSVdPNysofU9PUSRJUycjRXonI0V6Ty9nUSRJV08sNT15TyNCX1EkSVdPLDU9eU9PUSRJUyw1PXksNT15TyNCalEkSVdPLDU9eE8jQntRJElXTyw1PXhPT1EkSVMxRzFQMUcxUE9PUSRJUyw1O2csNTtnUCNDVFEkSVdPJyNGWE8jQ2VRJElXTzFHMWBPI0N4USRJV08xRzFgTyNEWVEkSVdPMUcxYFAjRGVRJElXTycjRllPI0RyUSRJV083KyhhTyNFU1EkSVdPNysoYU8jRVNRJElXTzcrKGFPI0VbUSRJV083KyhhTyNFbFEkSVdPNysoWE82fFEkSVdPNysoWE9PUSRJU0FOPlRBTj5UTyNGVlEkSVdPPDxLeE9PUSRJU0FOPmFBTj5hTy9nUSRJV08xRzFeTyNGZ1EkSVtPMUcxXlAjRnFRJElXTycjRldPT1EkSVMxRzFkMUcxZFAjR09RJElXTycjRl5PI0ddUSRJV083KyhsT09PTy1FOV0tRTldTyNHc1EkSVdPNysncU9PUSRJU0FOP1ZBTj9WTyNIXlEkSVdPLDU8VE8jSHJRJElXTzFHM19PT1EkSVMtRTlnLUU5Z08jSVRRJElXTzFHM19PT1EkSVNBTj9YQU4/WE8jSWZRJElXT0FOP1hPT1EkSVZBTj9jQU4/Y09PUSRJVjFHMXMxRzFzTzNVUSRJV09BTj9oTyNJa1EkSVpPQU4/aE9PUSRJVkFOP29BTj9vT09RJElWLUU5ai1FOWpPT1EkSVY8PEl4PDxJeE8zVVEkSVdPQU4/aU8zVVEkSVdPNysnYU9PUSRJVkFOP2lBTj9pT09RJElTNysnYjcrJ2JPI0x2USRJV088PExpT09RJElTMUczZTFHM2VPL2dRJElXTzFHM2VPT1EkSVMsNTxdLDU8XU8jTVRRJElXTzFHM2RPT1EkSVMtRTlvLUU5b08jTWZRJElXTzcrJnpPI012USRJV083KyZ6T09RJElTNysmejcrJnpPI05SUSRJV088PEt7TyNOY1EkSVdPPDxLe08jTmNRJElXTzw8S3tPI05rUSRJV08nI0dpT09RJElTPDxLczw8S3NPI051USRJV088PEtzT09RJElTNysmeDcrJnhPL3xRJElXTzFHMW9QL3xRJElXTycjRmlPJCBgUSRJV083Kyh5TyQgcVEkSVdPNysoeU9PUSRJU0cyNHNHMjRzT09RJElWRzI1U0cyNVNPM1VRJElXT0cyNVNPT1EkSVZHMjVURzI1VE9PUSRJVjw8Sns8PEp7T09RJElTNyspUDcrKVBQJCFTUSRJV08nI0ZxT09RJElTPDxKZjw8SmZPJCFiUSRJV088PEpmTyQhclEkSVdPQU5BZ08kI1NRJElXT0FOQWdPJCNbUSRJV08nI0dqT09RJElTJyNHaicjR2pPMGhRJElXTycjRGFPJCN1USRJV08sNT1UT09RJElTQU5BX0FOQV9PT1EkSVM3KydaNysnWk8kJF5RJElXTzw8TGVPT1EkSVZMRCpuTEQqbk9PUSRJU0FOQFFBTkBRTyQkb1EkSVdPRzI3Uk8kJVBRJElXTyw1OXtPT1EkSVMxRzJvMUcyb08jTmtRJElXTzFHL2dPT1EkSVM3KyVSNyslUk82fFEkSVdPJyNDek82fFEkSVdPLDU5X082fFEkSVdPLDU5X082fFEkSVdPLDU5X08kJVVRJElbTyw1PGtPNnxRJElXTzFHLnlPL2dRJElXTzFHL1VPL2dRJElXTzcrJG1QJCVpUSRJV08nI0ZkTydSUSRJV08nI0dQTyQldlEkSVdPLDU5X08kJXtRJElXTyw1OV9PJCZTUSRJV08sNTlqTyQmWFEkSVdPMUcvUk8waFEkSVdPJyNET082fFEkSVdPLDU5Z1wiLFxuICBzdGF0ZURhdGE6IFwiJCZvfk8kb09TJGxPUyRrT1NRT1N+T1BoT1RlT2RzT2ZYT2x0T3AhU09zdU98dk99IVBPIVIhVk8hUyFVTyFWWU8hWlpPIWZkTyFtZE8hbmRPIW9kTyF2eE8heHlPIXp6TyF8e08jT3xPI1N9TyNVIU9PI1ghUU8jWSFRTyNbIVJPI2MhVE8jZiFXTyNqIVhPI2whWU8jcSFaTyN0bE8kanFPJHpRTyR7UU8lUFJPJVFWTyVlW08lZl1PJWleTyVsX08lcmBPJXVhTyV3Yk9+T1QhYU9dIWFPXyFiT2YhaU8hViFrTyFkIWxPJHUhW08kdiFdTyR3IV5PJHghX08keSFfTyR6IWBPJHshYE8kfCFhTyR9IWFPJU8hYU9+T2glVFhpJVRYaiVUWGslVFhsJVRYbSVUWHAlVFh3JVRYeCVUWCFzJVRYI14lVFgkaiVUWCRtJVRYJVYlVFghTyVUWCFSJVRYIVMlVFglVyVUWCFXJVRYIVslVFh9JVRYI1YlVFhxJVRYIWolVFh+UCRfT2RzT2ZYTyFWWU8hWlpPIWZkTyFtZE8hbmRPIW9kTyR6UU8ke1FPJVBSTyVRVk8lZVtPJWZdTyVpXk8lbF9PJXJgTyV1YU8ld2JPfk93JVNYeCVTWCNeJVNYJGolU1gkbSVTWCVWJVNYfk9oIW9PaSFwT2ohbk9rIW5PbCFxT20hck9wIXNPIXMlU1h+UChgT1QheU9sLWZPcy10T3x2T35QJ1JPVCF8T2wtZk9zLXRPIVchfU9+UCdST1QjUU9fI1JPbC1mT3MtdE8hWyNTT35QJ1JPJWcjVk8laCNYT35PJWojWU8layNYT35PIVojW08lbSNdTyVxI19Pfk8hWiNbTyVzI2BPJXQjX09+TyFaI1tPJWgjX08ldiNiT35PIVojW08layNfTyV4I2RPfk9UJHRYXSR0WF8kdFhmJHRYaCR0WGkkdFhqJHRYayR0WGwkdFhtJHRYcCR0WHckdFghViR0WCFkJHRYJHUkdFgkdiR0WCR3JHRYJHgkdFgkeSR0WCR6JHRYJHskdFgkfCR0WCR9JHRYJU8kdFghTyR0WCFSJHRYIVMkdFh+TyVlW08lZl1PJWleTyVsX08lcmBPJXVhTyV3Yk94JHRYIXMkdFgjXiR0WCRqJHRYJG0kdFglViR0WCVXJHRYIVckdFghWyR0WH0kdFgjViR0WHEkdFghaiR0WH5QK3VPdyNpT3gkc1ghcyRzWCNeJHNYJGokc1gkbSRzWCVWJHNYfk9sLWZPcy10T35QJ1JPI14jbE8kaiNuTyRtI25Pfk8lUVZPfk8hUiNzTyNsIVlPI3EhWk8jdGxPfk9sdE9+UCdST1QjeE9fI3lPJVFWT3h0UH5PVCN9T2wtZk9zLXRPfSRPT35QJ1JPeCRRTyFzJFZPJVYkUk8jXiF0WCRqIXRYJG0hdFh+T1QjfU9sLWZPcy10TyNeIX1YJGohfVgkbSF9WH5QJ1JPbC1mT3MtdE8jXiNSWCRqI1JYJG0jUlh+UCdSTyFkJF1PIW0kXU8lUVZPfk9UJGdPflAnUk8hUyRpTyNqJGpPI2wka09+T3gkbE9+T1Qkek9fJHpPbC1mT3MtdE8hTyR8T35QJ1JPbC1mT3MtdE94JVBPflAnUk8lZCVST35PXyFiT2YhaU8hViFrTyFkIWxPVGBhXWBhaGBhaWBhamBha2BhbGBhbWBhcGBhd2BheGBhIXNgYSNeYGEkamBhJG1gYSR1YGEkdmBhJHdgYSR4YGEkeWBhJHpgYSR7YGEkfGBhJH1gYSVPYGElVmBhIU9gYSFSYGEhU2BhJVdgYSFXYGEhW2BhfWBhI1ZgYXFgYSFqYGF+T2slV09+T2wlV09+UCdST2wtZk9+UCdST2gtaE9pLWlPai1nT2stZ09sLXBPbS1xT3AtdU8hTyVTWCFSJVNYIVMlU1glVyVTWCFXJVNYIVslU1h9JVNYI1YlU1ghaiVTWH5QKGBPJVclWU93JVJYIU8lUlghUiVSWCFTJVJYIVclUlh4JVJYfk93JV1PIU8lW08hUiVhTyFTJWBPfk8hTyVbT35PdyVkTyFSJWFPIVMlYE8hVyVfWH5PIVclaE9+T3claU94JWtPIVIlYU8hUyVgTyFbJVlYfk8hWyVvT35PIVslcE9+TyVnI1ZPJWglck9+TyVqI1lPJWslck9+T1QldU9sLWZPcy10T3x2T35QJ1JPIVojW08lbSNdTyVxJXhPfk8hWiNbTyVzI2BPJXQleE9+TyFaI1tPJWgleE8ldiNiT35PIVojW08layV4TyV4I2RPfk9UIWxhXSFsYV8hbGFmIWxhaCFsYWkhbGFqIWxhayFsYWwhbGFtIWxhcCFsYXchbGF4IWxhIVYhbGEhZCFsYSFzIWxhI14hbGEkaiFsYSRtIWxhJHUhbGEkdiFsYSR3IWxhJHghbGEkeSFsYSR6IWxhJHshbGEkfCFsYSR9IWxhJU8hbGElViFsYSFPIWxhIVIhbGEhUyFsYSVXIWxhIVchbGEhWyFsYX0hbGEjViFsYXEhbGEhaiFsYX5QI3ZPdyV9T3gkc2EhcyRzYSNeJHNhJGokc2EkbSRzYSVWJHNhflAkX09UJlBPbHRPc3VPeCRzYSFzJHNhI14kc2EkaiRzYSRtJHNhJVYkc2F+UCdST3clfU94JHNhIXMkc2EjXiRzYSRqJHNhJG0kc2ElViRzYX5PUGhPVGVPbHRPc3VPfHZPfSFQTyF2eE8heHlPIXp6TyF8e08jT3xPI1N9TyNVIU9PI1ghUU8jWSFRTyNbIVJPI14kX1gkaiRfWCRtJF9YflAnUk8jXiNsTyRqJlVPJG0mVU9+TyFkJlZPZiV6WCRqJXpYI1YlelgjXiV6WCRtJXpYI1Ulelh+T2YhaU8kaiZYT35PaGNhaWNhamNha2NhbGNhbWNhcGNhd2NheGNhIXNjYSNeY2EkamNhJG1jYSVWY2EhT2NhIVJjYSFTY2ElV2NhIVdjYSFbY2F9Y2EjVmNhcWNhIWpjYX5QJF9PcG5hd25heG5hI15uYSRqbmEkbW5hJVZuYX5PaCFvT2khcE9qIW5PayFuT2whcU9tIXJPIXNuYX5QRFRPJVYmWk93JVVYeCVVWH5PJVFWT3clVVh4JVVYfk93Jl5PeHRYfk94JmBPfk93JWlPI14lWVgkaiVZWCRtJVlYIU8lWVh4JVlYIVslWVghaiVZWCVWJVlYfk9ULW9PbC1mT3MtdE98dk9+UCdSTyVWJFJPI15TYSRqU2EkbVNhfk8lViRST35PdyZpTyNeJVtYJGolW1gkbSVbWGslW1h+UCRfT3cmbE99JmtPI14jUmEkaiNSYSRtI1Jhfk8jViZtTyNeI1RhJGojVGEkbSNUYX5PIWQkXU8hbSRdTyNVJm9PJVFWT35PI1Umb09+T3cmcU8jXiV8WCRqJXxYJG0lfFh+T3cmc08jXiV5WCRqJXlYJG0leVh4JXlYfk93JndPayZPWH5QJF9PayZ6T35PUGhPVGVPbHRPc3VPfHZPfSFQTyF2eE8heHlPIXp6TyF8e08jT3xPI1N9TyNVIU9PI1ghUU8jWSFRTyNbIVJPJGonUE9+UCdST3EnVE8jZydSTyNoJ1NPUCNlYVQjZWFkI2VhZiNlYWwjZWFwI2VhcyNlYXwjZWF9I2VhIVIjZWEhUyNlYSFWI2VhIVojZWEhZiNlYSFtI2VhIW4jZWEhbyNlYSF2I2VhIXgjZWEheiNlYSF8I2VhI08jZWEjUyNlYSNVI2VhI1gjZWEjWSNlYSNbI2VhI2MjZWEjZiNlYSNqI2VhI2wjZWEjcSNlYSN0I2VhJGcjZWEkaiNlYSR6I2VhJHsjZWElUCNlYSVRI2VhJWUjZWElZiNlYSVpI2VhJWwjZWElciNlYSV1I2VhJXcjZWEkaSNlYSRtI2Vhfk93J1VPI1YnV094JlBYfk9mJ1lPfk9mIWlPeCRsT35PVCFhT10hYU9fIWJPZiFpTyFWIWtPIWQhbE8kdyFeTyR4IV9PJHkhX08keiFgTyR7IWBPJHwhYU8kfSFhTyVPIWFPaFVpaVVpalVpa1VpbFVpbVVpcFVpd1VpeFVpIXNVaSNeVWkkalVpJG1VaSR1VWklVlVpIU9VaSFSVWkhU1VpJVdVaSFXVWkhW1VpfVVpI1ZVaXFVaSFqVWl+TyR2IV1PflBOeU8kdlVpflBOeU9UIWFPXSFhT18hYk9mIWlPIVYha08hZCFsTyR6IWBPJHshYE8kfCFhTyR9IWFPJU8hYU9oVWlpVWlqVWlrVWlsVWltVWlwVWl3VWl4VWkhc1VpI15VaSRqVWkkbVVpJHVVaSR2VWkkd1VpJVZVaSFPVWkhUlVpIVNVaSVXVWkhV1VpIVtVaX1VaSNWVWlxVWkhalVpfk8keCFfTyR5IV9PflAhI3RPJHhVaSR5VWl+UCEjdE9fIWJPZiFpTyFWIWtPIWQhbE9oVWlpVWlqVWlrVWlsVWltVWlwVWl3VWl4VWkhc1VpI15VaSRqVWkkbVVpJHVVaSR2VWkkd1VpJHhVaSR5VWkkelVpJHtVaSVWVWkhT1VpIVJVaSFTVWklV1VpIVdVaSFbVWl9VWkjVlVpcVVpIWpVaX5PVCFhT10hYU8kfCFhTyR9IWFPJU8hYU9+UCEmck9UVWldVWkkfFVpJH1VaSVPVWl+UCEmck8hUiVhTyFTJWBPdyViWCFPJWJYfk8lVidfTyVXJ19PflArdU93J2FPIU8lYVh+TyFPJ2NPfk93J2RPeCdmTyFXJWNYfk9sLWZPcy10T3cnZE94J2dPIVclY1h+UCdSTyFXJ2lPfk9qIW5PayFuT2whcU9tIXJPaGdpcGdpd2dpeGdpIXNnaSNeZ2kkamdpJG1naSVWZ2l+T2khcE9+UCErZU9pZ2l+UCErZU9oLWhPaS1pT2otZ09rLWdPbC1wT20tcU9+T3Ena09+UCEsbk9UJ3BPbC1mT3MtdE8hTydxT35QJ1JPdydyTyFPJ3FPfk8hTyd0T35PIVMndk9+T3cnck8hTyd3TyFSJWFPIVMlYE9+UCRfT2gtaE9pLWlPai1nT2stZ09sLXBPbS1xTyFPbmEhUm5hIVNuYSVXbmEhV25hIVtuYX1uYSNWbmFxbmEham5hflBEVE9UJ3BPbC1mT3MtdE8hVyVfYX5QJ1JPdyd6TyFXJV9hfk8hVyd7T35Pdyd6TyFSJWFPIVMlYE8hVyVfYX5QJF9PVChQT2wtZk9zLXRPIVslWWEjXiVZYSRqJVlhJG0lWWEhTyVZYXglWWEhaiVZYSVWJVlhflAnUk93KFFPIVslWWEjXiVZYSRqJVlhJG0lWWEhTyVZYXglWWEhaiVZYSVWJVlhfk8hWyhUT35PdyhRTyFSJWFPIVMlYE8hWyVZYX5QJF9PdyhXTyFSJWFPIVMlYE8hWyVgYX5QJF9PdyhaT3glblghWyVuWCFqJW5Yfk94KF5PIVsoYE8haihhT35PVCZQT2x0T3N1T3gkc2khcyRzaSNeJHNpJGokc2kkbSRzaSVWJHNpflAnUk93KGJPeCRzaSFzJHNpI14kc2kkaiRzaSRtJHNpJVYkc2l+TyFkJlZPZiV6YSRqJXphI1YlemEjXiV6YSRtJXphI1UlemF+TyRqKGdPfk9UI3hPXyN5TyVRVk9+T3cmXk94dGF+T2x0T3N1T35QJ1JPdyhRTyNeJVlhJGolWWEkbSVZYSFPJVlheCVZYSFbJVlhIWolWWElViVZYX5QJF9PdyhsTyNeJHNYJGokc1gkbSRzWCVWJHNYfk8lViRSTyNeU2kkalNpJG1TaX5PI14lW2EkaiVbYSRtJVthayVbYX5QJ1JPdyhvTyNeJVthJGolW2EkbSVbYWslW2F+T1Qoc09mKHVPJVFWT35PI1Uodk9+TyVRVk8jXiV8YSRqJXxhJG0lfGF+T3coeE8jXiV8YSRqJXxhJG0lfGF+T2wtZk9zLXRPI14leWEkaiV5YSRtJXlheCV5YX5QJ1JPdyh7TyNeJXlhJGoleWEkbSV5YXgleWF+T3EpUE8jYSlPT1AjX2lUI19pZCNfaWYjX2lsI19pcCNfaXMjX2l8I19pfSNfaSFSI19pIVMjX2khViNfaSFaI19pIWYjX2khbSNfaSFuI19pIW8jX2khdiNfaSF4I19pIXojX2khfCNfaSNPI19pI1MjX2kjVSNfaSNYI19pI1kjX2kjWyNfaSNjI19pI2YjX2kjaiNfaSNsI19pI3EjX2kjdCNfaSRnI19pJGojX2kkeiNfaSR7I19pJVAjX2klUSNfaSVlI19pJWYjX2klaSNfaSVsI19pJXIjX2kldSNfaSV3I19pJGkjX2kkbSNfaX5PcSlRT1AjYmlUI2JpZCNiaWYjYmlsI2JpcCNiaXMjYml8I2JpfSNiaSFSI2JpIVMjYmkhViNiaSFaI2JpIWYjYmkhbSNiaSFuI2JpIW8jYmkhdiNiaSF4I2JpIXojYmkhfCNiaSNPI2JpI1MjYmkjVSNiaSNYI2JpI1kjYmkjWyNiaSNjI2JpI2YjYmkjaiNiaSNsI2JpI3EjYmkjdCNiaSRnI2JpJGojYmkkeiNiaSR7I2JpJVAjYmklUSNiaSVlI2JpJWYjYmklaSNiaSVsI2JpJXIjYmkldSNiaSV3I2JpJGkjYmkkbSNiaX5PVClTT2smT2F+UCdST3cpVE9rJk9hfk93KVRPayZPYX5QJF9PaylYT35PJGgpW09+T3EpX08jZydSTyNoKV5PUCNlaVQjZWlkI2VpZiNlaWwjZWlwI2VpcyNlaXwjZWl9I2VpIVIjZWkhUyNlaSFWI2VpIVojZWkhZiNlaSFtI2VpIW4jZWkhbyNlaSF2I2VpIXgjZWkheiNlaSF8I2VpI08jZWkjUyNlaSNVI2VpI1gjZWkjWSNlaSNbI2VpI2MjZWkjZiNlaSNqI2VpI2wjZWkjcSNlaSN0I2VpJGcjZWkkaiNlaSR6I2VpJHsjZWklUCNlaSVRI2VpJWUjZWklZiNlaSVpI2VpJWwjZWklciNlaSV1I2VpJXcjZWkkaSNlaSRtI2Vpfk9sLWZPcy10T3gkbE9+UCdST2wtZk9zLXRPeCZQYX5QJ1JPdyllT3gmUGF+T1QpaU9fKWpPIU8pbU8kfClrTyVRVk9+T3gkbE8mUylvT35PVCR6T18kek9sLWZPcy10TyFPJWFhflAnUk93KXVPIU8lYWF+T2wtZk9zLXRPeCl4TyFXJWNhflAnUk93KXlPIVclY2F+T2wtZk9zLXRPdyl5T3gpfE8hVyVjYX5QJ1JPbC1mT3MtdE93KXlPIVclY2F+UCdST3cpeU94KXxPIVclY2F+T2otZ09rLWdPbC1wT20tcU9oZ2lwZ2l3Z2khT2dpIVJnaSFTZ2klV2dpIVdnaXhnaSFbZ2kjXmdpJGpnaSRtZ2l9Z2kjVmdpcWdpIWpnaSVWZ2l+T2ktaU9+UCFHbU9pZ2l+UCFHbU9UJ3BPbC1mT3MtdE8hTypST35QJ1JPaypUT35PdypWTyFPKlJPfk8hTypXT35PVCdwT2wtZk9zLXRPIVclX2l+UCdST3cqWE8hVyVfaX5PIVcqWU9+T1QoUE9sLWZPcy10TyFbJVlpI14lWWkkaiVZaSRtJVlpIU8lWWl4JVlpIWolWWklViVZaX5QJ1JPdypdTyFSJWFPIVMlYE8hWyVgaX5PdypgTyFbJVlpI14lWWkkaiVZaSRtJVlpIU8lWWl4JVlpIWolWWklViVZaX5PIVsqYU9+T18qY09sLWZPcy10TyFbJWBpflAnUk93Kl1PIVslYGl+TyFbKmVPfk9UKmdPbC1mT3MtdE94JW5hIVslbmEhaiVuYX5QJ1JPdypoT3glbmEhWyVuYSFqJW5hfk8hWiNbTyVwKmtPIVsha1h+TyFbKm1Pfk94KF5PIVsqbk9+T1QmUE9sdE9zdU94JHNxIXMkc3EjXiRzcSRqJHNxJG0kc3ElViRzcX5QJ1JPdyRXaXgkV2khcyRXaSNeJFdpJGokV2kkbSRXaSVWJFdpflAkX09UJlBPbHRPc3VPflAnUk9UJlBPbC1mT3MtdE8jXiRzYSRqJHNhJG0kc2ElViRzYX5QJ1JPdypvTyNeJHNhJGokc2EkbSRzYSVWJHNhfk93I3lhI14jeWEkaiN5YSRtI3lhayN5YX5QJF9PI14lW2kkaiVbaSRtJVtpayVbaX5QJ1JPdypyTyNeI1JxJGojUnEkbSNScX5PdypzTyNWKnVPI14le1gkaiV7WCRtJXtYIU8le1h+T1Qqd09mKnhPJVFWT35PJVFWTyNeJXxpJGolfGkkbSV8aX5PbC1mT3MtdE8jXiV5aSRqJXlpJG0leWl4JXlpflAnUk9xKnxPI2EpT09QI19xVCNfcWQjX3FmI19xbCNfcXAjX3FzI19xfCNfcX0jX3EhUiNfcSFTI19xIVYjX3EhWiNfcSFmI19xIW0jX3EhbiNfcSFvI19xIXYjX3EheCNfcSF6I19xIXwjX3EjTyNfcSNTI19xI1UjX3EjWCNfcSNZI19xI1sjX3EjYyNfcSNmI19xI2ojX3EjbCNfcSNxI19xI3QjX3EkZyNfcSRqI19xJHojX3EkeyNfcSVQI19xJVEjX3ElZSNfcSVmI19xJWkjX3ElbCNfcSVyI19xJXUjX3EldyNfcSRpI19xJG0jX3F+T2skYmF3JGJhflAkX09UKVNPayZPaX5QJ1JPdytUT2smT2l+T1BoT1RlT2x0T3AhU09zdU98dk99IVBPIVIhVk8hUyFVTyF2eE8heHlPIXp6TyF8e08jT3xPI1N9TyNVIU9PI1ghUU8jWSFRTyNbIVJPI2MhVE8jZiFXTyNqIVhPI2whWU8jcSFaTyN0bE9+UCdST3crX094JGxPI1YrX09+TyNoK2BPUCNlcVQjZXFkI2VxZiNlcWwjZXFwI2VxcyNlcXwjZXF9I2VxIVIjZXEhUyNlcSFWI2VxIVojZXEhZiNlcSFtI2VxIW4jZXEhbyNlcSF2I2VxIXgjZXEheiNlcSF8I2VxI08jZXEjUyNlcSNVI2VxI1gjZXEjWSNlcSNbI2VxI2MjZXEjZiNlcSNqI2VxI2wjZXEjcSNlcSN0I2VxJGcjZXEkaiNlcSR6I2VxJHsjZXElUCNlcSVRI2VxJWUjZXElZiNlcSVpI2VxJWwjZXElciNlcSV1I2VxJXcjZXEkaSNlcSRtI2Vxfk8jVithT3ckZGF4JGRhfk9sLWZPcy10T3gmUGl+UCdST3crY094JlBpfk94JFFPJVYrZU93JlJYIU8mUlh+TyVRVk93JlJYIU8mUlh+T3craU8hTyZRWH5PIU8ra09+T1Qkek9fJHpPbC1mT3MtdE8hTyVhaX5QJ1JPeCtuT3cjfGEhVyN8YX5PbC1mT3MtdE94K29PdyN8YSFXI3xhflAnUk9sLWZPcy10T3gpeE8hVyVjaX5QJ1JPdytyTyFXJWNpfk9sLWZPcy10T3crck8hVyVjaX5QJ1JPdytyT3grdU8hVyVjaX5PdyN4aSFPI3hpIVcjeGl+UCRfT1QncE9sLWZPcy10T35QJ1JPayt3T35PVCdwT2wtZk9zLXRPIU8reE9+UCdST1QncE9sLWZPcy10TyFXJV9xflAnUk93I3dpIVsjd2kjXiN3aSRqI3dpJG0jd2khTyN3aXgjd2khaiN3aSVWI3dpflAkX09UKFBPbC1mT3MtdE9+UCdST18qY09sLWZPcy10TyFbJWBxflAnUk93K3lPIVslYHF+TyFbK3pPfk9UKFBPbC1mT3MtdE8hWyVZcSNeJVlxJGolWXEkbSVZcSFPJVlxeCVZcSFqJVlxJVYlWXF+UCdST3gre09+T1QqZ09sLWZPcy10T3glbmkhWyVuaSFqJW5pflAnUk93LFFPeCVuaSFbJW5pIWolbml+TyFaI1tPJXAqa08hWyFrYX5PVCZQT2wtZk9zLXRPI14kc2kkaiRzaSRtJHNpJVYkc2l+UCdST3csU08jXiRzaSRqJHNpJG0kc2klViRzaX5PJVFWTyNeJXthJGole2EkbSV7YSFPJXthfk93LFZPI14le2EkaiV7YSRtJXthIU8le2F+TyFPLFlPfk9rJGJpdyRiaX5QJF9PVClTT35QJ1JPVClTT2smT3F+UCdST3EsXk9QI2R5VCNkeWQjZHlmI2R5bCNkeXAjZHlzI2R5fCNkeX0jZHkhUiNkeSFTI2R5IVYjZHkhWiNkeSFmI2R5IW0jZHkhbiNkeSFvI2R5IXYjZHkheCNkeSF6I2R5IXwjZHkjTyNkeSNTI2R5I1UjZHkjWCNkeSNZI2R5I1sjZHkjYyNkeSNmI2R5I2ojZHkjbCNkeSNxI2R5I3QjZHkkZyNkeSRqI2R5JHojZHkkeyNkeSVQI2R5JVEjZHklZSNkeSVmI2R5JWkjZHklbCNkeSVyI2R5JXUjZHkldyNkeSRpI2R5JG0jZHl+T1BoT1RlT2x0T3AhU09zdU98dk99IVBPIVIhVk8hUyFVTyF2eE8heHlPIXp6TyF8e08jT3xPI1N9TyNVIU9PI1ghUU8jWSFRTyNbIVJPI2MhVE8jZiFXTyNqIVhPI2whWU8jcSFaTyN0bE8kaSxiTyRtLGJPflAnUk8jaCxjT1AjZXlUI2V5ZCNleWYjZXlsI2V5cCNleXMjZXl8I2V5fSNleSFSI2V5IVMjZXkhViNleSFaI2V5IWYjZXkhbSNleSFuI2V5IW8jZXkhdiNleSF4I2V5IXojZXkhfCNleSNPI2V5I1MjZXkjVSNleSNYI2V5I1kjZXkjWyNleSNjI2V5I2YjZXkjaiNleSNsI2V5I3EjZXkjdCNleSRnI2V5JGojZXkkeiNleSR7I2V5JVAjZXklUSNleSVlI2V5JWYjZXklaSNleSVsI2V5JXIjZXkldSNleSV3I2V5JGkjZXkkbSNleX5PbC1mT3MtdE94JlBxflAnUk93LGdPeCZQcX5PJVYrZU93JlJhIU8mUmF+T1QpaU9fKWpPJHwpa08lUVZPIU8mUWF+T3csa08hTyZRYX5PVCR6T18kek9sLWZPcy10T35QJ1JPbC1mT3MtdE94LG1PdyN8aSFXI3xpflAnUk9sLWZPcy10T3cjfGkhVyN8aX5QJ1JPeCxtT3cjfGkhVyN8aX5PbC1mT3MtdE94KXhPflAnUk9sLWZPcy10T3gpeE8hVyVjcX5QJ1JPdyxwTyFXJWNxfk9sLWZPcy10T3cscE8hVyVjcX5QJ1JPcCxzTyFSJWFPIVMlYE8hTyVacSFXJVpxIVslWnF3JVpxflAhLG5PXypjT2wtZk9zLXRPIVslYHl+UCdST3cjemkhWyN6aX5QJF9PXypjT2wtZk9zLXRPflAnUk9UKmdPbC1mT3MtdE9+UCdST1QqZ09sLWZPcy10T3glbnEhWyVucSFqJW5xflAnUk9UJlBPbC1mT3MtdE8jXiRzcSRqJHNxJG0kc3ElViRzcX5QJ1JPI1Ysd093JF1hI14kXWEkaiRdYSRtJF1hIU8kXWF+TyVRVk8jXiV7aSRqJXtpJG0le2khTyV7aX5Pdyx5TyNeJXtpJGole2kkbSV7aSFPJXtpfk8hTyx7T35PcSx9T1AjZCFSVCNkIVJkI2QhUmYjZCFSbCNkIVJwI2QhUnMjZCFSfCNkIVJ9I2QhUiFSI2QhUiFTI2QhUiFWI2QhUiFaI2QhUiFmI2QhUiFtI2QhUiFuI2QhUiFvI2QhUiF2I2QhUiF4I2QhUiF6I2QhUiF8I2QhUiNPI2QhUiNTI2QhUiNVI2QhUiNYI2QhUiNZI2QhUiNbI2QhUiNjI2QhUiNmI2QhUiNqI2QhUiNsI2QhUiNxI2QhUiN0I2QhUiRnI2QhUiRqI2QhUiR6I2QhUiR7I2QhUiVQI2QhUiVRI2QhUiVlI2QhUiVmI2QhUiVpI2QhUiVsI2QhUiVyI2QhUiV1I2QhUiV3I2QhUiRpI2QhUiRtI2QhUn5PbC1mT3MtdE94JlB5flAnUk9UKWlPXylqTyR8KWtPJVFWTyFPJlFpfk9sLWZPcy10T3cjfHEhVyN8cX5QJ1JPeC1UT3cjfHEhVyN8cX5PbC1mT3MtdE94KXhPIVclY3l+UCdST3ctVU8hVyVjeX5PbC1mT3MtWU9+UCdST3Asc08hUiVhTyFTJWBPIU8lWnkhVyVaeSFbJVp5dyVaeX5QISxuTyVRVk8jXiV7cSRqJXtxJG0le3EhTyV7cX5Pdy1eTyNeJXtxJGole3EkbSV7cSFPJXtxfk9UKWlPXylqTyR8KWtPJVFWT35PbC1mT3MtdE93I3x5IVcjfHl+UCdST2wtZk9zLXRPeCl4TyFXJWMhUn5QJ1JPdy1hTyFXJWMhUn5PcCVeWCFPJV5YIVIlXlghUyVeWCFXJV5YIVslXlh3JV5YflAhLG5PcCxzTyFSJWFPIVMlYE8hTyVdYSFXJV1hIVslXWF3JV1hfk8lUVZPI14le3kkaiV7eSRtJXt5IU8le3l+T2wtZk9zLXRPeCl4TyFXJWMhWn5QJ1JPeC1kT35PdypvTyNeJHNhJGokc2EkbSRzYSVWJHNhflAkX09UJlBPbC1mT3MtdE9+UCdST2sta09+T2wta09+UCdST3gtbE9+T3EtbU9+UCEsbk8lZiVpJXUldyVlIVolbSVzJXYleCVsJXIlbCVRflwiLFxuICBnb3RvOiBcIiEsdSZTUFBQUCZUUCZdKW4qVCprK1MrbCxWUCxxUCZdLV8tXyZdUCZdUDBwUFBQUFBQMHAzYFBQM2BQNWw1dTp5UFA6fDtbO19QUFAmXSZdUFA7ayZdUFAmXSZdUFAmXSZdJl0mXTtvPGMmXVA8ZlA8aTxpQE9QQGQmXVBQUEBoQG4mVFAmVCZUUCZUUCZUUCZUUCZUUCZUJlQmVFAmVFBQJlRQUCZUUEB0UEB7QVJQQHtQQHtAe1BQUEB7UEJ6UENUQ1pDYUJ6UEB7Q2dQQ25DdEN6RFdEakRwRHpFUUVuRXRFekZRRltGYkZoRm5GdEZ6R15HaEduR3RHekhVSFtIYkhoSG5IeElPSVlJYFBQUFBQUFBQUElpSXFJekpVSmFQUFBQUFBQUFBQUFBOdiEgYCElbiEoelBQISlTISliISlrISphISpXISpqISpwISpzISp2ISp5IStSUFBQUFBQUFBQUCErVSErWFBQUFBQUFBQUCErXyErayErdyEsVCEsVyEsXiEsZCEsaiEsbV1pT3IjbCRsKVsrWidvZE9TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFpIWshbiFvIXAhciFzIXkhfCNRI1IjWyNpI2wjfSRPJFEkUyRWJGckaSRqJGwkeiVQJVclWiVdJWAlZCVpJWsldSV9JlAmWyZgJmkmayZsJnMmdyZ6J1InVSdgJ2EnZCdmJ2cnaydwJ3Indid6KFAoUShXKFooYihkKGwobyh7KU8pUylUKVgpWyllKW8pdSl4KXkpfCpTKlQqVipYKlsqXSpgKmMqZypoKm8qcSpyKnorUytUK1orYitjK2YrbStuK28rcStyK3Urdyt5K3srfSxQLFEsUyxnLGksbSxwLHMtVC1VLWEtZC1mLWctaC1pLWstbC1tLW4tby1xLXV3IWNQI2gjdSRXJGYlYiVnJW0lbiZhJnkoYyhuKVIqUSpaK1IrfC1qeSFkUCNoI3UkVyRmJHIlYiVnJW0lbiZhJnkoYyhuKVIqUSpaK1IrfC1qeyFlUCNoI3UkVyRmJHIkcyViJWclbSVuJmEmeShjKG4pUipRKlorUit8LWp9IWZQI2gjdSRXJGYkciRzJHQlYiVnJW0lbiZhJnkoYyhuKVIqUSpaK1IrfC1qIVAhZ1AjaCN1JFckZiRyJHMkdCR1JWIlZyVtJW4mYSZ5KGMobilSKlEqWitSK3wtaiFSIWhQI2gjdSRXJGYkciRzJHQkdSR2JWIlZyVtJW4mYSZ5KGMobilSKlEqWitSK3wtaiFWIWhQIW0jaCN1JFckZiRyJHMkdCR1JHYkdyViJWclbSVuJmEmeShjKG4pUipRKlorUit8LWonb1NPU1hZWmVocnN0dnh8fSFSIVMhVCFVIVghYyFkIWUhZiFnIWghaSFrIW4hbyFwIXIhcyF5IXwjUSNSI1sjaSNsI30kTyRRJFMkViRnJGkkaiRsJHolUCVXJVolXSVgJWQlaSVrJXUlfSZQJlsmYCZpJmsmbCZzJncmeidSJ1UnYCdhJ2QnZidnJ2sncCdyJ3YneihQKFEoVyhaKGIoZChsKG8oeylPKVMpVClYKVspZSlvKXUpeCl5KXwqUypUKlYqWCpbKl0qYCpjKmcqaCpvKnEqcip6K1MrVCtaK2IrYytmK20rbitvK3Ercit1K3creSt7K30sUCxRLFMsZyxpLG0scCxzLVQtVS1hLWQtZi1nLWgtaS1rLWwtbS1uLW8tcS11JlpVT1hZWmhydHZ8fSFSIVMhVCFYIWkhayFuIW8hcCFyIXMjWyNpI2wkTyRRJFMkViRqJGwkeiVQJVclWiVdJWQlaSVrJXUlfSZbJmAmayZsJnMmeidSJ1UnYCdhJ2QnZidnJ2sncid6KFEoVyhaKGIoZChsKHspTylYKVspZSlvKXUpeCl5KXwqUypUKlYqWCpbKl0qYCpnKmgqbypyKnorWitiK2MrZittK24rbytxK3IrdSt3K3kreyt9LFAsUSxTLGcsaSxtLHAscy1ULVUtYS1kLWYtZy1oLWktay1sLW0tbi1xLXUlZVdPWFlaaHJ2fH0hUiFTIVQhWCFpIWsjWyNpI2wkTyRRJFMkViRqJGwkeiVQJVolXSVkJWklayV1JX0mWyZgJmsmbCZzJnonUidVJ2AnYSdkJ2YnZydrJ3IneihRKFcoWihiKGQobCh7KU8pWClbKWUpbyl1KXgpeSl8KlMqVipYKlsqXSpgKmcqaCpvKnIqeitaK2IrYytmK20rbitvK3Ercit1K3kreyt9LFAsUSxTLGcsaSxtLHAtVC1VLWEtbC1tLW5RI3t1US1iLVlSLXItdCdmZE9TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFrIW4hbyFwIXIhcyF5IXwjUSNSI1sjaSNsI30kTyRRJFMkViRnJGkkaiRsJHolUCVXJVolXSVgJWQlaSVrJXUlfSZQJlsmYCZpJmsmbCZzJncmeidSJ1UnYCdkJ2YnZydrJ3Ancid2J3ooUChRKFcoWihiKGQobChvKHspTylTKVQpWClbKWUpbyl4KXkpfCpTKlQqVipYKlsqXSpgKmMqZypoKm8qcSpyKnorUytUK1orYitjK2YrbitvK3Ercit1K3creSt7K30sUCxRLFMsZyxpLG0scCxzLVQtVS1hLWQtZi1nLWgtaS1rLWwtbS1uLW8tcS11VyNvbCFPIVAkXlcjd3UmXi1ZLXRRJGAhUVEkcCFZUSRxIVpXJHkhaSdhKXUrbVMmXSN4I3lRJn0ka1EoZSZWUShzJm1XKHQmbyh1KHYqeFUodyZxKHgqeVEpZydXVyloJ1kraSxrLVJTK2gpaSlqWSxVKnMsVix4LHktXlEsWCp1USxkK19RLGYrYVItXSx3UiZbI3dpIXZYWSFTIVQlXSVkJ3IneilPKlMqVipYUiVaIXVRIXpYUSV2I1tRJmUkU1ImaCRWVC1YLHMtZCFVIWpQIW0jaCN1JFckZiRyJHMkdCR1JHYkdyViJWclbSVuJmEmeShjKG4pUipRKlorUit8LWpRJlkjcFInXSRxUidgJHlSJVMhbCduY09TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFpIWshbiFvIXAhciFzIXkhfCNRI1IjWyNpI2wjfSRPJFEkUyRWJGckaSRqJGwkeiVQJVclWiVdJWAlZCVpJWsldSV9JlAmWyZgJmkmayZsJnMmdyZ6J1InVSdgJ2EnZCdmJ2cnaydwJ3Indid6KFAoUShXKFooYihkKGwobyh7KU8pUylUKVgpWyllKW8pdSl4KXkpfCpTKlQqVipYKlsqXSpgKmMqZypoKm8qcSpyKnorUytUK1orYitjK2YrbStuK28rcStyK3Urdyt5K3srfSxQLFEsUyxnLGksbSxwLHMtVC1VLWEtZC1mLWctaC1pLWstbC1tLW4tby1xLXVUI2ZjI2dTI11fI15TI2BgI2FTI2JhI2NTI2RiI2VUKmsoXipsVChfJXYoYVEkVXdSK2cpaFgkU3ckVCRVJmdaa09yJGwpWytaWG9PcilbK1pRJG0hV1EmdSRkUSZ2JGVRJ1gkb1EnWyRxUSlZJnxRKWAnUlEpYidTUSljJ1RRKXAnWlEpciddUSp9KU9RK1ApUFErUSlRUStVKVdTK1cpWilxUStbKV5RK10pX1ErXilhUSxbKnxRLF0rT1EsXytWUSxgK1hRLGUrYFEsfCxeUS1PLGNRLVAsZFItXyx9V29PcilbK1pSI3JuUSdaJHBSKVomfVErZiloUixpK2dRKXEnWlIrWClaWm1PbnIpWytaUXJPUiN0clEmXyN6UihqJl9TJWojUCN8UyhSJWooVVQoVSVtJmFRJV4heFElZSF7VydzJV4lZSd4J3xRJ3glYlInfCVnUSZqJFdSKHAmalEoWCVuUSpeKFNUKmQoWCpeUSdiJHtSKXYnYlMnZSVPJVBZKXonZSl7K3MscS1WVSl7J2YnZydoVStzKXwpfSpPUyxxK3QrdVItVixyUSNXXVIlcSNXUSNaXlIlcyNaUSNeX1IldyNeUShbJXRTKmkoWypqUipqKF1RKmwoXlIsUipsUSNhYFIleSNhUSNjYVIleiNjUSNlYlIleyNlUSNnY1IlfCNnUSNqZlEmTyNoVyZSI2omTyhtKnBRKG0mZFIqcC1qUSRUd1MmZiRUJmdSJmckVVEmdCRiUih8JnRRJlcjb1IoZiZXUSReIVBSJm4kXlEqdCh0UyxXKnQselIseixYUSZyJGBSKHkmclEjbWpSJlQjbVErWilbUixhK1pRKH0mdVIqeyh9USZ4JGZTKVUmeClWUilWJnlRJ1EkbVIpXSdRUSdWJG5TKWYnVitkUitkKWdRK2opbFIsbCtqV25PcilbK1pSI3FuU3FPclQrWSlbK1pXcE9yKVsrWlInTyRsWWpPciRsKVsrWlImUyNsW3dPciNsJGwpWytaUiZlJFMmWVBPWFlaaHJ0dnx9IVIhUyFUIVghaSFrIW4hbyFwIXIhcyNbI2kjbCRPJFEkUyRWJGokbCR6JVAlVyVaJV0lZCVpJWsldSV9JlsmYCZrJmwmcyZ6J1InVSdgJ2EnZCdmJ2cnaydyJ3ooUShXKFooYihkKGwoeylPKVgpWyllKW8pdSl4KXkpfCpTKlQqVipYKlsqXSpgKmcqaCpvKnIqeitaK2IrYytmK20rbitvK3Ercit1K3creSt7K30sUCxRLFMsZyxpLG0scCxzLVQtVS1hLWQtZi1nLWgtaS1rLWwtbS1uLXEtdVEhbVNRI2hlUSN1c1UkV3glYCd2UyRmIVUkaVEkciFjUSRzIWRRJHQhZVEkdSFmUSR2IWdRJHchaFElYiF5USVnIXxRJW0jUVElbiNSUSZhI31RJnkkZ1EoYyZQVShuJmkobypxVylSJncpVCtTK1RRKlEncFEqWihQUStSKVNRK3wqY1Itai1vUSF4WFEhe1lRJGQhU1EkZSFUXidvJV0lZCdyJ3oqUypWKlhSK08pT1tmT3IjbCRsKVsrWmghdVhZIVMhVCVdJWQncid6KU8qUypWKlhRI1BaUSNraFMjfHZ8USRafVckYiFSJFYmeilYUyRuIVgkalckeCFpJ2EpdSttUSVPIWtRJXQjW2AmUSNpJX0oYihkKGwqbyxTLW5RJmIkT1EmYyRRUSZkJFNRJ14kelEnaCVQUSduJVpXKE8laShRKlsqYFEoUyVrUShdJXVRKGgmW1MoayZgLWxRKHEma1EociZsVSh6JnMoeyp6USlhJ1JZKWQnVSllK2IrYyxnUSlzJ2BeKXcnZCl5K3ErcixwLVUtYVEpfSdmUSpPJ2dTKlAnay1tVypiKFcqXSt5K31XKmYoWipoLFAsUVErbClvUStwKXhRK3QpfFEsTypnUSxUKnJRLGgrZlEsbituUSxvK29RLHIrdVEsdit7US1RLGlRLVMsbVItYC1UaFRPciNpI2wkbCV9JmAnayhiKGQpWytaJHohdFhZWmh2fH0hUiFTIVQhWCFpIWsjWyRPJFEkUyRWJGokeiVQJVolXSVkJWklayV1JlsmayZsJnMmeidSJ1UnYCdhJ2QnZidnJ3IneihRKFcoWihsKHspTylYKWUpbyl1KXgpeSl8KlMqVipYKlsqXSpgKmcqaCpvKnIqeitiK2MrZittK24rbytxK3IrdSt5K3srfSxQLFEsUyxnLGksbSxwLVQtVS1hLWwtbS1uUSN2dFclVCFuIXItZy1xUSVVIW9RJVYhcFElWCFzUSVjLWZTJ2olVy1rUSdsLWhRJ20taVErdipUUSx1K3dTLVcscy1kUi1zLXVVI3p1LVktdFIoaSZeW2dPciNsJGwpWytaWCF3WCNbJFMkVlEjVVpRJFB2UiRZfFElXyF4USVmIXtRJWwjUFEnXiR4USd5JWJRJ30lZ1EoViVtUShZJW5RKl8oU1EsdCt2US1bLHVSLWMtWlEkWHhRJ3UlYFIqVSd2US1aLHNSLWUtZFIjT1lSI1RaUiR9IWlRJHshaVYpdCdhKXUrbVIlUSFrUiV2I1tRKGAldlIqbihhUSRjIVJRJmgkVlEpVyZ6UitWKVhRI3BsUSRbIU9RJF8hUFImcCReUShzJm9RKnYodVEqdyh2UixaKnhSJGEhUVhwT3IpWytaUSRoIVVSJnskaVEkbyFYUiZ8JGpSKW4nWVEpbCdZVixqK2ksay1SXCIsXG4gIG5vZGVOYW1lczogXCLimqAgcHJpbnQgQ29tbWVudCBTY3JpcHQgQXNzaWduU3RhdGVtZW50ICogQmluYXJ5RXhwcmVzc2lvbiBCaXRPcCBCaXRPcCBCaXRPcCBCaXRPcCBBcml0aE9wIEFyaXRoT3AgQCBBcml0aE9wICoqIFVuYXJ5RXhwcmVzc2lvbiBBcml0aE9wIEJpdE9wIEF3YWl0RXhwcmVzc2lvbiBhd2FpdCBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiAoIEJpbmFyeUV4cHJlc3Npb24gb3IgYW5kIENvbXBhcmVPcCBpbiBub3QgaXMgVW5hcnlFeHByZXNzaW9uIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBpZiBlbHNlIExhbWJkYUV4cHJlc3Npb24gbGFtYmRhIFBhcmFtTGlzdCBWYXJpYWJsZU5hbWUgQXNzaWduT3AgLCA6IE5hbWVkRXhwcmVzc2lvbiBBc3NpZ25PcCBZaWVsZEV4cHJlc3Npb24geWllbGQgZnJvbSApIFR1cGxlRXhwcmVzc2lvbiBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBhc3luYyBmb3IgTGFtYmRhRXhwcmVzc2lvbiBBcnJheUV4cHJlc3Npb24gWyBdIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gRGljdGlvbmFyeUV4cHJlc3Npb24geyB9IERpY3Rpb25hcnlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBTZXRFeHByZXNzaW9uIFNldENvbXByZWhlbnNpb25FeHByZXNzaW9uIENhbGxFeHByZXNzaW9uIEFyZ0xpc3QgQXNzaWduT3AgTWVtYmVyRXhwcmVzc2lvbiAuIFByb3BlcnR5TmFtZSBOdW1iZXIgU3RyaW5nIEZvcm1hdFN0cmluZyBGb3JtYXRSZXBsYWNlbWVudCBGb3JtYXRDb252ZXJzaW9uIEZvcm1hdFNwZWMgQ29udGludWVkU3RyaW5nIEVsbGlwc2lzIE5vbmUgQm9vbGVhbiBUeXBlRGVmIEFzc2lnbk9wIFVwZGF0ZVN0YXRlbWVudCBVcGRhdGVPcCBFeHByZXNzaW9uU3RhdGVtZW50IERlbGV0ZVN0YXRlbWVudCBkZWwgUGFzc1N0YXRlbWVudCBwYXNzIEJyZWFrU3RhdGVtZW50IGJyZWFrIENvbnRpbnVlU3RhdGVtZW50IGNvbnRpbnVlIFJldHVyblN0YXRlbWVudCByZXR1cm4gWWllbGRTdGF0ZW1lbnQgUHJpbnRTdGF0ZW1lbnQgUmFpc2VTdGF0ZW1lbnQgcmFpc2UgSW1wb3J0U3RhdGVtZW50IGltcG9ydCBhcyBTY29wZVN0YXRlbWVudCBnbG9iYWwgbm9ubG9jYWwgQXNzZXJ0U3RhdGVtZW50IGFzc2VydCBTdGF0ZW1lbnRHcm91cCA7IElmU3RhdGVtZW50IEJvZHkgZWxpZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBGb3JTdGF0ZW1lbnQgVHJ5U3RhdGVtZW50IHRyeSBleGNlcHQgZmluYWxseSBXaXRoU3RhdGVtZW50IHdpdGggRnVuY3Rpb25EZWZpbml0aW9uIGRlZiBQYXJhbUxpc3QgQXNzaWduT3AgVHlwZURlZiBDbGFzc0RlZmluaXRpb24gY2xhc3MgRGVjb3JhdGVkU3RhdGVtZW50IERlY29yYXRvciBBdFwiLFxuICBtYXhUZXJtOiAyMzQsXG4gIGNvbnRleHQ6IHRyYWNrSW5kZW50LFxuICBub2RlUHJvcHM6IFtcbiAgICBbbGV6ZXIuTm9kZVByb3AuZ3JvdXAsIC0xNCw0LDgwLDgyLDgzLDg1LDg3LDg5LDkxLDkzLDk0LDk1LDk3LDEwMCwxMDMsXCJTdGF0ZW1lbnQgU3RhdGVtZW50XCIsLTIyLDYsMTYsMTksMjEsMzcsNDcsNDgsNTIsNTUsNTYsNTksNjAsNjEsNjIsNjUsNjgsNjksNzAsNzQsNzUsNzYsNzcsXCJFeHByZXNzaW9uXCIsLTksMTA1LDEwNywxMTAsMTEyLDExMywxMTcsMTE5LDEyNCwxMjYsXCJTdGF0ZW1lbnRcIl1cbiAgXSxcbiAgc2tpcHBlZE5vZGVzOiBbMCwyXSxcbiAgcmVwZWF0Tm9kZUNvdW50OiAzMixcbiAgdG9rZW5EYXRhOiBcIiZBYU1nUiFeT1gkfVhZISN4WVskfVtdISN4XXAkfXBxISN4cXIhJlNycyEpeXN0IUN7dHUkfXV2JCt9dnckLmF3eCQvbXh5JExneXokTW16eyROc3t8JSNjfH0lJG99IU8lJXUhTyFQJShbIVAhUSUzYiFRIVIlNlEhUiFbJTpTIVshXSVFTyFdIV4lR2IhXiFfJUhoIV8hYCVLVyFgIWElTGQhYSFiJH0hYiFjJiBQIWMhZCYhXyFkIWUmJFAhZSFoJiFfIWghaSYuUiFpIXQmIV8hdCF1JjdnIXUhdyYhXyF3IXgmLGEheCF9JiFfIX0jTyY5cSNPI1AhJWIjUCNRJjp3I1EjUiY7fSNSI1MmIV8jUyNUJH0jVCNVJiFfI1UjViYkUCNWI1kmIV8jWSNaJi5SI1ojZiYhXyNmI2cmN2cjZyNpJiFfI2kjaiYsYSNqI28mIV8jbyNwJj1aI3AjcSY+UCNxI3ImP10jciNzJkBaI3MkZyR9JGd+JiFfPHIlYFolcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfTlbJl5aJXA3WyVnUyVtYCV2IWJPcidQcnNDeHN3J1B3eChQeCNPJ1AjTyNQPnYjUCNvJ1AjbyNwQ1UjcCNxJ1AjcSNyP1sjcn4nUDlbJ15aJXA3WyVnUyVqVyVtYCV2IWJPcidQcnMmUnN3J1B3eChQeCNPJ1AjTyNQPnYjUCNvJ1AjbyNwQ1UjcCNxJ1AjcSNyP1sjcn4nUDh6KFdaJXA3WyVqV09yKHlycyl3c3coeXd4O2J4I08oeSNPI1AyViNQI28oeSNvI3A3biNwI3EoeSNxI3IyayNyfih5OHopVVolcDdbJWdTJWpXJXYhYk9yKHlycyl3c3coeXd4KFB4I08oeSNPI1AyViNQI28oeSNvI3A3biNwI3EoeSNxI3IyayNyfih5OHoqUVolcDdbJWdTJXYhYk9yKHlycypzc3coeXd4KFB4I08oeSNPI1AyViNQI28oeSNvI3A3biNwI3EoeSNxI3IyayNyfih5OHoqfFolcDdbJWdTJXYhYk9yKHlycytvc3coeXd4KFB4I08oeSNPI1AyViNQI28oeSNvI3A3biNwI3EoeSNxI3IyayNyfih5OHIreFglcDdbJWdTJXYhYk93K293eCxleCNPK28jTyNQLlYjUCNvK28jbyNwMF4jcCNxK28jcSNyLmsjcn4rbzhyLGpYJXA3W093K293eC1WeCNPK28jTyNQLlYjUCNvK28jbyNwMF4jcCNxK28jcSNyLmsjcn4rbzhyLVtYJXA3W093K293eC13eCNPK28jTyNQLlYjUCNvK28jbyNwMF4jcCNxK28jcSNyLmsjcn4rbzdbLXxSJXA3W08jby13I3AjcS13I3J+LXc4ci5bVCVwN1tPI28rbyNvI3AuayNwI3ErbyNxI3IuayNyfitvIWYuclYlZ1MldiFiT3cua3d4L1h4I08uayNPI1AwVyNQI28uayNvI3AwXiNwfi5rIWYvW1ZPdy5rd3gvcXgjTy5rI08jUDBXI1Ajby5rI28jcDBeI3B+LmshZi90VU93Lmt4I08uayNPI1AwVyNQI28uayNvI3AwXiNwfi5rIWYwWlBPfi5rIWYwY1YlZ1NPdzB4d3gxXngjTzB4I08jUDJQI1AjbzB4I28jcC5rI3B+MHhTMH1UJWdTT3cweHd4MV54I08weCNPI1AyUCNQfjB4UzFhVE93MHh3eDFweCNPMHgjTyNQMlAjUH4weFMxc1NPdzB4eCNPMHgjTyNQMlAjUH4weFMyU1BPfjB4OHoyW1QlcDdbTyNvKHkjbyNwMmsjcCNxKHkjcSNyMmsjcn4oeSFuMnRYJWdTJWpXJXYhYk9yMmtyczNhc3cya3d4NHd4I08yayNPI1A3aCNQI28yayNvI3A3biNwfjJrIW4zaFglZ1MldiFiT3Iya3JzNFRzdzJrd3g0d3gjTzJrI08jUDdoI1AjbzJrI28jcDduI3B+MmshbjRbWCVnUyV2IWJPcjJrcnMua3N3Mmt3eDR3eCNPMmsjTyNQN2gjUCNvMmsjbyNwN24jcH4yayFuNHxYJWpXT3Iya3JzM2FzdzJrd3g1aXgjTzJrI08jUDdoI1AjbzJrI28jcDduI3B+MmshbjVuWCVqV09yMmtyczNhc3cya3d4Nlp4I08yayNPI1A3aCNQI28yayNvI3A3biNwfjJrVzZgVCVqV09yNlpyczZvcyNPNlojTyNQN2IjUH42Wlc2clRPcjZacnM3UnMjTzZaI08jUDdiI1B+NlpXN1VTT3I2WnMjTzZaI08jUDdiI1B+NlpXN2VQT342WiFuN2tQT34yayFuN3VYJWdTJWpXT3I4YnJzOU9zdzhid3g6VXgjTzhiI08jUDtbI1AjbzhiI28jcDJrI3B+OGJbOGlWJWdTJWpXT3I4YnJzOU9zdzhid3g6VXgjTzhiI08jUDtbI1B+OGJbOVRWJWdTT3I4YnJzOWpzdzhid3g6VXgjTzhiI08jUDtbI1B+OGJbOW9WJWdTT3I4YnJzMHhzdzhid3g6VXgjTzhiI08jUDtbI1B+OGJbOlpWJWpXT3I4YnJzOU9zdzhid3g6cHgjTzhiI08jUDtbI1B+OGJbOnVWJWpXT3I4YnJzOU9zdzhid3g2WngjTzhiI08jUDtbI1B+OGJbO19QT344Yjh6O2laJXA3WyVqV09yKHlycyl3c3coeXd4PFt4I08oeSNPI1AyViNQI28oeSNvI3A3biNwI3EoeSNxI3IyayNyfih5N2Q8Y1glcDdbJWpXT3I8W3JzPU9zI088WyNPI1A+YiNQI288WyNvI3A2WiNwI3E8WyNxI3I2WiNyfjxbN2Q9VFglcDdbT3I8W3JzPXBzI088WyNPI1A+YiNQI288WyNvI3A2WiNwI3E8WyNxI3I2WiNyfjxbN2Q9dVglcDdbT3I8W3JzLXdzI088WyNPI1A+YiNQI288WyNvI3A2WiNwI3E8WyNxI3I2WiNyfjxbN2Q+Z1QlcDdbTyNvPFsjbyNwNlojcCNxPFsjcSNyNlojcn48WzlbPntUJXA3W08jbydQI28jcD9bI3AjcSdQI3Ejcj9bI3J+J1AjTz9nWCVnUyVqVyVtYCV2IWJPcj9bcnNAU3N3P1t3eDR3eCNPP1sjTyNQQ08jUCNvP1sjbyNwQ1UjcH4/WyNPQF1YJWdTJW1gJXYhYk9yP1tyc0B4c3c/W3d4NHd4I08/WyNPI1BDTyNQI28/WyNvI3BDVSNwfj9bI09BUlglZ1MlbWAldiFiT3I/W3JzQW5zdz9bd3g0d3gjTz9bI08jUENPI1Ajbz9bI28jcENVI3B+P1shdkF3ViVnUyVtYCV2IWJPd0Fud3gvWHgjT0FuI08jUEJeI1Ajb0FuI28jcEJkI3B+QW4hdkJhUE9+QW4hdkJpViVnU093MHh3eDFeeCNPMHgjTyNQMlAjUCNvMHgjbyNwQW4jcH4weCNPQ1JQT34/WyNPQ11YJWdTJWpXT3I4YnJzOU9zdzhid3g6VXgjTzhiI08jUDtbI1AjbzhiI28jcD9bI3B+OGI5W0RUWiVwN1slZ1MlbWAldiFiT3InUHJzRHZzdydQd3goUHgjTydQI08jUD52I1AjbydQI28jcENVI3AjcSdQI3Ejcj9bI3J+J1A5U0VSWCVwN1slZ1MlbWAldiFiT3dEdnd4LGV4I09EdiNPI1BFbiNQI29EdiNvI3BCZCNwI3FEdiNxI3JBbiNyfkR2OVNFc1QlcDdbTyNvRHYjbyNwQW4jcCNxRHYjcSNyQW4jcn5EdjxiRl9aJXA3WyVqVyVzcCV4I3RPckdRcnMpd3N3R1F3eE1eeCNPR1EjTyNQSFMjUCNvR1EjbyNwTGojcCNxR1EjcSNySGgjcn5HUTxiR2FaJXA3WyVnUyVqVyVzcCV2IWIleCN0T3JHUXJzKXdzd0dRd3hGU3gjT0dRI08jUEhTI1Ajb0dRI28jcExqI3AjcUdRI3EjckhoI3J+R1E8YkhYVCVwN1tPI29HUSNvI3BIaCNwI3FHUSNxI3JIaCNyfkdRJlVIdVglZ1Mlalclc3AldiFiJXgjdE9ySGhyczNhc3dIaHd4SWJ4I09IaCNPI1BMZCNQI29IaCNvI3BMaiNwfkhoJlVJa1glalclc3AleCN0T3JIaHJzM2Fzd0hod3hKV3gjT0hoI08jUExkI1Ajb0hoI28jcExqI3B+SGgmVUphWCVqVyVzcCV4I3RPckhocnMzYXN3SGh3eEp8eCNPSGgjTyNQTGQjUCNvSGgjbyNwTGojcH5IaCRuS1ZYJWpXJXNwJXgjdE9ySnxyczZvc3dKfHd4Snx4I09KfCNPI1BLciNQI29KfCNvI3BLeCNwfkp8JG5LdVBPfkp8JG5LfVYlaldPcjZacnM2b3MjTzZaI08jUDdiI1AjbzZaI28jcEp8I3B+NlomVUxnUE9+SGgmVUxxWCVnUyVqV09yOGJyczlPc3c4Ynd4OlV4I084YiNPI1A7WyNQI284YiNvI3BIaCNwfjhiPGJNaVolcDdbJWpXJXNwJXgjdE9yR1Fycyl3c3dHUXd4Tlt4I09HUSNPI1BIUyNQI29HUSNvI3BMaiNwI3FHUSNxI3JIaCNyfkdROnpOZ1olcDdbJWpXJXNwJXgjdE9yTltycz1Pc3dOW3d4Tlt4I09OWyNPI1AhIFkjUCNvTlsjbyNwS3gjcCNxTlsjcSNySnwjcn5OWzp6ISBfVCVwN1tPI29OWyNvI3BKfCNwI3FOWyNxI3JKfCNyfk5bPHIhIHNUJXA3W08jbyR9I28jcCEhUyNwI3EkfSNxI3IhIVMjcn4kfSZmISFjWCVnUyVqVyVtYCVzcCV2IWIleCN0T3IhIVNyc0BTc3chIVN3eElieCNPISFTI08jUCEjTyNQI28hIVMjbyNwISNVI3B+ISFTJmYhI1JQT34hIVMmZiEjXVglZ1MlaldPcjhicnM5T3N3OGJ3eDpVeCNPOGIjTyNQO1sjUCNvOGIjbyNwISFTI3B+OGJNZyEkXWElcDdbJWdTJWpXJG8xcyVtYCVzcCV2IWIleCN0T1gkfVhZISN4WVskfVtdISN4XXAkfXBxISN4cXIkfXJzJlJzdyR9d3hGU3gjTyR9I08jUCElYiNQI28kfSNvI3AhI1UjcCNxJH0jcSNyISFTI3J+JH1NZyElZ1glcDdbT1kkfVlaISN4Wl0kfV1eISN4XiNvJH0jbyNwISFTI3AjcSR9I3EjciEhUyNyfiR9PHUhJmViJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3ghXyR9IV8hYCEnbSFgI08kfSNPI1AhIG4jUCNUJH0jVCNVIShzI1UjZiR9I2YjZyEocyNnI2ghKHMjaCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9PHUhKFFaalIlcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfTx1ISlXWiFqUiVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4I08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3shKllfJXRwJXA3WyVnUyVlLFglbWAldiFiT1khK1hZWidQWl0hK1hdXidQXnIhK1hycyFCUHN3IStYd3ghLWd4I08hK1gjTyNQIT5lI1AjbyErWCNvI3AhQH0jcCNxIStYI3EjciE+eSNyfiErWERlIStoXyVwN1slZ1MlalclZSxYJW1gJXYhYk9ZIStYWVonUFpdIStYXV4nUF5yIStYcnMhLGdzdyErWHd4IS1neCNPIStYI08jUCE+ZSNQI28hK1gjbyNwIUB9I3AjcSErWCNxI3IhPnkjcn4hK1hEZSEsdFolcDdbJWdTJWUsWCVtYCV2IWJPcidQcnNDeHN3J1B3eChQeCNPJ1AjTyNQPnYjUCNvJ1AjbyNwQ1UjcCNxJ1AjcSNyP1sjcn4nUERUIS1wXyVwN1slalclZSxYT1khLm9ZWih5Wl0hLm9dXih5XnIhLm9ycyEve3N3IS5vd3ghO1J4I08hLm8jTyNQITB5I1AjbyEubyNvI3AhNm0jcCNxIS5vI3EjciExXyNyfiEub0RUIS58XyVwN1slZ1MlalclZSxYJXYhYk9ZIS5vWVooeVpdIS5vXV4oeV5yIS5vcnMhL3tzdyEub3d4IS1neCNPIS5vI08jUCEweSNQI28hLm8jbyNwITZtI3AjcSEubyNxI3IhMV8jcn4hLm9EVCEwV1olcDdbJWdTJWUsWCV2IWJPcih5cnMqc3N3KHl3eChQeCNPKHkjTyNQMlYjUCNvKHkjbyNwN24jcCNxKHkjcSNyMmsjcn4oeURUITFPVCVwN1tPI28hLm8jbyNwITFfI3AjcSEubyNxI3IhMV8jcn4hLm8tdyExal0lZ1MlalclZSxYJXYhYk9ZITFfWVoya1pdITFfXV4ya15yITFfcnMhMmNzdyExX3d4ITNYeCNPITFfI08jUCE2ZyNQI28hMV8jbyNwITZtI3B+ITFfLXchMmxYJWdTJWUsWCV2IWJPcjJrcnM0VHN3Mmt3eDR3eCNPMmsjTyNQN2gjUCNvMmsjbyNwN24jcH4yay13ITNgXSVqVyVlLFhPWSExX1laMmtaXSExX11eMmteciExX3JzITJjc3chMV93eCE0WHgjTyExXyNPI1AhNmcjUCNvITFfI28jcCE2bSNwfiExXy13ITRgXSVqVyVlLFhPWSExX1laMmtaXSExX11eMmteciExX3JzITJjc3chMV93eCE1WHgjTyExXyNPI1AhNmcjUCNvITFfI28jcCE2bSNwfiExXyxhITVgWCVqVyVlLFhPWSE1WFlaNlpaXSE1WF1eNlpeciE1WHJzITV7cyNPITVYI08jUCE2YSNQfiE1WCxhITZRVCVlLFhPcjZacnM3UnMjTzZaI08jUDdiI1B+NlosYSE2ZFBPfiE1WC13ITZqUE9+ITFfLXchNnZdJWdTJWpXJWUsWE9ZITdvWVo4YlpdITdvXV44Yl5yITdvcnMhOGtzdyE3b3d4ITlYeCNPITdvI08jUCE6eyNQI28hN28jbyNwITFfI3B+ITdvLGUhN3haJWdTJWpXJWUsWE9ZITdvWVo4YlpdITdvXV44Yl5yITdvcnMhOGtzdyE3b3d4ITlYeCNPITdvI08jUCE6eyNQfiE3byxlIThyViVnUyVlLFhPcjhicnM5anN3OGJ3eDpVeCNPOGIjTyNQO1sjUH44YixlITlgWiVqVyVlLFhPWSE3b1laOGJaXSE3b11eOGJeciE3b3JzIThrc3chN293eCE6UngjTyE3byNPI1AhOnsjUH4hN28sZSE6WVolalclZSxYT1khN29ZWjhiWl0hN29dXjhiXnIhN29ycyE4a3N3ITdvd3ghNVh4I08hN28jTyNQITp7I1B+ITdvLGUhO09QT34hN29EVCE7W18lcDdbJWpXJWUsWE9ZIS5vWVooeVpdIS5vXV4oeV5yIS5vcnMhL3tzdyEub3d4ITxaeCNPIS5vI08jUCEweSNQI28hLm8jbyNwITZtI3AjcSEubyNxI3IhMV8jcn4hLm9CbSE8ZF0lcDdbJWpXJWUsWE9ZITxaWVo8W1pdITxaXV48W15yITxacnMhPV1zI08hPFojTyNQIT5QI1AjbyE8WiNvI3AhNVgjcCNxITxaI3EjciE1WCNyfiE8WkJtIT1kWCVwN1slZSxYT3I8W3JzPXBzI088WyNPI1A+YiNQI288WyNvI3A2WiNwI3E8WyNxI3I2WiNyfjxbQm0hPlVUJXA3W08jbyE8WiNvI3AhNVgjcCNxITxaI3EjciE1WCNyfiE8WkRlIT5qVCVwN1tPI28hK1gjbyNwIT55I3AjcSErWCNxI3IhPnkjcn4hK1guWCE/V10lZ1MlalclZSxYJW1gJXYhYk9ZIT55WVo/W1pdIT55XV4/W15yIT55cnMhQFBzdyE+eXd4ITNYeCNPIT55I08jUCFAdyNQI28hPnkjbyNwIUB9I3B+IT55LlghQFtYJWdTJWUsWCVtYCV2IWJPcj9bcnNAeHN3P1t3eDR3eCNPP1sjTyNQQ08jUCNvP1sjbyNwQ1UjcH4/Wy5YIUB6UE9+IT55LlghQVddJWdTJWpXJWUsWE9ZITdvWVo4YlpdITdvXV44Yl5yITdvcnMhOGtzdyE3b3d4ITlYeCNPITdvI08jUCE6eyNQI28hN28jbyNwIT55I3B+ITdvR1ohQl5aJXA3WyVnUyVlLFglbWAldiFiT3InUHJzIUNQc3cnUHd4KFB4I08nUCNPI1A+diNQI28nUCNvI3BDVSNwI3EnUCNxI3I/WyNyfidQR1ohQ2BYJWsjfCVwN1slZ1MlaSxYJW1gJXYhYk93RHZ3eCxleCNPRHYjTyNQRW4jUCNvRHYjbyNwQmQjcCNxRHYjcSNyQW4jcn5Edk1nIURgX1ExcyVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9ZIUN7WVokfVpdIUN7XV4kfV5yIUN7cnMhRV9zdyFDe3d4I0hxeCNPIUN7I08jUCQoaSNQI28hQ3sjbyNwJCp7I3AjcSFDeyNxI3IkKV0jcn4hQ3tKUCFFbF9RMXMlcDdbJWdTJW1gJXYhYk9ZIUZrWVonUFpdIUZrXV4nUF5yIUZrcnMjRWtzdyFGa3d4IUd5eCNPIUZrI08jUCM9dSNQI28hRmsjbyNwI0RpI3AjcSFGayNxI3IjPmkjcn4hRmtKUCFGel9RMXMlcDdbJWdTJWpXJW1gJXYhYk9ZIUZrWVonUFpdIUZrXV4nUF5yIUZrcnMhRV9zdyFGa3d4IUd5eCNPIUZrI08jUCM9dSNQI28hRmsjbyNwI0RpI3AjcSFGayNxI3IjPmkjcn4hRmtJbyFIU19RMXMlcDdbJWpXT1khSVJZWih5Wl0hSVJdXih5XnIhSVJycyFKX3N3IUlSd3gjOHd4I08hSVIjTyNQIypSI1AjbyFJUiNvI3AjMn0jcCNxIUlSI3EjciMqdSNyfiFJUklvIUlgX1ExcyVwN1slZ1MlalcldiFiT1khSVJZWih5Wl0hSVJdXih5XnIhSVJycyFKX3N3IUlSd3ghR3l4I08hSVIjTyNQIypSI1AjbyFJUiNvI3AjMn0jcCNxIUlSI3EjciMqdSNyfiFJUklvIUpqX1ExcyVwN1slZ1MldiFiT1khSVJZWih5Wl0hSVJdXih5XnIhSVJycyFLaXN3IUlSd3ghR3l4I08hSVIjTyNQIypSI1AjbyFJUiNvI3AjMn0jcCNxIUlSI3EjciMqdSNyfiFJUklvIUt0X1ExcyVwN1slZ1MldiFiT1khSVJZWih5Wl0hSVJdXih5XnIhSVJycyFMc3N3IUlSd3ghR3l4I08hSVIjTyNQIypSI1AjbyFJUiNvI3AjMn0jcCNxIUlSI3EjciMqdSNyfiFJUklnIU1PXVExcyVwN1slZ1MldiFiT1khTHNZWitvWl0hTHNdXitvXnchTHN3eCFNd3gjTyFMcyNPI1AjIXkjUCNvIUxzI28jcCMmbSNwI3EhTHMjcSNyIyNtI3J+IUxzSWchTk9dUTFzJXA3W09ZIUxzWVorb1pdIUxzXV4rb153IUxzd3ghTnd4I08hTHMjTyNQIyF5I1AjbyFMcyNvI3AjJm0jcCNxIUxzI3EjciMjbSNyfiFMc0lnIyBPXVExcyVwN1tPWSFMc1laK29aXSFMc11eK29edyFMc3d4IyB3eCNPIUxzI08jUCMheSNQI28hTHMjbyNwIyZtI3AjcSFMcyNxI3IjI20jcn4hTHNIUCMhT1hRMXMlcDdbT1kjIHdZWi13Wl0jIHddXi13XiNvIyB3I28jcCMhayNwI3EjIHcjcSNyIyFrI3J+IyB3MXMjIXBSUTFzT1kjIWtaXSMha15+IyFrSWcjI1FYUTFzJXA3W09ZIUxzWVorb1pdIUxzXV4rb14jbyFMcyNvI3AjI20jcCNxIUxzI3EjciMjbSNyfiFMczNaIyN2WlExcyVnUyV2IWJPWSMjbVlaLmtaXSMjbV1eLmtedyMjbXd4IyRpeCNPIyNtI08jUCMmWCNQI28jI20jbyNwIyZtI3B+IyNtM1ojJG5aUTFzT1kjI21ZWi5rWl0jI21dXi5rXncjI213eCMlYXgjTyMjbSNPI1AjJlgjUCNvIyNtI28jcCMmbSNwfiMjbTNaIyVmWlExc09ZIyNtWVoua1pdIyNtXV4ua153IyNtd3gjIWt4I08jI20jTyNQIyZYI1AjbyMjbSNvI3AjJm0jcH4jI20zWiMmXlRRMXNPWSMjbVlaLmtaXSMjbV1eLmtefiMjbTNaIyZ0WlExcyVnU09ZIydnWVoweFpdIydnXV4weF53Iydnd3gjKFp4I08jJ2cjTyNQIyltI1AjbyMnZyNvI3AjI20jcH4jJ2cxdyMnblhRMXMlZ1NPWSMnZ1laMHhaXSMnZ11eMHhedyMnZ3d4IyhaeCNPIydnI08jUCMpbSNQfiMnZzF3IyhgWFExc09ZIydnWVoweFpdIydnXV4weF53Iydnd3gjKHt4I08jJ2cjTyNQIyltI1B+IydnMXcjKVFYUTFzT1kjJ2dZWjB4Wl0jJ2ddXjB4XncjJ2d3eCMha3gjTyMnZyNPI1AjKW0jUH4jJ2cxdyMpclRRMXNPWSMnZ1laMHhaXSMnZ11eMHhefiMnZ0lvIypZWFExcyVwN1tPWSFJUllaKHlaXSFJUl1eKHleI28hSVIjbyNwIyp1I3AjcSFJUiNxI3IjKnUjcn4hSVIzYyMrUV1RMXMlZ1MlalcldiFiT1kjKnVZWjJrWl0jKnVdXjJrXnIjKnVycyMreXN3Iyp1d3gjLX14I08jKnUjTyNQIzJpI1AjbyMqdSNvI3AjMn0jcH4jKnUzYyMsU11RMXMlZ1MldiFiT1kjKnVZWjJrWl0jKnVdXjJrXnIjKnVycyMse3N3Iyp1d3gjLX14I08jKnUjTyNQIzJpI1AjbyMqdSNvI3AjMn0jcH4jKnUzYyMtVV1RMXMlZ1MldiFiT1kjKnVZWjJrWl0jKnVdXjJrXnIjKnVycyMjbXN3Iyp1d3gjLX14I08jKnUjTyNQIzJpI1AjbyMqdSNvI3AjMn0jcH4jKnUzYyMuVV1RMXMlaldPWSMqdVlaMmtaXSMqdV1eMmteciMqdXJzIyt5c3cjKnV3eCMufXgjTyMqdSNPI1AjMmkjUCNvIyp1I28jcCMyfSNwfiMqdTNjIy9VXVExcyVqV09ZIyp1WVoya1pdIyp1XV4ya15yIyp1cnMjK3lzdyMqdXd4Iy99eCNPIyp1I08jUCMyaSNQI28jKnUjbyNwIzJ9I3B+Iyp1MXsjMFVYUTFzJWpXT1kjL31ZWjZaWl0jL31dXjZaXnIjL31ycyMwcXMjTyMvfSNPI1AjMlQjUH4jL30xeyMwdlhRMXNPWSMvfVlaNlpaXSMvfV1eNlpeciMvfXJzIzFjcyNPIy99I08jUCMyVCNQfiMvfTF7IzFoWFExc09ZIy99WVo2WlpdIy99XV42Wl5yIy99cnMjIWtzI08jL30jTyNQIzJUI1B+Iy99MXsjMllUUTFzT1kjL31ZWjZaWl0jL31dXjZaXn4jL30zYyMyblRRMXNPWSMqdVlaMmtaXSMqdV1eMmtefiMqdTNjIzNXXVExcyVnUyVqV09ZIzRQWVo4YlpdIzRQXV44Yl5yIzRQcnMjNHtzdyM0UHd4IzZveCNPIzRQI08jUCM4YyNQI28jNFAjbyNwIyp1I3B+IzRQMlAjNFlaUTFzJWdTJWpXT1kjNFBZWjhiWl0jNFBdXjhiXnIjNFBycyM0e3N3IzRQd3gjNm94I08jNFAjTyNQIzhjI1B+IzRQMlAjNVNaUTFzJWdTT1kjNFBZWjhiWl0jNFBdXjhiXnIjNFBycyM1dXN3IzRQd3gjNm94I08jNFAjTyNQIzhjI1B+IzRQMlAjNXxaUTFzJWdTT1kjNFBZWjhiWl0jNFBdXjhiXnIjNFBycyMnZ3N3IzRQd3gjNm94I08jNFAjTyNQIzhjI1B+IzRQMlAjNnZaUTFzJWpXT1kjNFBZWjhiWl0jNFBdXjhiXnIjNFBycyM0e3N3IzRQd3gjN2l4I08jNFAjTyNQIzhjI1B+IzRQMlAjN3BaUTFzJWpXT1kjNFBZWjhiWl0jNFBdXjhiXnIjNFBycyM0e3N3IzRQd3gjL314I08jNFAjTyNQIzhjI1B+IzRQMlAjOGhUUTFzT1kjNFBZWjhiWl0jNFBdXjhiXn4jNFBJbyM5UV9RMXMlcDdbJWpXT1khSVJZWih5Wl0hSVJdXih5XnIhSVJycyFKX3N3IUlSd3gjOlB4I08hSVIjTyNQIypSI1AjbyFJUiNvI3AjMn0jcCNxIUlSI3EjciMqdSNyfiFJUkhYIzpZXVExcyVwN1slaldPWSM6UFlaPFtaXSM6UF1ePFteciM6UHJzIztScyNPIzpQI08jUCM9UiNQI28jOlAjbyNwIy99I3AjcSM6UCNxI3IjL30jcn4jOlBIWCM7WV1RMXMlcDdbT1kjOlBZWjxbWl0jOlBdXjxbXnIjOlBycyM8UnMjTyM6UCNPI1AjPVIjUCNvIzpQI28jcCMvfSNwI3EjOlAjcSNyIy99I3J+IzpQSFgjPFldUTFzJXA3W09ZIzpQWVo8W1pdIzpQXV48W15yIzpQcnMjIHdzI08jOlAjTyNQIz1SI1AjbyM6UCNvI3AjL30jcCNxIzpQI3EjciMvfSNyfiM6UEhYIz1ZWFExcyVwN1tPWSM6UFlaPFtaXSM6UF1ePFteI28jOlAjbyNwIy99I3AjcSM6UCNxI3IjL30jcn4jOlBKUCM9fFhRMXMlcDdbT1khRmtZWidQWl0hRmtdXidQXiNvIUZrI28jcCM+aSNwI3EhRmsjcSNyIz5pI3J+IUZrM3MjPnZdUTFzJWdTJWpXJW1gJXYhYk9ZIz5pWVo/W1pdIz5pXV4/W15yIz5pcnMjP29zdyM+aXd4Iy19eCNPIz5pI08jUCNEVCNQI28jPmkjbyNwI0RpI3B+Iz5pM3MjP3pdUTFzJWdTJW1gJXYhYk9ZIz5pWVo/W1pdIz5pXV4/W15yIz5pcnMjQHNzdyM+aXd4Iy19eCNPIz5pI08jUCNEVCNQI28jPmkjbyNwI0RpI3B+Iz5pM3MjQU9dUTFzJWdTJW1gJXYhYk9ZIz5pWVo/W1pdIz5pXV4/W15yIz5pcnMjQXdzdyM+aXd4Iy19eCNPIz5pI08jUCNEVCNQI28jPmkjbyNwI0RpI3B+Iz5pM2sjQlNaUTFzJWdTJW1gJXYhYk9ZI0F3WVpBblpdI0F3XV5Bbl53I0F3d3gjJGl4I08jQXcjTyNQI0J1I1AjbyNBdyNvI3AjQ1ojcH4jQXczayNCelRRMXNPWSNBd1laQW5aXSNBd11eQW5efiNBdzNrI0NiWlExcyVnU09ZIydnWVoweFpdIydnXV4weF53Iydnd3gjKFp4I08jJ2cjTyNQIyltI1AjbyMnZyNvI3AjQXcjcH4jJ2czcyNEWVRRMXNPWSM+aVlaP1taXSM+aV1eP1tefiM+aTNzI0RyXVExcyVnUyVqV09ZIzRQWVo4YlpdIzRQXV44Yl5yIzRQcnMjNHtzdyM0UHd4IzZveCNPIzRQI08jUCM4YyNQI28jNFAjbyNwIz5pI3B+IzRQSlAjRXhfUTFzJXA3WyVnUyVtYCV2IWJPWSFGa1laJ1BaXSFGa11eJ1BeciFGa3JzI0Z3c3chRmt3eCFHeXgjTyFGayNPI1AjPXUjUCNvIUZrI28jcCNEaSNwI3EhRmsjcSNyIz5pI3J+IUZrSXcjR1VdUTFzJXA3WyVnUyVtYCV2IWJPWSNGd1laRHZaXSNGd11eRHZedyNGd3d4IU13eCNPI0Z3I08jUCNHfSNQI28jRncjbyNwI0NaI3AjcSNGdyNxI3IjQXcjcn4jRndJdyNIVVhRMXMlcDdbT1kjRndZWkR2Wl0jRnddXkR2XiNvI0Z3I28jcCNBdyNwI3EjRncjcSNyI0F3I3J+I0Z3TVYjSU9fUTFzJXA3WyVqVyVzcCV4I3RPWSNJfVlaR1FaXSNJfV1eR1FeciNJfXJzIUpfc3cjSX13eCQlXXgjTyNJfSNPI1AjS18jUCNvI0l9I28jcCQkWiNwI3EjSX0jcSNyI0xSI3J+I0l9TVYjSmBfUTFzJXA3WyVnUyVqVyVzcCV2IWIleCN0T1kjSX1ZWkdRWl0jSX1dXkdRXnIjSX1ycyFKX3N3I0l9d3gjSHF4I08jSX0jTyNQI0tfI1AjbyNJfSNvI3AkJFojcCNxI0l9I3EjciNMUiNyfiNJfU1WI0tmWFExcyVwN1tPWSNJfVlaR1FaXSNJfV1eR1FeI28jSX0jbyNwI0xSI3AjcSNJfSNxI3IjTFIjcn4jSX02eSNMYl1RMXMlZ1Mlalclc3AldiFiJXgjdE9ZI0xSWVpIaFpdI0xSXV5IaF5yI0xScnMjK3lzdyNMUnd4I01aeCNPI0xSI08jUCQjdSNQI28jTFIjbyNwJCRaI3B+I0xSNnkjTWZdUTFzJWpXJXNwJXgjdE9ZI0xSWVpIaFpdI0xSXV5IaF5yI0xScnMjK3lzdyNMUnd4I05feCNPI0xSI08jUCQjdSNQI28jTFIjbyNwJCRaI3B+I0xSNnkjTmpdUTFzJWpXJXNwJXgjdE9ZI0xSWVpIaFpdI0xSXV5IaF5yI0xScnMjK3lzdyNMUnd4JCBjeCNPI0xSI08jUCQjdSNQI28jTFIjbyNwJCRaI3B+I0xSNWMkIG5dUTFzJWpXJXNwJXgjdE9ZJCBjWVpKfFpdJCBjXV5KfF5yJCBjcnMjMHFzdyQgY3d4JCBjeCNPJCBjI08jUCQhZyNQI28kIGMjbyNwJCF7I3B+JCBjNWMkIWxUUTFzT1kkIGNZWkp8Wl0kIGNdXkp8Xn4kIGM1YyQjU1pRMXMlaldPWSMvfVlaNlpaXSMvfV1eNlpeciMvfXJzIzBxcyNPIy99I08jUCMyVCNQI28jL30jbyNwJCBjI3B+Iy99NnkkI3pUUTFzT1kjTFJZWkhoWl0jTFJdXkhoXn4jTFI2eSQkZF1RMXMlZ1MlaldPWSM0UFlaOGJaXSM0UF1eOGJeciM0UHJzIzR7c3cjNFB3eCM2b3gjTyM0UCNPI1AjOGMjUCNvIzRQI28jcCNMUiNwfiM0UE1WJCVqX1ExcyVwN1slalclc3AleCN0T1kjSX1ZWkdRWl0jSX1dXkdRXnIjSX1ycyFKX3N3I0l9d3gkJml4I08jSX0jTyNQI0tfI1AjbyNJfSNvI3AkJFojcCNxI0l9I3EjciNMUiNyfiNJfUtvJCZ2X1ExcyVwN1slalclc3AleCN0T1kkJmlZWk5bWl0kJmldXk5bXnIkJmlycyM7UnN3JCZpd3gkJml4I08kJmkjTyNQJCd1I1AjbyQmaSNvI3AkIXsjcCNxJCZpI3EjciQgYyNyfiQmaUtvJCd8WFExcyVwN1tPWSQmaVlaTltaXSQmaV1eTlteI28kJmkjbyNwJCBjI3AjcSQmaSNxI3IkIGMjcn4kJmlNZyQocFhRMXMlcDdbT1khQ3tZWiR9Wl0hQ3tdXiR9XiNvIUN7I28jcCQpXSNwI3EhQ3sjcSNyJCldI3J+IUN7N1okKW5dUTFzJWdTJWpXJW1gJXNwJXYhYiV4I3RPWSQpXVlaISFTWl0kKV1dXiEhU15yJCldcnMjP29zdyQpXXd4I01aeCNPJCldI08jUCQqZyNQI28kKV0jbyNwJCp7I3B+JCldN1okKmxUUTFzT1kkKV1ZWiEhU1pdJCldXV4hIVNefiQpXTdaJCtVXVExcyVnUyVqV09ZIzRQWVo4YlpdIzRQXV44Yl5yIzRQcnMjNHtzdyM0UHd4IzZveCNPIzRQI08jUCM4YyNQI28jNFAjbyNwJCldI3B+IzRQR3okLGJdJH1RJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3ghXyR9IV8hYCQtWiFgI08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3okLW5aIXMsVyVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4I08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3okLnRdJHdRJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3ghXyR9IV8hYCQtWiFgI08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3skL3xfJXFgJXA3WyVqVyVlLFglc3AleCN0T1kkMHtZWkdRWl0kMHtdXkdRXnIkMHtycyQyXXN3JDB7d3gkSmV4I08kMHsjTyNQJEZ3I1AjbyQweyNvI3AkSWMjcCNxJDB7I3EjciRHXSNyfiQwe0drJDFeXyVwN1slZ1MlalclZSxYJXNwJXYhYiV4I3RPWSQwe1laR1FaXSQwe11eR1FeciQwe3JzJDJdc3ckMHt3eCRFd3gjTyQweyNPI1AkRncjUCNvJDB7I28jcCRJYyNwI3EkMHsjcSNyJEddI3J+JDB7RFQkMmhfJXA3WyVnUyVlLFgldiFiT1kkM2dZWih5Wl0kM2ddXih5XnIkM2dycyRCYXN3JDNnd3gkNHN4I08kM2cjTyNQJDVvI1AjbyQzZyNvI3AkPXsjcCNxJDNnI3EjciQ2VCNyfiQzZ0RUJDN0XyVwN1slZ1MlalclZSxYJXYhYk9ZJDNnWVooeVpdJDNnXV4oeV5yJDNncnMkMl1zdyQzZ3d4JDRzeCNPJDNnI08jUCQ1byNQI28kM2cjbyNwJD17I3AjcSQzZyNxI3IkNlQjcn4kM2dEVCQ0fFolcDdbJWpXJWUsWE9yKHlycyl3c3coeXd4O2J4I08oeSNPI1AyViNQI28oeSNvI3A3biNwI3EoeSNxI3IyayNyfih5RFQkNXRUJXA3W08jbyQzZyNvI3AkNlQjcCNxJDNnI3EjciQ2VCNyfiQzZy13JDZgXSVnUyVqVyVlLFgldiFiT1kkNlRZWjJrWl0kNlRdXjJrXnIkNlRycyQ3WHN3JDZUd3gkPVJ4I08kNlQjTyNQJD11I1AjbyQ2VCNvI3AkPXsjcH4kNlQtdyQ3Yl0lZ1MlZSxYJXYhYk9ZJDZUWVoya1pdJDZUXV4ya15yJDZUcnMkOFpzdyQ2VHd4JD1SeCNPJDZUI08jUCQ9dSNQI28kNlQjbyNwJD17I3B+JDZULXckOGRdJWdTJWUsWCV2IWJPWSQ2VFlaMmtaXSQ2VF1eMmteciQ2VHJzJDldc3ckNlR3eCQ9UngjTyQ2VCNPI1AkPXUjUCNvJDZUI28jcCQ9eyNwfiQ2VC1vJDlmWiVnUyVlLFgldiFiT1kkOV1ZWi5rWl0kOV1dXi5rXnckOV13eCQ6WHgjTyQ5XSNPI1AkOnMjUCNvJDldI28jcCQ6eSNwfiQ5XS1vJDpeViVlLFhPdy5rd3gvcXgjTy5rI08jUDBXI1Ajby5rI28jcDBeI3B+LmstbyQ6dlBPfiQ5XS1vJDtRWiVnUyVlLFhPWSQ7c1laMHhaXSQ7c11eMHhedyQ7c3d4JDxneCNPJDtzI08jUCQ8eyNQI28kO3MjbyNwJDldI3B+JDtzLF0kO3pYJWdTJWUsWE9ZJDtzWVoweFpdJDtzXV4weF53JDtzd3gkPGd4I08kO3MjTyNQJDx7I1B+JDtzLF0kPGxUJWUsWE93MHh3eDFweCNPMHgjTyNQMlAjUH4weCxdJD1PUE9+JDtzLXckPVlYJWpXJWUsWE9yMmtyczNhc3cya3d4NWl4I08yayNPI1A3aCNQI28yayNvI3A3biNwfjJrLXckPXhQT34kNlQtdyQ+VV0lZ1MlalclZSxYT1kkPn1ZWjhiWl0kPn1dXjhiXnIkPn1ycyQ/eXN3JD59d3gkQW14I08kPn0jTyNQJEJaI1AjbyQ+fSNvI3AkNlQjcH4kPn0sZSQ/V1olZ1MlalclZSxYT1kkPn1ZWjhiWl0kPn1dXjhiXnIkPn1ycyQ/eXN3JD59d3gkQW14I08kPn0jTyNQJEJaI1B+JD59LGUkQFFaJWdTJWUsWE9ZJD59WVo4YlpdJD59XV44Yl5yJD59cnMkQHNzdyQ+fXd4JEFteCNPJD59I08jUCRCWiNQfiQ+fSxlJEB6WiVnUyVlLFhPWSQ+fVlaOGJaXSQ+fV1eOGJeciQ+fXJzJDtzc3ckPn13eCRBbXgjTyQ+fSNPI1AkQlojUH4kPn0sZSRBdFYlalclZSxYT3I4YnJzOU9zdzhid3g6cHgjTzhiI08jUDtbI1B+OGIsZSRCXlBPfiQ+fURUJEJsXyVwN1slZ1MlZSxYJXYhYk9ZJDNnWVooeVpdJDNnXV4oeV5yJDNncnMkQ2tzdyQzZ3d4JDRzeCNPJDNnI08jUCQ1byNQI28kM2cjbyNwJD17I3AjcSQzZyNxI3IkNlQjcn4kM2dDeyRDdl0lcDdbJWdTJWUsWCV2IWJPWSRDa1laK29aXSRDa11eK29edyRDa3d4JERveCNPJENrI08jUCRFYyNQI28kQ2sjbyNwJDp5I3AjcSRDayNxI3IkOV0jcn4kQ2tDeyREdlglcDdbJWUsWE93K293eC1WeCNPK28jTyNQLlYjUCNvK28jbyNwMF4jcCNxK28jcSNyLmsjcn4rb0N7JEVoVCVwN1tPI28kQ2sjbyNwJDldI3AjcSRDayNxI3IkOV0jcn4kQ2tHayRGVVolcDdbJWpXJWUsWCVzcCV4I3RPckdRcnMpd3N3R1F3eE1eeCNPR1EjTyNQSFMjUCNvR1EjbyNwTGojcCNxR1EjcSNySGgjcn5HUUdrJEZ8VCVwN1tPI28kMHsjbyNwJEddI3AjcSQweyNxI3IkR10jcn4kMHsxXyRHbF0lZ1MlalclZSxYJXNwJXYhYiV4I3RPWSRHXVlaSGhaXSRHXV1eSGheciRHXXJzJDdYc3ckR113eCRIZXgjTyRHXSNPI1AkSV0jUCNvJEddI28jcCRJYyNwfiRHXTFfJEhwWCVqVyVlLFglc3AleCN0T3JIaHJzM2Fzd0hod3hKV3gjT0hoI08jUExkI1Ajb0hoI28jcExqI3B+SGgxXyRJYFBPfiRHXTFfJElsXSVnUyVqVyVlLFhPWSQ+fVlaOGJaXSQ+fV1eOGJeciQ+fXJzJD95c3ckPn13eCRBbXgjTyQ+fSNPI1AkQlojUCNvJD59I28jcCRHXSNwfiQ+fUdrJEpyWiVwN1slalclZSxYJXNwJXgjdE9yR1Fycyl3c3dHUXd4JEtleCNPR1EjTyNQSFMjUCNvR1EjbyNwTGojcCNxR1EjcSNySGgjcn5HUUdrJEt0WiVoIWYlcDdbJWpXJWYsWCVzcCV4I3RPck5bcnM9T3N3Tlt3eE5beCNPTlsjTyNQISBZI1Ajb05bI28jcEt4I3AjcU5bI3Ejckp8I3J+TltHeyRMelpmLFglcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfTx1JE5RWiFPUiVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4I08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3slIFdfVCxYJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3h6JH16eyUhVnshXyR9IV8hYCQtWiFgI08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3slIWpdX1IlcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCFfJH0hXyFgJC1aIWAjTyR9I08jUCEgbiNQI28kfSNvI3AhI1UjcCNxJH0jcSNyISFTI3J+JH1HeyUjdl0keixYJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3ghXyR9IV8hYCQtWiFgI08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9PHUlJVNad1IlcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfU1nJSZZXiR7LFglcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCFfJH0hXyFgJC1aIWAhYSUnVSFhI08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9Ql4lJ2laJlMmaiVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4I08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3slKG9fIWRRJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3ghTyR9IU8hUCUpbiFQIVEkfSFRIVslLE8hWyNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfUd7JSpQXSVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4IU8kfSFPIVAlKnghUCNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfUd7JStdWiFtLFglcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfUd5JSxjZyFmLFYlcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCFRJH0hUSFbJSxPIVshZyR9IWchaCUteiFoIWwkfSFsIW0lMlshbSNPJH0jTyNQISBuI1AjUiR9I1IjUyUsTyNTI1gkfSNYI1klLXojWSNeJH0jXiNfJTJbI18jbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfUd5JS5dYSVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4eyR9e3wlL2J8fSR9fSFPJS9iIU8hUSR9IVEhWyUwbCFbI08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3klL3NdJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3ghUSR9IVEhWyUwbCFbI08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3klMVBjIWYsViVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4IVEkfSFRIVslMGwhWyFsJH0hbCFtJTJbIW0jTyR9I08jUCEgbiNQI1IkfSNSI1MlMGwjUyNeJH0jXiNfJTJbI18jbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfUd5JTJvWiFmLFYlcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfUd7JTN1XyR8UiVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4IVAkfSFQIVElNHQhUSFfJH0hXyFgJC1aIWAjTyR9I08jUCEgbiNQI28kfSNvI3AhI1UjcCNxJH0jcSNyISFTI3J+JH1HeiU1WF0lT1ElcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCFfJH0hXyFgJC1aIWAjTyR9I08jUCEgbiNQI28kfSNvI3AhI1UjcCNxJH0jcSNyISFTI3J+JH1HeSU2ZXUhZixWJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3ghTyR9IU8hUCU4eCFQIVEkfSFRIVslOlMhWyFkJH0hZCFlJTxVIWUhZyR9IWchaCUteiFoIWwkfSFsIW0lMlshbSFxJH0hcSFyJT9PIXIheiR9IXoheyVBciF7I08kfSNPI1AhIG4jUCNSJH0jUiNTJTpTI1MjVSR9I1UjViU8VSNWI1gkfSNYI1klLXojWSNeJH0jXiNfJTJbI18jYyR9I2MjZCU/TyNkI2wkfSNsI20lQXIjbSNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3klOVpdJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3ghUSR9IVEhWyUsTyFbI08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3klOmdpIWYsViVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4IU8kfSFPIVAlOHghUCFRJH0hUSFbJTpTIVshZyR9IWchaCUteiFoIWwkfSFsIW0lMlshbSNPJH0jTyNQISBuI1AjUiR9I1IjUyU6UyNTI1gkfSNYI1klLXojWSNeJH0jXiNfJTJbI18jbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfUd5JTxnYCVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4IVEkfSFRIVIlPWkhUiFTJT1pIVMjTyR9I08jUCEgbiNQI1IkfSNSI1MlPWkjUyNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3klPXxgIWYsViVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4IVEkfSFRIVIlPWkhUiFTJT1pIVMjTyR9I08jUCEgbiNQI1IkfSNSI1MlPWkjUyNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3klP2FfJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3ghUSR9IVEhWSVAYCFZI08kfSNPI1AhIG4jUCNSJH0jUiNTJUBgI1MjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfUd5JUBzXyFmLFYlcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCFRJH0hUSFZJUBgIVkjTyR9I08jUCEgbiNQI1IkfSNSI1MlQGAjUyNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3klQlRjJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3ghUSR9IVEhWyVDYCFbIWMkfSFjIWklQ2AhaSNPJH0jTyNQISBuI1AjUiR9I1IjUyVDYCNTI1QkfSNUI1olQ2AjWiNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3klQ3NjIWYsViVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4IVEkfSFRIVslQ2AhWyFjJH0hYyFpJUNgIWkjTyR9I08jUCEgbiNQI1IkfSNSI1MlQ2AjUyNUJH0jVCNaJUNgI1ojbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfU1nJUVjXXgxcyVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4IV8kfSFfIWAlRlshYCNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfTx1JUZvWiVXUiVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4I08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3slR3VaI14sWCVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4I08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9R3slSHtfalIlcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCFeJH0hXiFfJUl6IV8hYCEnbSFgIWEhJ20hYSNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfUd6JUpfXSR4USVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4IV8kfSFfIWAkLVohYCNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfUd7JUtrXSVWLFglcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCFfJH0hXyFgISdtIWAjTyR9I08jUCEgbiNQI28kfSNvI3AhI1UjcCNxJH0jcSNyISFTI3J+JH1HeyVMd15qUiVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4IV8kfSFfIWAhJ20hYCFhJU1zIWEjTyR9I08jUCEgbiNQI28kfSNvI3AhI1UjcCNxJH0jcSNyISFTI3J+JH1HeiVOV10keVElcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCFfJH0hXyFgJC1aIWAjTyR9I08jUCEgbiNQI28kfSNvI3AhI1UjcCNxJH0jcSNyISFTI3J+JH1HeyYgZl1dUSN0UCVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4IV8kfSFfIWAkLVohYCNPJH0jTyNQISBuI1AjbyR9I28jcCEjVSNwI3EkfSNxI3IhIVMjcn4kfU1nJiF0YyVwN1slZ1MlalclZCZqJW1gJXNwJXYhYiV4I3QlUSxYT3IkfXJzJlJzdyR9d3hGU3ghUSR9IVEhWyYhXyFbIWMkfSFjIX0mIV8hfSNPJH0jTyNQISBuI1AjUiR9I1IjUyYhXyNTI1QkfSNUI28mIV8jbyNwISNVI3AjcSR9I3EjciEhUyNyJGckfSRnfiYhX01nJiRmZyVwN1slZ1MlalclZCZqJW1gJXNwJXYhYiV4I3QlUSxYT3IkfXJzJiV9c3ckfXd4JilUeCFRJH0hUSFbJiFfIVshYyR9IWMhdCYhXyF0IXUmLGEhdSF9JiFfIX0jTyR9I08jUCEgbiNQI1IkfSNSI1MmIV8jUyNUJH0jVCNmJiFfI2YjZyYsYSNnI28mIV8jbyNwISNVI3AjcSR9I3EjciEhUyNyJGckfSRnfiYhX0RlJiZbXyVwN1slZ1MlZSxYJW1gJXYhYk9ZIStYWVonUFpdIStYXV4nUF5yIStYcnMmJ1pzdyErWHd4IS1neCNPIStYI08jUCE+ZSNQI28hK1gjbyNwIUB9I3AjcSErWCNxI3IhPnkjcn4hK1hEZSYnaFolcDdbJWdTJWUsWCVtYCV2IWJPcidQcnMmKFpzdydQd3goUHgjTydQI08jUD52I1AjbydQI28jcENVI3AjcSdQI3Ejcj9bI3J+J1BEXSYoaFglcDdbJWdTJWksWCVtYCV2IWJPd0R2d3gsZXgjT0R2I08jUEVuI1Ajb0R2I28jcEJkI3AjcUR2I3EjckFuI3J+RHZHayYpYl8lcDdbJWpXJWUsWCVzcCV4I3RPWSQwe1laR1FaXSQwe11eR1FeciQwe3JzJDJdc3ckMHt3eCYqYXgjTyQweyNPI1AkRncjUCNvJDB7I28jcCRJYyNwI3EkMHsjcSNyJEddI3J+JDB7R2smKm5aJXA3WyVqVyVlLFglc3AleCN0T3JHUXJzKXdzd0dRd3gmK2F4I09HUSNPI1BIUyNQI29HUSNvI3BMaiNwI3FHUSNxI3JIaCNyfkdRRlQmK25aJXA3WyVqVyVmLFglc3AleCN0T3JOW3JzPU9zd05bd3hOW3gjT05bI08jUCEgWSNQI29OWyNvI3BLeCNwI3FOWyNxI3JKfCNyfk5bTWcmLHZjJXA3WyVnUyVqVyVkJmolbWAlc3AldiFiJXgjdCVRLFhPciR9cnMmJX1zdyR9d3gmKVR4IVEkfSFRIVsmIV8hWyFjJH0hYyF9JiFfIX0jTyR9I08jUCEgbiNQI1IkfSNSI1MmIV8jUyNUJH0jVCNvJiFfI28jcCEjVSNwI3EkfSNxI3IhIVMjciRnJH0kZ34mIV9NZyYuaGclcDdbJWdTJWpXJWQmaiVtYCVzcCV2IWIleCN0JVEsWE9yJH1ycyYwUHN3JH13eCYyd3ghUSR9IVEhWyYhXyFbIWMkfSFjIXQmIV8hdCF1JjV1IXUhfSYhXyF9I08kfSNPI1AhIG4jUCNSJH0jUiNTJiFfI1MjVCR9I1QjZiYhXyNmI2cmNXUjZyNvJiFfI28jcCEjVSNwI3EkfSNxI3IhIVMjciRnJH0kZ34mIV9EZSYwXlolcDdbJWdTJW1gJXYhYiVyLFhPcidQcnMmMVBzdydQd3goUHgjTydQI08jUD52I1AjbydQI28jcENVI3AjcSdQI3Ejcj9bI3J+J1BEZSYxW1olcDdbJWdTJW1gJXYhYk9yJ1BycyYxfXN3J1B3eChQeCNPJ1AjTyNQPnYjUCNvJ1AjbyNwQ1UjcCNxJ1AjcSNyP1sjcn4nUERdJjJbWCVwN1slZ1MldyxYJW1gJXYhYk93RHZ3eCxleCNPRHYjTyNQRW4jUCNvRHYjbyNwQmQjcCNxRHYjcSNyQW4jcn5EdkdrJjNVWiVwN1slalclc3AleCN0JWwsWE9yR1Fycyl3c3dHUXd4JjN3eCNPR1EjTyNQSFMjUCNvR1EjbyNwTGojcCNxR1EjcSNySGgjcn5HUUdrJjRTWiVwN1slalclc3AleCN0T3JHUXJzKXdzd0dRd3gmNHV4I09HUSNPI1BIUyNQI29HUSNvI3BMaiNwI3FHUSNxI3JIaCNyfkdRRlQmNVNaJXA3WyVqVyV1LFglc3AleCN0T3JOW3JzPU9zd05bd3hOW3gjT05bI08jUCEgWSNQI29OWyNvI3BLeCNwI3FOWyNxI3JKfCNyfk5bTWcmNltjJXA3WyVnUyVqVyVkJmolbWAlc3AldiFiJXgjdCVRLFhPciR9cnMmMFBzdyR9d3gmMnd4IVEkfSFRIVsmIV8hWyFjJH0hYyF9JiFfIX0jTyR9I08jUCEgbiNQI1IkfSNSI1MmIV8jUyNUJH0jVCNvJiFfI28jcCEjVSNwI3EkfSNxI3IhIVMjciRnJH0kZ34mIV9NZyY3fGslcDdbJWdTJWpXJWQmaiVtYCVzcCV2IWIleCN0JVEsWE9yJH1ycyYlfXN3JH13eCYpVHghUSR9IVEhWyYhXyFbIWMkfSFjIWgmIV8haCFpJjV1IWkhdCYhXyF0IXUmLGEhdSF9JiFfIX0jTyR9I08jUCEgbiNQI1IkfSNSI1MmIV8jUyNUJH0jVCNVJiFfI1UjViYsYSNWI1kmIV8jWSNaJjV1I1ojbyYhXyNvI3AhI1UjcCNxJH0jcSNyISFTI3IkZyR9JGd+JiFfR3smOlVaIVYsWCVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4I08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9PHUmO1taIVdSJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3gjTyR9I08jUCEgbiNQI28kfSNvI3AhI1UjcCNxJH0jcSNyISFTI3J+JH1HeiY8Yl0kdlElcDdbJWdTJWpXJW1gJXNwJXYhYiV4I3RPciR9cnMmUnN3JH13eEZTeCFfJH0hXyFgJC1aIWAjTyR9I08jUCEgbiNQI28kfSNvI3AhI1UjcCNxJH0jcSNyISFTI3J+JH1HeSY9ZFglZ1MlalchWkdtT3I4YnJzOU9zdzhid3g6VXgjTzhiI08jUDtbI1AjbzhiI28jcCEhUyNwfjhiR3omPmRdJHVRJXA3WyVnUyVqVyVtYCVzcCV2IWIleCN0T3IkfXJzJlJzdyR9d3hGU3ghXyR9IV8hYCQtWiFgI08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9PHUmP25YIVs3XyVnUyVqVyVtYCVzcCV2IWIleCN0T3IhIVNyc0BTc3chIVN3eElieCNPISFTI08jUCEjTyNQI28hIVMjbyNwISNVI3B+ISFTR3kmQG5aJVAsViVwN1slZ1MlalclbWAlc3AldiFiJXgjdE9yJH1ycyZSc3ckfXd4RlN4I08kfSNPI1AhIG4jUCNvJH0jbyNwISNVI3AjcSR9I3EjciEhUyNyfiR9XCIsXG4gIHRva2VuaXplcnM6IFtsZWdhY3lQcmludCwgaW5kZW50YXRpb24sIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCBuZXdsaW5lc10sXG4gIHRvcFJ1bGVzOiB7XCJTY3JpcHRcIjpbMCwzXX0sXG4gIHNwZWNpYWxpemVkOiBbe3Rlcm06IDE4NiwgZ2V0OiB2YWx1ZSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogNjU5NFxufSk7XG5cbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLy8gVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZS5cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vLy8gRWFjaCBbbm9kZSB0eXBlXSgjdHJlZS5Ob2RlVHlwZSkgY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoXG4vLy8gaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBwcm9wIG5hbWVzLlxuY2xhc3MgTm9kZVByb3Age1xuICAgIC8vLyBDcmVhdGUgYSBuZXcgbm9kZSBwcm9wIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFcbiAgICAvLy8gYGRlc2VyaWFsaXplYCBmdW5jdGlvbi5cbiAgICBjb25zdHJ1Y3Rvcih7IGRlc2VyaWFsaXplIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmlkID0gbmV4dFByb3BJRCsrO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemUgfHwgKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgZGVmaW5lIGEgZGVzZXJpYWxpemUgZnVuY3Rpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgc3RyaW5nLXZhbHVlZCBub2RlIHByb3Agd2hvc2UgZGVzZXJpYWxpemUgZnVuY3Rpb24gaXNcbiAgICAvLy8gdGhlIGlkZW50aXR5IGZ1bmN0aW9uLlxuICAgIHN0YXRpYyBzdHJpbmcoKSB7IHJldHVybiBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ciB9KTsgfVxuICAgIC8vLyBDcmVhdGUgYSBudW1iZXItdmFsdWVkIG5vZGUgcHJvcCB3aG9zZSBkZXNlcmlhbGl6ZSBmdW5jdGlvbiBpc1xuICAgIC8vLyBqdXN0IGBOdW1iZXJgLlxuICAgIHN0YXRpYyBudW1iZXIoKSB7IHJldHVybiBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogTnVtYmVyIH0pOyB9XG4gICAgLy8vIENyZWF0ZXMgYSBib29sZWFuLXZhbHVlZCBub2RlIHByb3Agd2hvc2UgZGVzZXJpYWxpemUgZnVuY3Rpb25cbiAgICAvLy8gcmV0dXJucyB0cnVlIGZvciBhbnkgaW5wdXQuXG4gICAgc3RhdGljIGZsYWcoKSB7IHJldHVybiBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogKCkgPT4gdHJ1ZSB9KTsgfVxuICAgIC8vLyBTdG9yZSBhIHZhbHVlIGZvciB0aGlzIHByb3AgaW4gdGhlIGdpdmVuIG9iamVjdC4gVGhpcyBjYW4gYmVcbiAgICAvLy8gdXNlZnVsIHdoZW4gYnVpbGRpbmcgdXAgYSBwcm9wIG9iamVjdCB0byBwYXNzIHRvIHRoZVxuICAgIC8vLyBbYE5vZGVUeXBlYF0oI3RyZWUuTm9kZVR5cGUpIGNvbnN0cnVjdG9yLiBSZXR1cm5zIGl0cyBmaXJzdFxuICAgIC8vLyBhcmd1bWVudC5cbiAgICBzZXQocHJvcE9iaiwgdmFsdWUpIHtcbiAgICAgICAgcHJvcE9ialt0aGlzLmlkXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gcHJvcE9iajtcbiAgICB9XG4gICAgLy8vIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgLy8vIFtgTm9kZVNldC5leHRlbmRgXSgjdHJlZS5Ob2RlU2V0LmV4dGVuZCkgb3JcbiAgICAvLy8gW2BQYXJzZXIud2l0aFByb3BzYF0oI2xlemVyLlBhcnNlci53aXRoUHJvcHMpIHRvIGNvbXB1dGUgcHJvcFxuICAgIC8vLyB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgLy8vIG9iamVjdF0oI3RyZWUuTm9kZVR5cGVebWF0Y2gpIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB1bmRlZmluZWRcbiAgICAvLy8gaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgLy8vIGl0IGRvZXMuXG4gICAgYWRkKG1hdGNoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgbWF0Y2ggPSBOb2RlVHlwZS5tYXRjaChtYXRjaCk7XG4gICAgICAgIHJldHVybiAodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFt0aGlzLCByZXN1bHRdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8vLyBQcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuLy8vIGRlbGltaXRlcnMsIHRoaXMgaG9sZHMgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lcyAod3JpdHRlbiBhcyBhXG4vLy8gc3BhY2Utc2VwYXJhdGVkIHN0cmluZyB3aGVuIGRlY2xhcmluZyB0aGlzIHByb3AgaW4gYSBncmFtbWFyKVxuLy8vIGZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbk5vZGVQcm9wLmNsb3NlZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFRoZSBpbnZlcnNlIG9mIFtgb3BlbmVkQnlgXSgjdHJlZS5Ob2RlUHJvcF5jbG9zZWRCeSkuIFRoaXMgaXNcbi8vLyBhdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xuLy8vIG9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFVzZWQgdG8gYXNzaWduIG5vZGUgdHlwZXMgdG8gZ3JvdXBzIChmb3IgZXhhbXBsZSwgYWxsIG5vZGVcbi8vLyB0eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG4vLy8gYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLy8vIEVhY2ggbm9kZSBpbiBhIHN5bnRheCB0cmVlIGhhcyBhIG5vZGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggaXQuXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbmFtZSBvZiB0aGUgbm9kZSB0eXBlLiBOb3QgbmVjZXNzYXJpbHkgdW5pcXVlLCBidXQgaWYgdGhlXG4gICAgLy8vIGdyYW1tYXIgd2FzIHdyaXR0ZW4gcHJvcGVybHksIGRpZmZlcmVudCBub2RlIHR5cGVzIHdpdGggdGhlXG4gICAgLy8vIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIC8vLyByb2xlLlxuICAgIG5hbWUsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwcm9wcywgXG4gICAgLy8vIFRoZSBpZCBvZiB0aGlzIG5vZGUgaW4gaXRzIHNldC4gQ29ycmVzcG9uZHMgdG8gdGhlIHRlcm0gaWRzXG4gICAgLy8vIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICBpZCwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIFRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBFcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBBbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpXG4gICAgICAgICAgICAgICAgICAgIHNyY1swXS5zZXQocHJvcHMsIHNyY1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICAvLy8gUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgLy8vIHRoZSBwcm9wIGlzbid0IHByZXNlbnQgb24gdGhpcyBub2RlLlxuICAgIHByb3AocHJvcCkgeyByZXR1cm4gdGhpcy5wcm9wc1twcm9wLmlkXTsgfVxuICAgIC8vLyBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgIGdldCBpc1RvcCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBUb3AgKi8pID4gMDsgfVxuICAgIC8vLyBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIHByb2R1Y2VkIGJ5IGEgc2tpcCBydWxlLlxuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLy8vIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYW4gZXJyb3Igbm9kZS5cbiAgICBnZXQgaXNFcnJvcigpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgNCAvKiBFcnJvciAqLykgPiAwOyB9XG4gICAgLy8vIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIC8vLyBuYW1lZCBub2RlLCBmb3IgZXhhbXBsZSBiZWNhdXNlIGl0IGlzIHVzZWQgdG8gY2FjaGUgcmVwZXRpdGlvbi5cbiAgICBnZXQgaXNBbm9ueW1vdXMoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDggLyogQW5vbnltb3VzICovKSA+IDA7IH1cbiAgICAvLy8gUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgLy8vIFtncm91cHNdKCN0cmVlLk5vZGVQcm9wXmdyb3VwKSBtYXRjaGVzIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgZnVuY3Rpb24gZnJvbSBub2RlIHR5cGVzIHRvIGFyYml0cmFyeSB2YWx1ZXMgYnlcbiAgICAvLy8gc3BlY2lmeWluZyBhbiBvYmplY3Qgd2hvc2UgcHJvcGVydHkgbmFtZXMgYXJlIG5vZGUgb3JcbiAgICAvLy8gW2dyb3VwXSgjdHJlZS5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI3RyZWUuTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICAvLy8gbmFtZXMsIHNlcGFyYXRlZCBieSBzcGFjZXMsIGluIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUgdG8gbWFwXG4gICAgLy8vIG11bHRpcGxlIG5vZGUgbmFtZXMgdG8gYSBzaW5nbGUgdmFsdWUuXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vLyBBbiBlbXB0eSBkdW1teSBub2RlIHR5cGUgdG8gdXNlIHdoZW4gbm8gYWN0dWFsIHR5cGUgaXMgYXZhaWxhYmxlLlxuTm9kZVR5cGUubm9uZSA9IG5ldyBOb2RlVHlwZShcIlwiLCBPYmplY3QuY3JlYXRlKG51bGwpLCAwLCA4IC8qIEFub255bW91cyAqLyk7XG4vLy8gQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuLy8vIGNvbXBhY3RseSByZXByZXNlbnQgdHJlZXMgYnkgc3RvcmluZyB0aGVpciB0eXBlIGlkcywgcmF0aGVyIHRoYW4gYVxuLy8vIGZ1bGwgcG9pbnRlciB0byB0aGUgdHlwZSBvYmplY3QsIGluIGEgbnVtYmVyIGFycmF5LiBFYWNoIHBhcnNlclxuLy8vIFtoYXNdKCNsZXplci5QYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG4vLy8gYnVmZmVyc10oI3RyZWUuVHJlZUJ1ZmZlcikgY2FuIG9ubHkgc3RvcmUgY29sbGVjdGlvbnMgb2Ygbm9kZXNcbi8vLyBmcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNilcbi8vLyBub2RlIHR5cGVzIGluIGl0LCBzbyB0aGF0IHRoZSBpZHMgZml0IGludG8gMTYtYml0IHR5cGVkIGFycmF5XG4vLy8gc2xvdHMuXG5jbGFzcyBOb2RlU2V0IHtcbiAgICAvLy8gQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgLy8vIHR5cGUgc2hvdWxkIGNvcnJlc3BvbmQgdG8gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXJyYXkuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICB0eXBlcykge1xuICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodHlwZXNbaV0uaWQgIT0gaSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBpZHMgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYXJyYXkgcG9zaXRpb25zIHdoZW4gY3JlYXRpbmcgYSBub2RlIHNldFwiKTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBzZXQgd2l0aCBzb21lIG5vZGUgcHJvcGVydGllcyBhZGRlZC4gVGhlXG4gICAgLy8vIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY3JlYXRlZCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI3RyZWUuTm9kZVByb3AuYWRkKS5cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkWzBdLnNldChuZXdQcm9wcywgYWRkWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeXBlcy5wdXNoKG5ld1Byb3BzID8gbmV3IE5vZGVUeXBlKHR5cGUubmFtZSwgbmV3UHJvcHMsIHR5cGUuaWQsIHR5cGUuZmxhZ3MpIDogdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcbiAgICB9XG59XG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG4vLy8gdHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuLy8vIGNvbnZlbmllbnQgd2F5LlxuLy8vXG4vLy8gU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG4vLy8gb2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG4vLy9cbi8vLyBIb3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xuLy8vIHVzZSB0aGUgYFRyZWVDdXJzb3JgIGludGVyZmFjZSBpbnN0ZWFkLCB3aGljaCBwcm92aWRlcyBhIHZpZXcgb25cbi8vLyBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvIG1vdmUgYXJvdW5kXG4vLy8gdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlIHtcbiAgICAvLy8gQ29uc3RydWN0IGEgbmV3IHRyZWUuIFlvdSB1c3VhbGx5IHdhbnQgdG8gZ28gdGhyb3VnaFxuICAgIC8vLyBbYFRyZWUuYnVpbGRgXSgjdHJlZS5UcmVlXmJ1aWxkKSBpbnN0ZWFkLlxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIFxuICAgIC8vLyBUaGUgdHJlZSdzIGNoaWxkIG5vZGVzLiBDaGlsZHJlbiBzbWFsbCBlbm91Z2ggdG8gZml0IGluIGFcbiAgICAvLy8gYFRyZWVCdWZmZXIgd2lsbCBiZSByZXByZXNlbnRlZCBhcyBzdWNoLCBvdGhlciBjaGlsZHJlbiBjYW4gYmVcbiAgICAvLy8gZnVydGhlciBgVHJlZWAgaW5zdGFuY2VzIHdpdGggdGhlaXIgb3duIGludGVybmFsIHN0cnVjdHVyZS5cbiAgICBjaGlsZHJlbiwgXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICAvLy8gdGhlIGNoaWxkcmVuLlxuICAgIHBvc2l0aW9ucywgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ubWFwKGMgPT4gYy50b1N0cmluZygpKS5qb2luKCk7XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCN0cmVlLlRyZWVDdXJzb3IpIHJvb3RlZCBhdCB0aGlzIHRyZWUuIFdoZW5cbiAgICAvLy8gYHBvc2AgaXMgZ2l2ZW4sIHRoZSBjdXJzb3IgaXMgW21vdmVkXSgjdHJlZS5UcmVlQ3Vyc29yLm1vdmVUbylcbiAgICAvLy8gdG8gdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlLlxuICAgIGN1cnNvcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IChwb3MgIT0gbnVsbCAmJiBDYWNoZWROb2RlLmdldCh0aGlzKSkgfHwgdGhpcy50b3BOb2RlO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3Ioc2NvcGUpO1xuICAgICAgICBpZiAocG9zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIGN1cnNvci5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLy8vIEdldCBhIFt0cmVlIGN1cnNvcl0oI3RyZWUuVHJlZUN1cnNvcikgdGhhdCwgdW5saWtlIHJlZ3VsYXJcbiAgICAvLy8gY3Vyc29ycywgZG9lc24ndCBza2lwIFthbm9ueW1vdXNdKCN0cmVlLk5vZGVUeXBlLmlzQW5vbnltb3VzKVxuICAgIC8vLyBub2Rlcy5cbiAgICBmdWxsQ3Vyc29yKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcy50b3BOb2RlLCB0cnVlKTtcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI3RyZWUuU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIC8vLyB0cmVlLlxuICAgIGdldCB0b3BOb2RlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbc3ludGF4IG5vZGVdKCN0cmVlLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAvLy8gSWYgYHNpZGVgIGlzIC0xLCB0aGlzIHdpbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgZW5kIGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgLy8vIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cbiAgICAvLy8gZnJvbSBib3RoIHNpZGVzLlxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IocG9zLCBzaWRlKS5ub2RlO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgLy8vIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICAvLy8gcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIC8vLyBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vLyB3aWxsIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgaXRlcmF0ZShzcGVjKSB7XG4gICAgICAgIGxldCB7IGVudGVyLCBsZWF2ZSwgZnJvbSA9IDAsIHRvID0gdGhpcy5sZW5ndGggfSA9IHNwZWM7XG4gICAgICAgIGZvciAobGV0IGMgPSB0aGlzLmN1cnNvcigpOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjLmZyb20gPD0gdG8gJiYgYy50byA+PSBmcm9tICYmIChjLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIoYy50eXBlLCBjLmZyb20sIGMudG8pICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmICghYy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChtdXN0TGVhdmUgJiYgbGVhdmUpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGMudHlwZSwgYy5mcm9tLCBjLnRvKTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSBjLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKGMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZS5cbiAgICBiYWxhbmNlKG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IEJhbGFuY2VCcmFuY2hGYWN0b3IgPyB0aGlzXG4gICAgICAgICAgICA6IGJhbGFuY2VSYW5nZSh0aGlzLnR5cGUsIE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgbWF4QnVmZmVyTGVuZ3RoLCB0aGlzLmxlbmd0aCwgMCk7XG4gICAgfVxuICAgIC8vLyBCdWlsZCBhIHRyZWUgZnJvbSBhIHBvc3RmaXgtb3JkZXJlZCBidWZmZXIgb2Ygbm9kZSBpbmZvcm1hdGlvbixcbiAgICAvLy8gb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8vLyBUaGUgZW1wdHkgdHJlZVxuVHJlZS5lbXB0eSA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgMCk7XG4vLyBGb3IgdHJlZXMgdGhhdCBuZWVkIGEgY29udGV4dCBoYXNoIGF0dGFjaGVkLCB3ZSdyZSB1c2luZyB0aGlzXG4vLyBrbHVkZ2Ugd2hpY2ggYXNzaWducyBhbiBleHRyYSBwcm9wZXJ0eSBkaXJlY3RseSBhZnRlclxuLy8gaW5pdGlhbGl6YXRpb24gKGNyZWF0aW5nIGEgc2luZ2xlIG5ldyBvYmplY3Qgc2hhcGUpLlxuZnVuY3Rpb24gd2l0aEhhc2godHJlZSwgaGFzaCkge1xuICAgIGlmIChoYXNoKVxuICAgICAgICB0cmVlLmNvbnRleHRIYXNoID0gaGFzaDtcbiAgICByZXR1cm4gdHJlZTtcbn1cbi8vLyBUcmVlIGJ1ZmZlcnMgY29udGFpbiAodHlwZSwgc3RhcnQsIGVuZCwgZW5kSW5kZXgpIHF1YWRzIGZvciBlYWNoXG4vLy8gbm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbi8vLyBiZWZvcmUgY2hpbGRyZW4sIHdpdGggdGhlIGVuZEluZGV4IG9mIHRoZSBwYXJlbnQgaW5kaWNhdGluZyB3aGljaFxuLy8vIGNoaWxkcmVuIGJlbG9uZyB0byBpdClcbmNsYXNzIFRyZWVCdWZmZXIge1xuICAgIC8vLyBDcmVhdGUgYSB0cmVlIGJ1ZmZlciBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyLCBcbiAgICAvLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBncm91cCBvZiBub2RlcyBpbiB0aGUgYnVmZmVyLlxuICAgIGxlbmd0aCwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNldCwgdHlwZSA9IE5vZGVUeXBlLm5vbmUpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGg7KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNoaWxkU3RyaW5nKGluZGV4KSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuYnVmZmVyW2luZGV4XSwgZW5kSW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xuICAgICAgICBpZiAoL1xcVy8udGVzdChyZXN1bHQpICYmICF0eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAoZW5kSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBcIihcIiArIGNoaWxkcmVuLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgYWZ0ZXIpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLCBwaWNrID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpICE9IGVuZEluZGV4OyBpID0gYnVmZmVyW2kgKyAzXSkge1xuICAgICAgICAgICAgaWYgKGFmdGVyICE9IC0xMDAwMDAwMDAgLyogTm9uZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGJ1ZmZlcltpICsgMV0sIGVuZCA9IGJ1ZmZlcltpICsgMl07XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+PSBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG59XG5jbGFzcyBUcmVlTm9kZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgZnJvbSwgaW5kZXgsIF9wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMubm9kZS50eXBlOyB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLm5vZGUudHlwZS5uYW1lOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5ub2RlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIGFmdGVyLCBmdWxsID0gZmFsc2UpIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5ub2RlLCBlID0gZGlyID4gMCA/IGNoaWxkcmVuLmxlbmd0aCA6IC0xOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltpXSwgc3RhcnQgPSBwb3NpdGlvbnNbaV0gKyBwYXJlbnQuZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgIT0gLTEwMDAwMDAwMCAvKiBOb25lICovICYmIChkaXIgPCAwID8gc3RhcnQgPj0gYWZ0ZXIgOiBzdGFydCArIG5leHQubGVuZ3RoIDw9IGFmdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG5leHQuZmluZENoaWxkKDAsIG5leHQuYnVmZmVyLmxlbmd0aCwgZGlyLCBhZnRlciA9PSAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gPyAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gOiBhZnRlciAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUobmV3IEJ1ZmZlckNvbnRleHQocGFyZW50LCBuZXh0LCBpLCBzdGFydCksIG51bGwsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZnVsbCB8fCAoIW5leHQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gbmV3IFRyZWVOb2RlKG5leHQsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsbCB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyIDogaW5uZXIubmV4dENoaWxkKGRpciA8IDAgPyBuZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIGFmdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVsbCB8fCAhcGFyZW50LnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zKTsgfVxuICAgIG5leHRTaWduaWZpY2FudFBhcmVudCgpIHtcbiAgICAgICAgbGV0IHZhbCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh2YWwudHlwZS5pc0Fub255bW91cyAmJiB2YWwuX3BhcmVudClcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fcGFyZW50O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4ICsgMSwgMSwgLTEpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4IC0gMSwgLTEsIC0xKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBjdXJzb3IoKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzKTsgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IubW92ZVRvKHBvcywgc2lkZSkubm9kZTtcbiAgICB9XG4gICAgZ2V0Q2hpbGQodHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLm5vZGUudG9TdHJpbmcoKTsgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSwgdHlwZSwgYmVmb3JlLCBhZnRlcikge1xuICAgIGxldCBjdXIgPSBub2RlLmN1cnNvciwgcmVzdWx0ID0gW107XG4gICAgaWYgKCFjdXIuZmlyc3RDaGlsZCgpKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChiZWZvcmUgIT0gbnVsbClcbiAgICAgICAgd2hpbGUgKCFjdXIudHlwZS5pcyhiZWZvcmUpKVxuICAgICAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKGFmdGVyICE9IG51bGwgJiYgY3VyLnR5cGUuaXMoYWZ0ZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKGN1ci50eXBlLmlzKHR5cGUpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyLm5vZGUpO1xuICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgcmV0dXJuIGFmdGVyID09IG51bGwgPyByZXN1bHQgOiBbXTtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGJ1ZmZlciwgaW5kZXgsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgX3BhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSBjb250ZXh0LmJ1ZmZlci5zZXQudHlwZXNbY29udGV4dC5idWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNoaWxkKGRpciwgYWZ0ZXIpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIGFmdGVyID09IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA/IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA6IGFmdGVyIC0gdGhpcy5jb250ZXh0LnN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIHBvcyk7IH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50IHx8IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgfVxuICAgIGV4dGVybmFsU2libGluZyhkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IG51bGwgOiB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRDaGlsZCh0aGlzLmNvbnRleHQuaW5kZXggKyBkaXIsIGRpciwgLTEpO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgaWYgKGFmdGVyIDwgKHRoaXMuX3BhcmVudCA/IGJ1ZmZlci5idWZmZXJbdGhpcy5fcGFyZW50LmluZGV4ICsgM10gOiBidWZmZXIuYnVmZmVyLmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLl9wYXJlbnQsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKDEpO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuaW5kZXggKyA0IDogMDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gcGFyZW50U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoLTEpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLl9wYXJlbnQsIGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pKTtcbiAgICB9XG4gICAgZ2V0IGN1cnNvcigpIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMpOyB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKS5ub2RlO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XG4gICAgZ2V0Q2hpbGQodHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgIH1cbn1cbi8vLyBBIHRyZWUgY3Vyc29yIG9iamVjdCBmb2N1c2VzIG9uIGEgZ2l2ZW4gbm9kZSBpbiBhIHN5bnRheCB0cmVlLCBhbmRcbi8vLyBhbGxvd3MgeW91IHRvIG1vdmUgdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlQ3Vyc29yIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3Iobm9kZSwgZnVsbCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZnVsbCA9IGZ1bGw7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gbm9kZS5jb250ZXh0LnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IG5vZGUuX3BhcmVudDsgbjsgbiA9IG4uX3BhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnVuc2hpZnQobi5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gU2hvcnRoYW5kIGZvciBgLnR5cGUubmFtZWAuXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4LCBub2RlLnR5cGUpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGVudGVyKGRpciwgYWZ0ZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUubmV4dENoaWxkKGRpciA8IDAgPyB0aGlzLl90cmVlLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgYWZ0ZXIsIHRoaXMuZnVsbCkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBhZnRlciA9PSAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gPyAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gOiBhZnRlciAtIHRoaXMuYnVmZmVyLnN0YXJ0KTtcbiAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihpbmRleCk7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgLy8vIGZhbHNlLCB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIGFuZCB0aGUgY3Vyc29yIGhhcyBub3QgYmVlbiBtb3ZlZC5cbiAgICBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlcigxLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgIGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXIoLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdCBjaGlsZCB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlcigxLCBwb3MpOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIGxhc3QgY2hpbGQgdGhhdCBlbmRzIGF0IG9yIGJlZm9yZSBgcG9zYC5cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXIoLTEsIHBvcyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUodGhpcy5mdWxsID8gdGhpcy5fdHJlZS5fcGFyZW50IDogdGhpcy5fdHJlZS5wYXJlbnQpO1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zih0aGlzLnN0YWNrLnBvcCgpKTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZnVsbCA/IHRoaXMuYnVmZmVyLnBhcmVudCA6IHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUocGFyZW50KTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNpYmxpbmcoZGlyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3RyZWUuX3BhcmVudCA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5fdHJlZS5pbmRleCArIGRpciwgZGlyLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8sIHRoaXMuZnVsbCkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gZCA8IDAgPyAwIDogdGhpcy5zdGFja1tkXSArIDQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCAhPSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgLTEwMDAwMDAwMCAvKiBOb25lICovLCB0aGlzLmZ1bGwpKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBuZXh0IHNpYmxpbmcsIGlmIGFueS5cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIHByZXZpb3VzIHNpYmxpbmcsIGlmIGFueS5cbiAgICBwcmV2U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygtMSk7IH1cbiAgICBhdExhc3ROb2RlKGRpcikge1xuICAgICAgICBsZXQgaW5kZXgsIHBhcmVudCwgeyBidWZmZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCBidWZmZXIuYnVmZmVyLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmRleDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlci5idWZmZXJbaSArIDNdIDwgdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh7IGluZGV4LCBwYXJlbnQgfSA9IGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgcGFyZW50OyB7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHBhcmVudCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgZGlyLCBlID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Lm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Lm5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZnVsbCB8fCAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fCBjaGlsZCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgaGFzQ2hpbGQoY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1vdmUoZGlyKSB7XG4gICAgICAgIGlmICh0aGlzLmVudGVyKGRpciwgLTEwMDAwMDAwMCAvKiBOb25lICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWJsaW5nKGRpcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hdExhc3ROb2RlKGRpcikgfHwgIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIC8vLyBbcHJlLW9yZGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmVlX3RyYXZlcnNhbCNQcmUtb3JkZXJfKE5MUikpXG4gICAgLy8vIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICAvLy8gY3VycmVudCBub2RlIGlzIGVtcHR5LCBpdHMgbmV4dCBzaWJsaW5nIG9yIHRoZSBuZXh0IHNpYmxpbmcgb2ZcbiAgICAvLy8gdGhlIGZpcnN0IHBhcmVudCBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICBuZXh0KCkgeyByZXR1cm4gdGhpcy5tb3ZlKDEpOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhIGxhc3QtdG8tZmlyc3QgcHJlLW9yZGVyIHRyYXZlcmFsLiBBXG4gICAgLy8vIG5vZGUgaXMgZm9sbG93ZWQgYnkgaXN0IGxhc3QgY2hpbGQgb3IsIGlmIGl0IGhhcyBub25lLCBpdHNcbiAgICAvLy8gcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XG4gICAgLy8vIG5vZGUgdGhhdCBoYXMgb25lLlxuICAgIHByZXYoKSB7IHJldHVybiB0aGlzLm1vdmUoLTEpOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgLy8vIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICAvLy8gaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHNpZGUgPCAwID8gIXRoaXMuY2hpbGRCZWZvcmUocG9zKSA6ICF0aGlzLmNoaWxkQWZ0ZXIocG9zKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb20gPT0gdGhpcy50byB8fFxuICAgICAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3N5bnRheCBub2RlXSgjdHJlZS5TeW50YXhOb2RlKSBhdCB0aGUgY3Vyc29yJ3MgY3VycmVudFxuICAgIC8vLyBwb3NpdGlvbi5cbiAgICBnZXQgbm9kZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuICAgICAgICBsZXQgY2FjaGUgPSB0aGlzLmJ1ZmZlck5vZGUsIHJlc3VsdCA9IG51bGwsIGRlcHRoID0gMDtcbiAgICAgICAgaWYgKGNhY2hlICYmIGNhY2hlLmNvbnRleHQgPT0gdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIHNjYW46IGZvciAobGV0IGluZGV4ID0gdGhpcy5pbmRleCwgZCA9IHRoaXMuc3RhY2subGVuZ3RoOyBkID49IDA7KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNhY2hlOyBjOyBjID0gYy5fcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5pbmRleCA9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSBkICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuc3RhY2tbLS1kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gZGVwdGg7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5zdGFja1tpXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlck5vZGUgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgW3RyZWVdKCN0cmVlLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIC8vLyBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgLy8vIGJ1ZmZlcl0oI3RyZWUuVHJlZUJ1ZmZlcikuXG4gICAgZ2V0IHRyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IG51bGwgOiB0aGlzLl90cmVlLm5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gIWNoLnR5cGUuaXNBbm9ueW1vdXMgfHwgY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5jbGFzcyBGbGF0QnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIGdldCBwb3MoKSB7IHJldHVybiB0aGlzLmluZGV4OyB9XG4gICAgbmV4dCgpIHsgdGhpcy5pbmRleCAtPSA0OyB9XG4gICAgZm9yaygpIHsgcmV0dXJuIG5ldyBGbGF0QnVmZmVyQ3Vyc29yKHRoaXMuYnVmZmVyLCB0aGlzLmluZGV4KTsgfVxufVxuY29uc3QgQmFsYW5jZUJyYW5jaEZhY3RvciA9IDg7XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIHRvcElEID0gMCwgbWF4QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aCwgcmV1c2VkID0gW10sIG1pblJlcGVhdFR5cGUgPSBub2RlU2V0LnR5cGVzLmxlbmd0aCB9ID0gZGF0YTtcbiAgICBsZXQgY3Vyc29yID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gbmV3IEZsYXRCdWZmZXJDdXJzb3IoYnVmZmVyLCBidWZmZXIubGVuZ3RoKSA6IGJ1ZmZlcjtcbiAgICBsZXQgdHlwZXMgPSBub2RlU2V0LnR5cGVzO1xuICAgIGxldCBjb250ZXh0SGFzaCA9IDA7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PSAtMSkgeyAvLyBSZXVzZWQgbm9kZVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gocmV1c2VkW2lkXSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpZF0sIG5vZGUsIGJ1ZmZlcjtcbiAgICAgICAgaWYgKGVuZCAtIHN0YXJ0IDw9IG1heEJ1ZmZlckxlbmd0aCAmJiAoYnVmZmVyID0gZmluZEJ1ZmZlclNpemUoY3Vyc29yLnBvcyAtIG1pblBvcywgaW5SZXBlYXQpKSkge1xuICAgICAgICAgICAgLy8gU21hbGwgZW5vdWdoIGZvciBhIGJ1ZmZlciwgYW5kIG5vIHJldXNlZCBub2RlcyBpbnNpZGVcbiAgICAgICAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlci5zaXplIC0gYnVmZmVyLnNraXApO1xuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBidWZmZXIuc2l6ZSwgaW5kZXggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlci5zdGFydCwgZGF0YSwgaW5kZXgsIGluUmVwZWF0KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQsIGluUmVwZWF0IDwgMCA/IE5vZGVUeXBlLm5vbmUgOiB0eXBlc1tpblJlcGVhdF0pO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0KVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoID4gQmFsYW5jZUJyYW5jaEZhY3RvcilcbiAgICAgICAgICAgICAgICBub2RlID0gYmFsYW5jZVJhbmdlKHR5cGUsIHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCAwLCBsb2NhbENoaWxkcmVuLmxlbmd0aCwgMCwgbWF4QnVmZmVyTGVuZ3RoLCBlbmQgLSBzdGFydCwgY29udGV4dEhhc2gpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGUgPSB3aXRoSGFzaChuZXcgVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQpLCBjb250ZXh0SGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgICAgICAgICBza2lwICs9IDQ7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplLCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCwgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKGlkID09IGluUmVwZWF0KVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAoc2l6ZSA+IDQpIHtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4LCBpblJlcGVhdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkIDwgbWluUmVwZWF0VHlwZSkgeyAvLyBEb24ndCBjb3B5IHJlcGVhdCBub2RlcyBpbnRvIGJ1ZmZlcnNcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBlbmQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0IC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEpO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1t0b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VSYW5nZShvdXRlclR5cGUsIGlubmVyVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIHN0YXJ0LCBtYXhCdWZmZXJMZW5ndGgsIGxlbmd0aCwgY29udGV4dEhhc2gpIHtcbiAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgIGlmIChsZW5ndGggPD0gbWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gocG9zaXRpb25zW2ldIC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbWF4Q2hpbGQgPSBNYXRoLm1heChtYXhCdWZmZXJMZW5ndGgsIE1hdGguY2VpbChsZW5ndGggKiAxLjUgLyBCYWxhbmNlQnJhbmNoRmFjdG9yKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBGcm9tID0gaSwgZ3JvdXBTdGFydCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0RW5kID0gcG9zaXRpb25zW2ldICsgY2hpbGRyZW5baV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0RW5kIC0gZ3JvdXBTdGFydCA+IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09IGdyb3VwRnJvbSArIDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07XG4gICAgICAgICAgICAgICAgaWYgKG9ubHkgaW5zdGFuY2VvZiBUcmVlICYmIG9ubHkudHlwZSA9PSBpbm5lclR5cGUgJiYgb25seS5sZW5ndGggPiBtYXhDaGlsZCA8PCAxKSB7IC8vIFRvbyBiaWcsIGNvbGxhcHNlXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb25seS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKG9ubHkuY2hpbGRyZW5bal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChvbmx5LnBvc2l0aW9uc1tqXSArIGdyb3VwU3RhcnQgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChvbmx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGJhbGFuY2VSYW5nZShpbm5lclR5cGUsIGlubmVyVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZ3JvdXBGcm9tLCBpLCBncm91cFN0YXJ0LCBtYXhCdWZmZXJMZW5ndGgsIHBvc2l0aW9uc1tpIC0gMV0gKyBjaGlsZHJlbltpIC0gMV0ubGVuZ3RoIC0gZ3JvdXBTdGFydCwgY29udGV4dEhhc2gpO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lclR5cGUgIT0gTm9kZVR5cGUubm9uZSAmJiAhY29udGFpbnNUeXBlKGlubmVyLmNoaWxkcmVuLCBpbm5lclR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBpbm5lciA9IHdpdGhIYXNoKG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGlubmVyLmNoaWxkcmVuLCBpbm5lci5wb3NpdGlvbnMsIGlubmVyLmxlbmd0aCksIGNvbnRleHRIYXNoKTtcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goaW5uZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0IC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3aXRoSGFzaChuZXcgVHJlZShvdXRlclR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsZW5ndGgpLCBjb250ZXh0SGFzaCk7XG59XG5mdW5jdGlvbiBjb250YWluc1R5cGUobm9kZXMsIHR5cGUpIHtcbiAgICBmb3IgKGxldCBlbHQgb2Ygbm9kZXMpXG4gICAgICAgIGlmIChlbHQudHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8vIFRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbi8vLyBwYXJzaW5nXSgjbGV6ZXIuUGFyc2VPcHRpb25zLmZyYWdtZW50cykgdG8gdHJhY2sgcGFydHMgb2Ygb2xkXG4vLy8gdHJlZXMgdGhhdCBjYW4gYmUgcmV1c2VkIGluIGEgbmV3IHBhcnNlLiBBbiBhcnJheSBvZiBmcmFnbWVudHMgaXNcbi8vLyB1c2VkIHRvIHRyYWNrIHJlZ2lvbnMgb2YgYW4gb2xkIHRyZWUgd2hvc2Ugbm9kZXMgbWlnaHQgYmUgcmV1c2VkXG4vLy8gaW4gbmV3IHBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbi8vLyBbYGFwcGx5Q2hhbmdlc2BdKCN0cmVlLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0byB1cGRhdGVcbi8vLyBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgLy8vIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgLy8vIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICBmcm9tLCBcbiAgICAvLy8gVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgIHRvLCBcbiAgICAvLy8gVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgIHRyZWUsIFxuICAgIC8vLyBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICAvLy8gdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICAvLy8gZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIC8vLyBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgb2Zmc2V0LCBvcGVuKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBTdGFydCAqLykgPiAwOyB9XG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBFbmQgKi8pID4gMDsgfVxuICAgIC8vLyBBcHBseSBhIHNldCBvZiBlZGl0cyB0byBhbiBhcnJheSBvZiBmcmFnbWVudHMsIHJlbW92aW5nIG9yXG4gICAgLy8vIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICAvLy8gYWRqdXN0aW5nIG9mZnNldHMgZm9yIGZyYWdtZW50cyB0aGF0IG1vdmVkLlxuICAgIHN0YXRpYyBhcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBjaGFuZ2VzLCBtaW5HYXAgPSAxMjgpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGZJID0gMSwgbmV4dEYgPSBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgbGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRDID0gY0kgPCBjaGFuZ2VzLmxlbmd0aCA/IGNoYW5nZXNbY0krK10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIChjSSA+IDAgPyAxIC8qIFN0YXJ0ICovIDogMCkgfCAobmV4dEMgPyAyIC8qIEVuZCAqLyA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRGLnRvID4gbmV4dFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBuZXh0RiA9IGZJIDwgZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1tmSSsrXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0QylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHRDLnRvQTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRDLnRvQSAtIG5leHRDLnRvQjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgc2V0IG9mIGZyYWdtZW50cyBmcm9tIGEgZnJlc2hseSBwYXJzZWQgdHJlZSwgb3IgdXBkYXRlXG4gICAgLy8vIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIC8vLyB3aXRoIGEgdHJlZSB3aXRoIGNvbnRlbnQgZnJvbSB0aGUgbmV3IHRyZWUuIFdoZW4gYHBhcnRpYWxgIGlzXG4gICAgLy8vIHRydWUsIHRoZSBwYXJzZSBpcyB0cmVhdGVkIGFzIGluY29tcGxldGUsIGFuZCB0aGUgdG9rZW4gYXQgaXRzXG4gICAgLy8vIGVuZCBpcyBub3QgaW5jbHVkZWQgaW4gW2BzYWZlVG9gXSgjdHJlZS5UcmVlRnJhZ21lbnQuc2FmZVRvKS5cbiAgICBzdGF0aWMgYWRkVHJlZSh0cmVlLCBmcmFnbWVudHMgPSBbXSwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbbmV3IFRyZWVGcmFnbWVudCgwLCB0cmVlLmxlbmd0aCwgdHJlZSwgMCwgcGFydGlhbCA/IDIgLyogRW5kICovIDogMCldO1xuICAgICAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cylcbiAgICAgICAgICAgIGlmIChmLnRvID4gdHJlZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8gQ3JlYXRlcyBhbiBgSW5wdXRgIHRoYXQgaXMgYmFja2VkIGJ5IGEgc2luZ2xlLCBmbGF0IHN0cmluZy5cbmZ1bmN0aW9uIHN0cmluZ0lucHV0KGlucHV0KSB7IHJldHVybiBuZXcgU3RyaW5nSW5wdXQoaW5wdXQpOyB9XG5jbGFzcyBTdHJpbmdJbnB1dCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgZ2V0KHBvcykge1xuICAgICAgICByZXR1cm4gcG9zIDwgMCB8fCBwb3MgPj0gdGhpcy5sZW5ndGggPyAtMSA6IHRoaXMuc3RyaW5nLmNoYXJDb2RlQXQocG9zKTtcbiAgICB9XG4gICAgbGluZUFmdGVyKHBvcykge1xuICAgICAgICBpZiAocG9zIDwgMClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihcIlxcblwiLCBwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBlbmQgPCAwID8gdGhpcy5sZW5ndGggOiBNYXRoLm1pbihlbmQsIHRoaXMubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykpOyB9XG4gICAgY2xpcChhdCkgeyByZXR1cm4gbmV3IFN0cmluZ0lucHV0KHRoaXMuc3RyaW5nLCBhdCk7IH1cbn1cblxuZXhwb3J0cy5EZWZhdWx0QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aDtcbmV4cG9ydHMuTm9kZVByb3AgPSBOb2RlUHJvcDtcbmV4cG9ydHMuTm9kZVNldCA9IE5vZGVTZXQ7XG5leHBvcnRzLk5vZGVUeXBlID0gTm9kZVR5cGU7XG5leHBvcnRzLlRyZWUgPSBUcmVlO1xuZXhwb3J0cy5UcmVlQnVmZmVyID0gVHJlZUJ1ZmZlcjtcbmV4cG9ydHMuVHJlZUN1cnNvciA9IFRyZWVDdXJzb3I7XG5leHBvcnRzLlRyZWVGcmFnbWVudCA9IFRyZWVGcmFnbWVudDtcbmV4cG9ydHMuc3RyaW5nSW5wdXQgPSBzdHJpbmdJbnB1dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyZWUuY2pzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbGV6ZXJUcmVlID0gcmVxdWlyZSgnbGV6ZXItdHJlZScpO1xuXG4vLy8gQSBwYXJzZSBzdGFjay4gVGhlc2UgYXJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgcGFyc2VyIHRvIHRyYWNrXG4vLy8gcGFyc2luZyBwcm9ncmVzcy4gVGhleSBhbHNvIHByb3ZpZGUgc29tZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXG4vLy8gdGhhdCBleHRlcm5hbCBjb2RlIHN1Y2ggYXMgYSB0b2tlbml6ZXIgY2FuIHVzZSB0byBnZXQgaW5mb3JtYXRpb25cbi8vLyBhYm91dCB0aGUgcGFyc2Ugc3RhdGUuXG5jbGFzcyBTdGFjayB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBBIHRoZSBwYXJzZSB0aGF0IHRoaXMgc3RhY2sgaXMgcGFydCBvZiBAaW50ZXJuYWxcbiAgICBwLCBcbiAgICAvLy8gSG9sZHMgc3RhdGUsIHBvcywgdmFsdWUgc3RhY2sgcG9zICgxNSBiaXRzIGFycmF5IGluZGV4LCAxNSBiaXRzXG4gICAgLy8vIGJ1ZmZlciBpbmRleCkgdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlIHRvcCBzdGF0ZVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGFjaywgXG4gICAgLy8vIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgIHN0YXRlLCBcbiAgICAvLyBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIG5leHQgcmVkdWNlIHNob3VsZCB0YWtlIHBsYWNlLiBUaGlzXG4gICAgLy8gY2FuIGJlIGxlc3MgdGhhbiBgdGhpcy5wb3NgIHdoZW4gc2tpcHBlZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgc3RhY2sgKHdoaWNoIHNob3VsZCBiZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBuZXh0XG4gICAgLy8gcmVkdWN0aW9uKVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2VQb3MsIFxuICAgIC8vLyBUaGUgaW5wdXQgcG9zaXRpb24gdXAgdG8gd2hpY2ggdGhpcyBzdGFjayBoYXMgcGFyc2VkLlxuICAgIHBvcywgXG4gICAgLy8vIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIC8vLyBhbmQgZXJyb3ItcmVjb3ZlcnkgcGVuYWx0aWVzXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyQmFzZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGN1ckNvbnRleHQsIFxuICAgIC8vIEEgcGFyZW50IHN0YWNrIGZyb20gd2hpY2ggdGhpcyB3YXMgc3BsaXQgb2ZmLCBpZiBhbnkuIFRoaXMgaXNcbiAgICAvLyBzZXQgdXAgc28gdGhhdCBpdCBhbHdheXMgcG9pbnRzIHRvIGEgc3RhY2sgdGhhdCBoYXMgc29tZVxuICAgIC8vIGFkZGl0aW9uYWwgYnVmZmVyIGNvbnRlbnQsIG5ldmVyIHRvIGEgc3RhY2sgd2l0aCBhbiBlcXVhbFxuICAgIC8vIGBidWZmZXJCYXNlYC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcGFyZW50KSB7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHJlZHVjZVBvcztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuYnVmZmVyQmFzZSA9IGJ1ZmZlckJhc2U7XG4gICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IGN1ckNvbnRleHQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5zdGFjay5maWx0ZXIoKF8sIGkpID0+IGkgJSAzID09IDApLmNvbmNhdCh0aGlzLnN0YXRlKX1dQCR7dGhpcy5wb3N9JHt0aGlzLnNjb3JlID8gXCIhXCIgKyB0aGlzLnNjb3JlIDogXCJcIn1gO1xuICAgIH1cbiAgICAvLyBTdGFydCBhbiBlbXB0eSBzdGFja1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0aWMgc3RhcnQocCwgc3RhdGUsIHBvcyA9IDApIHtcbiAgICAgICAgbGV0IGN4ID0gcC5wYXJzZXIuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayhwLCBbXSwgc3RhdGUsIHBvcywgcG9zLCAwLCBbXSwgMCwgY3ggPyBuZXcgU3RhY2tDb250ZXh0KGN4LCBjeC5zdGFydCkgOiBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgLy8vIFRoZSBzdGFjaydzIGN1cnJlbnQgW2NvbnRleHRdKCNsZXplci5Db250ZXh0VHJhY2tlcikgdmFsdWUsIGlmXG4gICAgLy8vIGFueS4gSXRzIHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIGNvbnRleHQgdHJhY2tlcidzIHR5cGVcbiAgICAvLy8gcGFyYW1ldGVyLCBvciBpdCB3aWxsIGJlIGBudWxsYCBpZiB0aGVyZSBpcyBubyBjb250ZXh0XG4gICAgLy8vIHRyYWNrZXIuXG4gICAgZ2V0IGNvbnRleHQoKSB7IHJldHVybiB0aGlzLmN1ckNvbnRleHQgPyB0aGlzLmN1ckNvbnRleHQuY29udGV4dCA6IG51bGw7IH1cbiAgICAvLyBQdXNoIGEgc3RhdGUgb250byB0aGUgc3RhY2ssIHRyYWNraW5nIGl0cyBzdGFydCBwb3NpdGlvbiBhcyB3ZWxsXG4gICAgLy8gYXMgdGhlIGJ1ZmZlciBiYXNlIGF0IHRoYXQgcG9pbnQuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHB1c2hTdGF0ZShzdGF0ZSwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIHN0YXJ0LCB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgcmVkdWNlIGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovLCB0eXBlID0gYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgbGV0IGRQcmVjID0gcGFyc2VyLmR5bmFtaWNQcmVjZWRlbmNlKHR5cGUpO1xuICAgICAgICBpZiAoZFByZWMpXG4gICAgICAgICAgICB0aGlzLnNjb3JlICs9IGRQcmVjO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhdGUsIHR5cGUsIHRydWUpLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLyA/IDYgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFja1tiYXNlIC0gMl07XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gdGhpcy5zdGFja1tiYXNlIC0gMV0sIGNvdW50ID0gdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoIC0gYnVmZmVyQmFzZTtcbiAgICAgICAgLy8gU3RvcmUgbm9ybWFsIHRlcm1zIG9yIGBSIC0+IFIgUmAgcmVwZWF0IHJlZHVjdGlvbnNcbiAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSB8fCAoYWN0aW9uICYgMTMxMDcyIC8qIFJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmFzZVN0YXRlSUQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAzXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJzZXIuZ2V0R290byhiYXNlU3RhdGVJRCwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gYmFzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlKTtcbiAgICB9XG4gICAgLy8gU2hpZnQgYSB2YWx1ZSBpbnRvIHRoZSBidWZmZXJcbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RvcmVOb2RlKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUgPSA0LCBpc1JlZHVjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0ZXJtID09IDAgLyogRXJyICovKSB7IC8vIFRyeSB0byBvbWl0L21lcmdlIGFkamFjZW50IGVycm9yIG5vZGVzXG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcywgdG9wID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvcCA9PSAwICYmIGN1ci5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBjdXIuYnVmZmVyQmFzZSAtIGN1ci5wYXJlbnQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCA+IDAgJiYgY3VyLmJ1ZmZlclt0b3AgLSA0XSA9PSAwIC8qIEVyciAqLyAmJiBjdXIuYnVmZmVyW3RvcCAtIDFdID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5idWZmZXJbdG9wIC0gMl0gPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLmJ1ZmZlclt0b3AgLSAyXSA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUmVkdWNlIHx8IHRoaXMucG9zID09IGVuZCkgeyAvLyBTaW1wbGUgY2FzZSwganVzdCBhcHBlbmRcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGVybSwgc3RhcnQsIGVuZCwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFRoZXJlIG1heSBiZSBza2lwcGVkIG5vZGVzIHRoYXQgaGF2ZSB0byBiZSBtb3ZlZCBmb3J3YXJkXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gNF0gIT0gMCAvKiBFcnIgKi8pXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhpcyByZWNvcmQgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gdGhpcy5idWZmZXJbaW5kZXggLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAtPSA0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplIC09IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGVybTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhIHNoaWZ0IGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaGlmdChhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDEzMTA3MiAvKiBHb3RvRmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUoYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykgPT0gMCkgeyAvLyBSZWd1bGFyIHNoaWZ0XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcywgbmV4dFN0YXRlID0gYWN0aW9uLCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICAgICAgaWYgKG5leHRFbmQgPiB0aGlzLnBvcyB8fCBuZXh0IDw9IHBhcnNlci5tYXhOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VyLnN0YXRlRmxhZyhuZXh0U3RhdGUsIDEgLyogU2tpcHBlZCAqLykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHRTdGF0ZSwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKG5leHQgPD0gcGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCBzdGFydCwgbmV4dEVuZCwgNCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICBpZiAobmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCB0aGlzLnBvcywgbmV4dEVuZCwgNCk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGFwcGx5KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLylcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgbm9kZSBpbnRvIHRoZSBidWZmZXIuIFRoaXMgbWF5IGJlIGEgcmV1c2VkIG5vZGUgb3JcbiAgICAvLyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgYSBuZXN0ZWQgcGFyc2VyLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB1c2VOb2RlKHZhbHVlLCBuZXh0KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMucC5yZXVzZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLnAucmV1c2VkW2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wLnJldXNlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3MgPSBzdGFydCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dCwgc3RhcnQpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGluZGV4LCBzdGFydCwgdGhpcy5yZWR1Y2VQb3MsIC0xIC8qIHNpemUgPCAwIG1lYW5zIHRoaXMgaXMgYSByZXVzZWQgdmFsdWUgKi8pO1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJldXNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB2YWx1ZSwgdGhpcy5wLmlucHV0LCB0aGlzKSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IHRoZSBzdGFjay4gRHVlIHRvIHRoZSBidWZmZXIgc2hhcmluZyBhbmQgdGhlIGZhY3RcbiAgICAvLyB0aGF0IGB0aGlzLnN0YWNrYCB0ZW5kcyB0byBzdGF5IHF1aXRlIHNoYWxsb3csIHRoaXMgaXNuJ3QgdmVyeVxuICAgIC8vIGV4cGVuc2l2ZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgb2ZmID0gcGFyZW50LmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHRvcCBvZiB0aGUgYnVmZmVyIChhZnRlciB0aGlzLnBvcykgbWF5IGJlIG11dGF0ZWRcbiAgICAgICAgLy8gdG8gcmVvcmRlciByZWR1Y3Rpb25zIGFuZCBza2lwcGVkIHRva2VucywgYW5kIHNoYXJlZCBidWZmZXJzXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbW11dGFibGUsIHRoaXMgY29waWVzIGFueSBvdXRzdGFuZGluZyBza2lwcGVkIHRva2Vuc1xuICAgICAgICAvLyB0byB0aGUgbmV3IGJ1ZmZlciwgYW5kIHB1dHMgdGhlIGJhc2UgcG9pbnRlciBiZWZvcmUgdGhlbS5cbiAgICAgICAgd2hpbGUgKG9mZiA+IDAgJiYgcGFyZW50LmJ1ZmZlcltvZmYgLSAyXSA+IHBhcmVudC5yZWR1Y2VQb3MpXG4gICAgICAgICAgICBvZmYgLT0gNDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHBhcmVudC5idWZmZXIuc2xpY2Uob2ZmKSwgYmFzZSA9IHBhcmVudC5idWZmZXJCYXNlICsgb2ZmO1xuICAgICAgICAvLyBNYWtlIHN1cmUgcGFyZW50IHBvaW50cyB0byBhbiBhY3R1YWwgcGFyZW50IHdpdGggY29udGVudCwgaWYgdGhlcmUgaXMgc3VjaCBhIHBhcmVudC5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBiYXNlID09IHBhcmVudC5idWZmZXJCYXNlKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayh0aGlzLnAsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHRoaXMuY3VyQ29udGV4dCwgcGFyZW50KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHJlY292ZXIgZnJvbSBhbiBlcnJvciBieSAnZGVsZXRpbmcnIChpZ25vcmluZykgb25lIHRva2VuLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlEZWxldGUobmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBsZXQgaXNOb2RlID0gbmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGU7XG4gICAgICAgIGlmIChpc05vZGUpXG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZShuZXh0LCB0aGlzLnBvcywgbmV4dEVuZCk7XG4gICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogRXJyICovLCB0aGlzLnBvcywgbmV4dEVuZCwgaXNOb2RlID8gOCA6IDQpO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgdGhpcy5zY29yZSAtPSAyMDAgLyogVG9rZW4gKi87XG4gICAgfVxuICAgIC8vLyBDaGVjayBpZiB0aGUgZ2l2ZW4gdGVybSB3b3VsZCBiZSBhYmxlIHRvIGJlIHNoaWZ0ZWQgKG9wdGlvbmFsbHlcbiAgICAvLy8gYWZ0ZXIgc29tZSByZWR1Y3Rpb25zKSBvbiB0aGlzIHN0YWNrLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXG4gICAgLy8vIGV4dGVybmFsIHRva2VuaXplcnMgdGhhdCB3YW50IHRvIG1ha2Ugc3VyZSB0aGV5IG9ubHkgcHJvdmlkZSBhXG4gICAgLy8vIGdpdmVuIHRva2VuIHdoZW4gaXQgYXBwbGllcy5cbiAgICBjYW5TaGlmdCh0ZXJtKSB7XG4gICAgICAgIGZvciAobGV0IHNpbSA9IG5ldyBTaW11bGF0ZWRTdGFjayh0aGlzKTs7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3Qoc2ltLnRvcCwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSB8fCB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzaW0udG9wLCB0ZXJtKTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEZpbmQgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBydWxlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHBhcnNlZC5cbiAgICBnZXQgcnVsZVN0YXJ0KCkge1xuICAgICAgICBmb3IgKGxldCBzdGF0ZSA9IHRoaXMuc3RhdGUsIGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDs7KSB7XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdChzdGF0ZSwgNSAvKiBGb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICAgICAgaWYgKCEoZm9yY2UgJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGJhc2UgLT0gMyAqIChmb3JjZSA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovKTtcbiAgICAgICAgICAgIGlmICgoZm9yY2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pIDwgdGhpcy5wLnBhcnNlci5taW5SZXBlYXRUZXJtKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrW2Jhc2UgKyAxXTtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGFja1tiYXNlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gRmluZCB0aGUgc3RhcnQgcG9zaXRpb24gb2YgYW4gaW5zdGFuY2Ugb2YgYW55IG9mIHRoZSBnaXZlbiB0ZXJtXG4gICAgLy8vIHR5cGVzLCBvciByZXR1cm4gYG51bGxgIHdoZW4gbm9uZSBvZiB0aGVtIGFyZSBmb3VuZC5cbiAgICAvLy9cbiAgICAvLy8gKipOb3RlOioqIHRoaXMgaXMgb25seSByZWxpYWJsZSB3aGVuIHRoZXJlIGlzIGF0IGxlYXN0IHNvbWVcbiAgICAvLy8gc3RhdGUgdGhhdCB1bmFtYmlndW91c2x5IG1hdGNoZXMgdGhlIGdpdmVuIHJ1bGUgb24gdGhlIHN0YWNrLlxuICAgIC8vLyBJLmUuIGlmIHlvdSBoYXZlIGEgZ3JhbW1hciBsaWtlIHRoaXMsIHdoZXJlIHRoZSBkaWZmZXJlbmNlXG4gICAgLy8vIGJldHdlZW4gYGFgIGFuZCBgYmAgaXMgb25seSBhcHBhcmVudCBhdCB0aGUgdGhpcmQgdG9rZW46XG4gICAgLy8vXG4gICAgLy8vICAgICBhIHsgYiB8IGMgfVxuICAgIC8vLyAgICAgYiB7IFwieFwiIFwieVwiIFwieFwiIH1cbiAgICAvLy8gICAgIGMgeyBcInhcIiBcInlcIiBcInpcIiB9XG4gICAgLy8vXG4gICAgLy8vIFRoZW4gYSBwYXJzZSBzdGF0ZSBhZnRlciBgXCJ4XCJgIHdpbGwgbm90IHJlbGlhYmx5IHRlbGwgeW91IHRoYXRcbiAgICAvLy8gYGJgIGlzIG9uIHRoZSBzdGFjay4gWW91IF9jYW5fIHBhc3MgYFtiLCBjXWAgdG8gcmVsaWFibHkgY2hlY2tcbiAgICAvLy8gZm9yIGVpdGhlciBvZiB0aG9zZSB0d28gcnVsZXMgKGFzc3VtaW5nIHRoYXQgYGFgIGlzbid0IHBhcnQgb2ZcbiAgICAvLy8gc29tZSBydWxlIHRoYXQgaW5jbHVkZXMgb3RoZXIgdGhpbmdzIHN0YXJ0aW5nIHdpdGggYFwieFwiYCkuXG4gICAgLy8vXG4gICAgLy8vIFdoZW4gYGJlZm9yZWAgaXMgZ2l2ZW4sIHRoaXMga2VlcHMgc2Nhbm5pbmcgdXAgdGhlIHN0YWNrIHVudGlsXG4gICAgLy8vIGl0IGZpbmRzIGEgbWF0Y2ggdGhhdCBzdGFydHMgYmVmb3JlIHRoYXQgcG9zaXRpb24uXG4gICAgLy8vXG4gICAgLy8vIE5vdGUgdGhhdCB5b3UgaGF2ZSB0byBiZSBjYXJlZnVsIHdoZW4gdXNpbmcgdGhpcyBpbiB0b2tlbml6ZXJzLFxuICAgIC8vLyBzaW5jZSBpdCdzIHJlbGF0aXZlbHkgZWFzeSB0byBpbnRyb2R1Y2UgZGF0YSBkZXBlbmRlbmNpZXMgdGhhdFxuICAgIC8vLyBicmVhayBpbmNyZW1lbnRhbCBwYXJzaW5nIGJ5IHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgIHN0YXJ0T2YodHlwZXMsIGJlZm9yZSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlLCBmcmFtZSA9IHRoaXMuc3RhY2subGVuZ3RoLCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YXRlLCA1IC8qIEZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSBmb3JjZSA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovLCB0ZXJtID0gZm9yY2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5kZXhPZih0ZXJtKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBmcmFtZSAtICgzICogKGZvcmNlID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8pKSwgcG9zID0gdGhpcy5zdGFja1tiYXNlICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA9PSBudWxsIHx8IGJlZm9yZSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFtZSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgICAgICBmcmFtZSAtPSAzO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGFja1tmcmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFtZSAtPSAzICogKGRlcHRoIC0gMSk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW2ZyYW1lIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IHVwIHRvIFJlY292ZXIuTWF4TmV4dCByZWNvdmVyeSBhY3Rpb25zIHRoYXQgY29uY2VwdHVhbGx5XG4gICAgLy8gaW5zZXJ0cyBzb21lIG1pc3NpbmcgdG9rZW4gb3IgcnVsZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5SW5zZXJ0KG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID49IDMwMCAvKiBNYXhJbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXRlcyA9IHRoaXMucC5wYXJzZXIubmV4dFN0YXRlcyh0aGlzLnN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRTdGF0ZXMubGVuZ3RoID4gNCAvKiBNYXhOZXh0ICovIDw8IDEgfHwgdGhpcy5zdGFjay5sZW5ndGggPj0gMTIwIC8qIERhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pIHtcbiAgICAgICAgICAgIGxldCBiZXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgczsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHMgPSBuZXh0U3RhdGVzW2kgKyAxXSkgIT0gdGhpcy5zdGF0ZSAmJiB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzLCBuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMTIwIC8qIERhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGJlc3QubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovIDw8IDEgJiYgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZXN0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSBzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0U3RhdGVzID0gYmVzdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IDQgLyogTWF4TmV4dCAqLzsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHMgPT0gdGhpcy5zdGF0ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIHN0YWNrLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgc3RhY2sucG9zLCBzdGFjay5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgc3RhY2sucHVzaFN0YXRlKHMsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnNoaWZ0Q29udGV4dChuZXh0U3RhdGVzW2ldKTtcbiAgICAgICAgICAgIHN0YWNrLnNjb3JlIC09IDIwMCAvKiBUb2tlbiAqLztcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGb3JjZSBhIHJlZHVjZSwgaWYgcG9zc2libGUuIFJldHVybiBmYWxzZSBpZiB0aGF0IGNhbid0XG4gICAgLy8gYmUgZG9uZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yY2VSZWR1Y2UoKSB7XG4gICAgICAgIGxldCByZWR1Y2UgPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA1IC8qIEZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgIGlmICgocmVkdWNlICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLnAucGFyc2VyLnZhbGlkQWN0aW9uKHRoaXMuc3RhdGUsIHJlZHVjZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogRXJyICovLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY29yZSAtPSAxMDAgLyogUmVkdWNlICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkdWNlKHJlZHVjZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yY2VBbGwoKSB7XG4gICAgICAgIHdoaWxlICghdGhpcy5wLnBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMiAvKiBBY2NlcHRpbmcgKi8pICYmIHRoaXMuZm9yY2VSZWR1Y2UoKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGhhcyBubyBmdXJ0aGVyIGFjdGlvbnMgKGFzc3VtZWQgdG8gYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGVcbiAgICAvLy8gdG9wIHN0YXRlLCBzaW5jZSBhbnkgb3RoZXIgc3RhdGVzIG11c3QgYmUgYWJsZSB0byBjb250aW51ZVxuICAgIC8vLyBzb21laG93KS4gQGludGVybmFsXG4gICAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5kYXRhW3BhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgMSAvKiBBY3Rpb25zICovKV0gPT0gNjU1MzUgLyogRW5kICovICYmXG4gICAgICAgICAgICAhcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pO1xuICAgIH1cbiAgICAvLy8gUmVzdGFydCB0aGUgc3RhY2sgKHB1dCBpdCBiYWNrIGluIGl0cyBzdGFydCBzdGF0ZSkuIE9ubHkgc2FmZVxuICAgIC8vLyB3aGVuIHRoaXMuc3RhY2subGVuZ3RoID09IDMgKHN0YXRlIGlzIGRpcmVjdGx5IGJlbG93IHRoZSB0b3BcbiAgICAvLy8gc3RhdGUpLiBAaW50ZXJuYWxcbiAgICByZXN0YXJ0KCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1swXTtcbiAgICAgICAgdGhpcy5zdGFjay5sZW5ndGggPSAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2FtZVN0YXRlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9IG90aGVyLnN0YXRlIHx8IHRoaXMuc3RhY2subGVuZ3RoICE9IG90aGVyLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tbaV0gIT0gb3RoZXIuc3RhY2tbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgcGFyc2VyIHVzZWQgYnkgdGhpcyBzdGFjay5cbiAgICBnZXQgcGFyc2VyKCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlcjsgfVxuICAgIC8vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBkaWFsZWN0IChieSBudW1lcmljIElELCBhcyBleHBvcnRlZCBmcm9tXG4gICAgLy8vIHRoZSB0ZXJtcyBmaWxlKSBpcyBlbmFibGVkLlxuICAgIGRpYWxlY3RFbmFibGVkKGRpYWxlY3RJRCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlci5kaWFsZWN0LmZsYWdzW2RpYWxlY3RJRF07IH1cbiAgICBzaGlmdENvbnRleHQodGVybSkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnNoaWZ0KHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLnAuaW5wdXQsIHRoaXMpKTtcbiAgICB9XG4gICAgcmVkdWNlQ29udGV4dCh0ZXJtKSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmVkdWNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB0ZXJtLCB0aGlzLnAuaW5wdXQsIHRoaXMpKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGVtaXRDb250ZXh0KCkge1xuICAgICAgICBsZXQgY3ggPSB0aGlzLmN1ckNvbnRleHQ7XG4gICAgICAgIGlmICghY3gudHJhY2tlci5zdHJpY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC0yKVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChjeC5oYXNoLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIC0yKTtcbiAgICB9XG4gICAgdXBkYXRlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ICE9IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgbmV3Q3ggPSBuZXcgU3RhY2tDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChuZXdDeC5oYXNoICE9IHRoaXMuY3VyQ29udGV4dC5oYXNoKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IG5ld0N4O1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RhY2tDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFja2VyLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHJhY2tlciA9IHRyYWNrZXI7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaGFzaCA9IHRyYWNrZXIuaGFzaChjb250ZXh0KTtcbiAgICB9XG59XG52YXIgUmVjb3ZlcjtcbihmdW5jdGlvbiAoUmVjb3Zlcikge1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIlRva2VuXCJdID0gMjAwXSA9IFwiVG9rZW5cIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJSZWR1Y2VcIl0gPSAxMDBdID0gXCJSZWR1Y2VcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhOZXh0XCJdID0gNF0gPSBcIk1heE5leHRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhJbnNlcnRTdGFja0RlcHRoXCJdID0gMzAwXSA9IFwiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIl0gPSAxMjBdID0gXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCI7XG59KShSZWNvdmVyIHx8IChSZWNvdmVyID0ge30pKTtcbi8vIFVzZWQgdG8gY2hlYXBseSBydW4gc29tZSByZWR1Y3Rpb25zIHRvIHNjYW4gYWhlYWQgd2l0aG91dCBtdXRhdGluZ1xuLy8gYW4gZW50aXJlIHN0YWNrXG5jbGFzcyBTaW11bGF0ZWRTdGFjayB7XG4gICAgY29uc3RydWN0b3Ioc3RhY2spIHtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnRvcCA9IHN0YWNrLnN0YXRlO1xuICAgICAgICB0aGlzLnJlc3QgPSBzdGFjay5zdGFjaztcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLnJlc3QubGVuZ3RoO1xuICAgIH1cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovLCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdCA9PSB0aGlzLnN0YWNrLnN0YWNrKVxuICAgICAgICAgICAgICAgIHRoaXMucmVzdCA9IHRoaXMucmVzdC5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXN0LnB1c2godGhpcy50b3AsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0IC09IChkZXB0aCAtIDEpICogMztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ290byA9IHRoaXMuc3RhY2sucC5wYXJzZXIuZ2V0R290byh0aGlzLnJlc3RbdGhpcy5vZmZzZXQgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMudG9wID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaykge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHN0YWNrLCBzdGFjay5idWZmZXJCYXNlICsgc3RhY2suYnVmZmVyLmxlbmd0aCwgc3RhY2suYnVmZmVyLmxlbmd0aCk7XG4gICAgfVxuICAgIG1heWJlTmV4dCgpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLnN0YWNrLnBhcmVudDtcbiAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2suYnVmZmVyQmFzZSAtIG5leHQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBuZXh0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXh0LmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLmluZGV4IC09IDQ7XG4gICAgICAgIHRoaXMucG9zIC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBmb3JrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHRoaXMuc3RhY2ssIHRoaXMucG9zLCB0aGlzLmluZGV4KTtcbiAgICB9XG59XG5cbi8vLyBUb2tlbml6ZXJzIHdyaXRlIHRoZSB0b2tlbnMgdGhleSByZWFkIGludG8gaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuXG5jbGFzcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHRva2VuLiBUaGlzIGlzIHNldCBieSB0aGUgcGFyc2VyLCBhbmQgc2hvdWxkIG5vdFxuICAgICAgICAvLy8gYmUgbXV0YXRlZCBieSB0aGUgdG9rZW5pemVyLlxuICAgICAgICB0aGlzLnN0YXJ0ID0gLTE7XG4gICAgICAgIC8vLyBUaGlzIHN0YXJ0cyBhdCAtMSwgYW5kIHNob3VsZCBiZSB1cGRhdGVkIHRvIGEgdGVybSBpZCB3aGVuIGFcbiAgICAgICAgLy8vIG1hdGNoaW5nIHRva2VuIGlzIGZvdW5kLlxuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIC8vLyBXaGVuIHNldHRpbmcgYC52YWx1ZWAsIHlvdSBzaG91bGQgYWxzbyBzZXQgYC5lbmRgIHRvIHRoZSBlbmRcbiAgICAgICAgLy8vIHBvc2l0aW9uIG9mIHRoZSB0b2tlbi4gKFlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gdXNlIHRoZSBgYWNjZXB0YFxuICAgICAgICAvLy8gbWV0aG9kLilcbiAgICAgICAgdGhpcy5lbmQgPSAtMTtcbiAgICB9XG4gICAgLy8vIEFjY2VwdCBhIHRva2VuLCBzZXR0aW5nIGB2YWx1ZWAgYW5kIGBlbmRgIHRvIHRoZSBnaXZlbiB2YWx1ZXMuXG4gICAgYWNjZXB0KHZhbHVlLCBlbmQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG59XG4vLy8gQGludGVybmFsXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCB0b2tlbiwgc3RhY2spIHsgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHRva2VuLCBzdGFjaywgdGhpcy5pZCk7IH1cbn1cblRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLy8vIEV4cG9ydHMgdGhhdCBhcmUgdXNlZCBmb3IgYEBleHRlcm5hbCB0b2tlbnNgIGluIHRoZSBncmFtbWFyIHNob3VsZFxuLy8vIGV4cG9ydCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuY2xhc3MgRXh0ZXJuYWxUb2tlbml6ZXIge1xuICAgIC8vLyBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICAvLy8gZ2l2ZW4gYW4gaW5wdXQgc3RyZWFtIGFuZCBhIHRva2VuIG9iamVjdCxcbiAgICAvLy8gW2ZpbGxzXSgjbGV6ZXIuVG9rZW4uYWNjZXB0KSB0aGUgdG9rZW4gb2JqZWN0IGlmIGl0IHJlY29nbml6ZXMgYVxuICAgIC8vLyB0b2tlbi4gYHRva2VuLnN0YXJ0YCBzaG91bGQgYmUgdXNlZCBhcyB0aGUgc3RhcnQgcG9zaXRpb24gdG9cbiAgICAvLy8gc2NhbiBmcm9tLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b2tlbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5jb250ZXh0dWFsID0gISFvcHRpb25zLmNvbnRleHR1YWw7XG4gICAgICAgIHRoaXMuZmFsbGJhY2sgPSAhIW9wdGlvbnMuZmFsbGJhY2s7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gISFvcHRpb25zLmV4dGVuZDtcbiAgICB9XG59XG4vLyBUb2tlbml6ZXIgZGF0YSBpcyBzdG9yZWQgYSBiaWcgdWludDE2IGFycmF5IGNvbnRhaW5pbmcsIGZvciBlYWNoXG4vLyBzdGF0ZTpcbi8vXG4vLyAgLSBBIGdyb3VwIGJpdG1hc2ssIGluZGljYXRpbmcgd2hhdCB0b2tlbiBncm91cHMgYXJlIHJlYWNoYWJsZSBmcm9tXG4vLyAgICB0aGlzIHN0YXRlLCBzbyB0aGF0IHBhdGhzIHRoYXQgY2FuIG9ubHkgbGVhZCB0byB0b2tlbnMgbm90IGluXG4vLyAgICBhbnkgb2YgdGhlIGN1cnJlbnQgZ3JvdXBzIGNhbiBiZSBjdXQgb2ZmIGVhcmx5LlxuLy9cbi8vICAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIHRoZSBzdGF0ZSdzIHNlcXVlbmNlIG9mIGFjY2VwdGluZ1xuLy8gICAgdG9rZW5zXG4vL1xuLy8gIC0gVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyBmb3IgdGhlIHN0YXRlXG4vL1xuLy8gIC0gVGhlIGFjY2VwdGluZyB0b2tlbnMsIGFzICh0b2tlbiBpZCwgZ3JvdXAgbWFzaykgcGFpcnNcbi8vXG4vLyAgLSBUaGUgb3V0Z29pbmcgZWRnZXMsIGFzIChzdGFydCBjaGFyYWN0ZXIsIGVuZCBjaGFyYWN0ZXIsIHN0YXRlXG4vLyAgICBpbmRleCkgdHJpcGxlcywgd2l0aCBlbmQgY2hhcmFjdGVyIGJlaW5nIGV4Y2x1c2l2ZVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gaW50ZXJwcmV0cyB0aGF0IGRhdGEsIHJ1bm5pbmcgdGhyb3VnaCBhIHN0cmVhbSBhc1xuLy8gbG9uZyBhcyBuZXcgc3RhdGVzIHdpdGggdGhlIGEgbWF0Y2hpbmcgZ3JvdXAgbWFzayBjYW4gYmUgcmVhY2hlZCxcbi8vIGFuZCB1cGRhdGluZyBgdG9rZW5gIHdoZW4gaXQgbWF0Y2hlcyBhIHRva2VuLlxuZnVuY3Rpb24gcmVhZFRva2VuKGRhdGEsIGlucHV0LCB0b2tlbiwgc3RhY2ssIGdyb3VwKSB7XG4gICAgbGV0IHN0YXRlID0gMCwgZ3JvdXBNYXNrID0gMSA8PCBncm91cCwgZGlhbGVjdCA9IHN0YWNrLnAucGFyc2VyLmRpYWxlY3Q7XG4gICAgc2NhbjogZm9yIChsZXQgcG9zID0gdG9rZW4uc3RhcnQ7Oykge1xuICAgICAgICBpZiAoKGdyb3VwTWFzayAmIGRhdGFbc3RhdGVdKSA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBhY2NFbmQgPSBkYXRhW3N0YXRlICsgMV07XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBjYW4gbGVhZCB0byBhIHRva2VuIGluIHRoZSBjdXJyZW50IGdyb3VwXG4gICAgICAgIC8vIEFjY2VwdCB0b2tlbnMgaW4gdGhpcyBzdGF0ZSwgcG9zc2libHkgb3ZlcndyaXRpbmdcbiAgICAgICAgLy8gbG93ZXItcHJlY2VkZW5jZSAvIHNob3J0ZXIgdG9rZW5zXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGF0ZSArIDM7IGkgPCBhY2NFbmQ7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICgoZGF0YVtpICsgMV0gJiBncm91cE1hc2spID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZGlhbGVjdC5hbGxvd3ModGVybSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuLnZhbHVlID09IC0xIHx8IHRva2VuLnZhbHVlID09IHRlcm0gfHwgc3RhY2sucC5wYXJzZXIub3ZlcnJpZGVzKHRlcm0sIHRva2VuLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uYWNjZXB0KHRlcm0sIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5nZXQocG9zKyspO1xuICAgICAgICAvLyBEbyBhIGJpbmFyeSBzZWFyY2ggb24gdGhlIHN0YXRlJ3MgZWRnZXNcbiAgICAgICAgZm9yIChsZXQgbG93ID0gMCwgaGlnaCA9IGRhdGFbc3RhdGUgKyAyXTsgbG93IDwgaGlnaDspIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGFjY0VuZCArIG1pZCArIChtaWQgPDwgMSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRhdGFbaW5kZXhdLCB0byA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA+PSB0bylcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBkYXRhW2luZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8vIFNlZSBsZXplci1nZW5lcmF0b3Ivc3JjL2VuY29kZS50cyBmb3IgY29tbWVudHMgYWJvdXQgdGhlIGVuY29kaW5nXG4vLyB1c2VkIGhlcmVcbmZ1bmN0aW9uIGRlY29kZUFycmF5KGlucHV0LCBUeXBlID0gVWludDE2QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICBsZXQgYXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIG91dCA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKSwgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gMTI2IC8qIEJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEdhcDIgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgaWYgKG5leHQgPj0gMzQgLyogR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogQmFzZSAqLykge1xuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDQ2IC8qIEJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLy8gRklYTUUgZmluZCBzb21lIHdheSB0byByZWR1Y2UgcmVjb3Zlcnkgd29yayBkb25lIHdoZW4gdGhlIGlucHV0XG4vLyBkb2Vzbid0IG1hdGNoIHRoZSBncmFtbWFyIGF0IGFsbC5cbi8vIEVudmlyb25tZW50IHZhcmlhYmxlIHVzZWQgdG8gY29udHJvbCBjb25zb2xlIG91dHB1dFxuY29uc3QgdmVyYm9zZSA9IHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgL1xcYnBhcnNlXFxiLy50ZXN0KHByb2Nlc3MuZW52LkxPRyk7XG5sZXQgc3RhY2tJRHMgPSBudWxsO1xuZnVuY3Rpb24gY3V0QXQodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGN1cnNvciA9IHRyZWUuY3Vyc29yKHBvcyk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIShzaWRlIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZShwb3MpIDogY3Vyc29yLmNoaWxkQWZ0ZXIocG9zKSkpXG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlIDwgMCA/IGN1cnNvci50byA8IHBvcyA6IGN1cnNvci5mcm9tID4gcG9zKSAmJiAhY3Vyc29yLnR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oY3Vyc29yLnRvIC0gMSwgcG9zIC0gNSkpIDogTWF0aC5taW4odHJlZS5sZW5ndGgsIE1hdGgubWF4KGN1cnNvci5mcm9tICsgMSwgcG9zICsgNSkpO1xuICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyAwIDogdHJlZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FmZUZyb20gPSAtMTtcbiAgICAgICAgdGhpcy5zYWZlVG8gPSAtMTtcbiAgICAgICAgdGhpcy50cmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICBsZXQgZnIgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5pID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IG51bGwgOiB0aGlzLmZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgICAgIGlmIChmcikge1xuICAgICAgICAgICAgdGhpcy5zYWZlRnJvbSA9IGZyLm9wZW5TdGFydCA/IGN1dEF0KGZyLnRyZWUsIGZyLmZyb20gKyBmci5vZmZzZXQsIDEpIC0gZnIub2Zmc2V0IDogZnIuZnJvbTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvID0gZnIub3BlbkVuZCA/IGN1dEF0KGZyLnRyZWUsIGZyLnRvICsgZnIub2Zmc2V0LCAtMSkgLSBmci5vZmZzZXQgOiBmci50bztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRyZWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKGZyLnRyZWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKC1mci5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLm5leHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLnNhZmVUbyA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnRyZWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHsgLy8gRW5kIG9mIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudHJlZXNbbGFzdF0sIGluZGV4ID0gdGhpcy5pbmRleFtsYXN0XTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0b3AuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YXJ0W2xhc3RdICsgdG9wLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQgPT0gcG9zICYmIHN0YXJ0ICsgbmV4dC5sZW5ndGggPD0gdGhpcy5zYWZlVG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQgPT0gcG9zICYmIHN0YXJ0ID49IHRoaXMuc2FmZUZyb20gPyBuZXh0IDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgbGV6ZXJUcmVlLlRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IHBvcykgeyAvLyBFbnRlciB0aGlzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ2FjaGVkVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5tYXNrID0gMDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gMDtcbiAgICB9XG4gICAgY2xlYXIoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5leHRlbmRlZCA9IC0xO1xuICAgIH1cbn1cbmNvbnN0IGR1bW15VG9rZW4gPSBuZXcgVG9rZW47XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBkdW1teVRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrLCBpbnB1dCkge1xuICAgICAgICBsZXQgYWN0aW9uSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWFpbiA9IG51bGw7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyB0b2tlbml6ZXJzIH0gPSBwYXJzZXI7XG4gICAgICAgIGxldCBtYXNrID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgMyAvKiBUb2tlbml6ZXJNYXNrICovKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzdGFjay5jdXJDb250ZXh0ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKCgxIDw8IGkpICYgbWFzaykgPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0b2tlbml6ZXIgPSB0b2tlbml6ZXJzW2ldLCB0b2tlbiA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKG1haW4gJiYgIXRva2VuaXplci5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0b2tlbml6ZXIuY29udGV4dHVhbCB8fCB0b2tlbi5zdGFydCAhPSBzdGFjay5wb3MgfHwgdG9rZW4ubWFzayAhPSBtYXNrIHx8IHRva2VuLmNvbnRleHQgIT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2ssIGlucHV0KTtcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXNrID0gbWFzaztcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSAhPSAwIC8qIEVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmICghbWFpbikge1xuICAgICAgICAgICAgbWFpbiA9IGR1bW15VG9rZW47XG4gICAgICAgICAgICBtYWluLnN0YXJ0ID0gc3RhY2sucG9zO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA9PSBpbnB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFpbi5hY2NlcHQoc3RhY2sucC5wYXJzZXIuZW9mVGVybSwgc3RhY2sucG9zKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYWluLmFjY2VwdCgwIC8qIEVyciAqLywgc3RhY2sucG9zICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBtYWluO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zO1xuICAgIH1cbiAgICB1cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjaywgaW5wdXQpIHtcbiAgICAgICAgdG9rZW4uY2xlYXIoc3RhY2sucG9zKTtcbiAgICAgICAgdG9rZW5pemVyLnRva2VuKGlucHV0LCB0b2tlbiwgc3RhY2spO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZXIuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zcGVjaWFsaXplZFtpXSA9PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VyLnNwZWNpYWxpemVyc1tpXShpbnB1dC5yZWFkKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPj0gMCAmJiBzdGFjay5wLnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uZXh0ZW5kZWQgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YWNrLnBvcyA9PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2VuLmFjY2VwdChzdGFjay5wLnBhcnNlci5lb2ZUZXJtLCBzdGFjay5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4uYWNjZXB0KDAgLyogRXJyICovLCBzdGFjay5wb3MgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXRBY3Rpb24oYWN0aW9uLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICAvLyBEb24ndCBhZGQgZHVwbGljYXRlIGFjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpXSA9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBhY3Rpb247XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IHRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBlbmQ7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHN0YWNrLCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyBkYXRhIH0gPSBwYXJzZXI7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VyLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBTa2lwICovIDogMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gMCAmJiBkYXRhW2kgKyAxXSA9PSAyIC8qIE90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDEpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbnZhciBSZWM7XG4oZnVuY3Rpb24gKFJlYykge1xuICAgIFJlY1tSZWNbXCJEaXN0YW5jZVwiXSA9IDVdID0gXCJEaXN0YW5jZVwiO1xuICAgIFJlY1tSZWNbXCJNYXhSZW1haW5pbmdQZXJTdGVwXCJdID0gM10gPSBcIk1heFJlbWFpbmluZ1BlclN0ZXBcIjtcbiAgICBSZWNbUmVjW1wiTWluQnVmZmVyTGVuZ3RoUHJ1bmVcIl0gPSAyMDBdID0gXCJNaW5CdWZmZXJMZW5ndGhQcnVuZVwiO1xuICAgIFJlY1tSZWNbXCJGb3JjZVJlZHVjZUxpbWl0XCJdID0gMTBdID0gXCJGb3JjZVJlZHVjZUxpbWl0XCI7XG59KShSZWMgfHwgKFJlYyA9IHt9KSk7XG4vLy8gQSBwYXJzZSBjb250ZXh0IGNhbiBiZSB1c2VkIGZvciBzdGVwLWJ5LXN0ZXAgcGFyc2luZy4gQWZ0ZXJcbi8vLyBjcmVhdGluZyBpdCwgeW91IHJlcGVhdGVkbHkgY2FsbCBgLmFkdmFuY2UoKWAgdW50aWwgaXQgcmV0dXJucyBhXG4vLy8gdHJlZSB0byBpbmRpY2F0ZSBpdCBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwYXJzZS5cbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGlucHV0LCBzdGFydFBvcywgY29udGV4dCkge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnN0YXJ0UG9zID0gc3RhcnRQb3M7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIC8vIFRoZSBwb3NpdGlvbiB0byB3aGljaCB0aGUgcGFyc2UgaGFzIGFkdmFuY2VkLlxuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFN0YWNrSUQgPSAweDI2NTQ7XG4gICAgICAgIHRoaXMubmVzdGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXN0RW5kID0gMDtcbiAgICAgICAgdGhpcy5uZXN0V3JhcCA9IG51bGw7XG4gICAgICAgIHRoaXMucmV1c2VkID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zID0gbmV3IFRva2VuQ2FjaGUocGFyc2VyKTtcbiAgICAgICAgdGhpcy50b3BUZXJtID0gcGFyc2VyLnRvcFsxXTtcbiAgICAgICAgdGhpcy5zdGFja3MgPSBbU3RhY2suc3RhcnQodGhpcywgcGFyc2VyLnRvcFswXSwgdGhpcy5zdGFydFBvcyldO1xuICAgICAgICBsZXQgZnJhZ21lbnRzID0gY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LmZyYWdtZW50cztcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMgJiYgZnJhZ21lbnRzLmxlbmd0aCA/IG5ldyBGcmFnbWVudEN1cnNvcihmcmFnbWVudHMpIDogbnVsbDtcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLm5lc3RlZCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubmVzdGVkLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5uZXN0ZWQucG9zO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoTmVzdGVkKHRoaXMuc3RhY2tzWzBdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBob2xkIHN0YWNrcyBiZXlvbmQgYHBvc2AuXG4gICAgICAgIGxldCBuZXdTdGFja3MgPSB0aGlzLnN0YWNrcyA9IFtdO1xuICAgICAgICBsZXQgc3RvcHBlZCwgc3RvcHBlZFRva2VucztcbiAgICAgICAgbGV0IG1heWJlTmVzdDtcbiAgICAgICAgLy8gS2VlcCBhZHZhbmNpbmcgYW55IHN0YWNrcyBhdCBgcG9zYCB1bnRpbCB0aGV5IGVpdGhlciBtb3ZlXG4gICAgICAgIC8vIGZvcndhcmQgb3IgY2FuJ3QgYmUgYWR2YW5jZWQuIEdhdGhlciBzdGFja3MgdGhhdCBjYW4ndCBiZVxuICAgICAgICAvLyBhZHZhbmNlZCBmdXJ0aGVyIGluIGBzdG9wcGVkYC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXSwgbmVzdDtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmVzdCA9IHRoaXMuY2hlY2tOZXN0KHN0YWNrKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heWJlTmVzdCB8fCBtYXliZU5lc3Quc3RhY2suc2NvcmUgPCBzdGFjay5zY29yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlTmVzdCA9IG5lc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBuZXdTdGFja3MsIHN0YWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9rID0gdGhpcy50b2tlbnMubWFpblRva2VuO1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zLnB1c2godG9rLnZhbHVlLCB0b2suZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlTmVzdCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydE5lc3RlZChtYXliZU5lc3QpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZXdTdGFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBzdG9wcGVkICYmIGZpbmRGaW5pc2hlZChzdG9wcGVkKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UgJiYgc3RvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdHVjayB3aXRoIHRva2VuIFwiICsgdGhpcy5wYXJzZXIuZ2V0TmFtZSh0aGlzLnRva2Vucy5tYWluVG9rZW4udmFsdWUpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJObyBwYXJzZSBhdCBcIiArIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVjb3ZlcmluZylcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSA1IC8qIERpc3RhbmNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJpbmcgJiYgc3RvcHBlZCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gdGhpcy5ydW5SZWNvdmVyeShzdG9wcGVkLCBzdG9wcGVkVG9rZW5zLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkLmZvcmNlQWxsKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJpbmcpIHtcbiAgICAgICAgICAgIGxldCBtYXhSZW1haW5pbmcgPSB0aGlzLnJlY292ZXJpbmcgPT0gMSA/IDEgOiB0aGlzLnJlY292ZXJpbmcgKiAzIC8qIE1heFJlbWFpbmluZ1BlclN0ZXAgKi87XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZykge1xuICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3Muc29tZShzID0+IHMucmVkdWNlUG9zID4gcG9zKSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmctLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gUHJ1bmUgc3RhY2tzIHRoYXQgYXJlIGluIHRoZSBzYW1lIHN0YXRlLCBvciB0aGF0IGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gcnVubmluZyB3aXRob3V0IHNwbGl0dGluZyBmb3IgYSB3aGlsZSwgdG8gYXZvaWQgZ2V0dGluZyBzdHVja1xuICAgICAgICAgICAgLy8gd2l0aCBtdWx0aXBsZSBzdWNjZXNzZnVsIHN0YWNrcyBydW5uaW5nIGVuZGxlc3NseSBvbi5cbiAgICAgICAgICAgIG91dGVyOiBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSBuZXdTdGFja3NbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbmV3U3RhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLnNhbWVTdGF0ZShvdGhlcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmJ1ZmZlci5sZW5ndGggPiAyMDAgLyogTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8gJiYgb3RoZXIuYnVmZmVyLmxlbmd0aCA+IDIwMCAvKiBNaW5CdWZmZXJMZW5ndGhQcnVuZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoc3RhY2suc2NvcmUgLSBvdGhlci5zY29yZSkgfHwgKHN0YWNrLmJ1ZmZlci5sZW5ndGggLSBvdGhlci5idWZmZXIubGVuZ3RoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gbmV3U3RhY2tzWzBdLnBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnBvcyA8IHRoaXMucG9zKVxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gbmV3U3RhY2tzW2ldLnBvcztcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYW4gdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBzdGFjaywgb3IgbnVsbCBpZiB0aGVcbiAgICAvLyBzdGFjayBjYW4ndCBhZHZhbmNlIG5vcm1hbGx5LiBXaGVuIGBzcGxpdGAgYW5kIGBzdGFja3NgIGFyZVxuICAgIC8vIGdpdmVuLCBzdGFja3Mgc3BsaXQgb2ZmIGJ5IGFtYmlndW91cyBvcGVyYXRpb25zIHdpbGwgYmUgcHVzaGVkIHRvXG4gICAgLy8gYHNwbGl0YCwgb3IgYWRkZWQgdG8gYHN0YWNrc2AgaWYgdGhleSBtb3ZlIGBwb3NgIGZvcndhcmQuXG4gICAgYWR2YW5jZVN0YWNrKHN0YWNrLCBzdGFja3MsIHNwbGl0KSB7XG4gICAgICAgIGxldCBzdGFydCA9IHN0YWNrLnBvcywgeyBpbnB1dCwgcGFyc2VyIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGxldCBzdHJpY3RDeCA9IHN0YWNrLmN1ckNvbnRleHQgJiYgc3RhY2suY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCwgY3hIYXNoID0gc3RyaWN0Q3ggPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGggJiYgKCFzdHJpY3RDeCB8fCAoY2FjaGVkLmNvbnRleHRIYXNoIHx8IDApID09IGN4SGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlTm9kZShjYWNoZWQsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZXVzZSBvZiAke3BhcnNlci5nZXROYW1lKGNhY2hlZC50eXBlLmlkKX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZWQgaW5zdGFuY2VvZiBsZXplclRyZWUuVHJlZSkgfHwgY2FjaGVkLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IGNhY2hlZC5wb3NpdGlvbnNbMF0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjYWNoZWQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyIGluc3RhbmNlb2YgbGV6ZXJUcmVlLlRyZWUpXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoZGVmYXVsdFJlZHVjZSA+IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZShkZWZhdWx0UmVkdWNlKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIGFsd2F5cy1yZWR1Y2UgJHtwYXJzZXIuZ2V0TmFtZShkZWZhdWx0UmVkdWNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovKX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMudG9rZW5zLmdldEFjdGlvbnMoc3RhY2ssIGlucHV0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBhY3Rpb25zW2krK10sIHRlcm0gPSBhY3Rpb25zW2krK10sIGVuZCA9IGFjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBhY3Rpb25zLmxlbmd0aCB8fCAhc3BsaXQ7XG4gICAgICAgICAgICBsZXQgbG9jYWxTdGFjayA9IGxhc3QgPyBzdGFjayA6IHN0YWNrLnNwbGl0KCk7XG4gICAgICAgICAgICBsb2NhbFN0YWNrLmFwcGx5KGFjdGlvbiwgdGVybSwgZW5kKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQobG9jYWxTdGFjaykgKyBgICh2aWEgJHsoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMCA/IFwic2hpZnRcIlxuICAgICAgICAgICAgICAgICAgICA6IGByZWR1Y2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pfWB9IGZvciAke3BhcnNlci5nZXROYW1lKHRlcm0pfSBAICR7c3RhcnR9JHtsb2NhbFN0YWNrID09IHN0YWNrID8gXCJcIiA6IFwiLCBzcGxpdFwifSlgKTtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxTdGFjay5wb3MgPiBzdGFydClcbiAgICAgICAgICAgICAgICBzdGFja3MucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzcGxpdC5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWR2YW5jZSBhIGdpdmVuIHN0YWNrIGZvcndhcmQgYXMgZmFyIGFzIGl0IHdpbGwgZ28uIFJldHVybnMgdGhlXG4gICAgLy8gKHBvc3NpYmx5IHVwZGF0ZWQpIHN0YWNrIGlmIGl0IGdvdCBzdHVjaywgb3IgbnVsbCBpZiBpdCBtb3ZlZFxuICAgIC8vIGZvcndhcmQgYW5kIHdhcyBnaXZlbiB0byBgcHVzaFN0YWNrRGVkdXBgLlxuICAgIGFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBwb3MgPSBzdGFjay5wb3M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXN0ID0gdGhpcy5jaGVja05lc3Qoc3RhY2spO1xuICAgICAgICAgICAgaWYgKG5lc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBudWxsLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuUmVjb3Zlcnkoc3RhY2tzLCB0b2tlbnMsIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgZmluaXNoZWQgPSBudWxsLCByZXN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG1heWJlTmVzdDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXSwgdG9rZW4gPSB0b2tlbnNbaSA8PCAxXSwgdG9rZW5FbmQgPSB0b2tlbnNbKGkgPDwgMSkgKyAxXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAoc3RhY2suZGVhZEVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIChyZXN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5lc3QgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBzdGFjay5zcGxpdCgpLCBmb3JjZUJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGZvcmNlLmZvcmNlUmVkdWNlKCkgJiYgaiA8IDEwIC8qIEZvcmNlUmVkdWNlTGltaXQgKi87IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmb3JjZUJhc2UgKyB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgKHZpYSBmb3JjZS1yZWR1Y2UpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoZm9yY2UsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5lc3QgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQmFzZSA9IHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAtPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGluc2VydCBvZiBzdGFjay5yZWNvdmVyQnlJbnNlcnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoaW5zZXJ0KSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUZ1bGx5KGluc2VydCwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0Lmxlbmd0aCA+IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkVuZCA9PSBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmQrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAwIC8qIEVyciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucmVjb3ZlckJ5RGVsZXRlKHRva2VuLCB0b2tlbkVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJlY292ZXItZGVsZXRlICR7dGhpcy5wYXJzZXIuZ2V0TmFtZSh0b2tlbil9KWApO1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmlzaGVkIHx8IGZpbmlzaGVkLnNjb3JlIDwgc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICAgICAgaWYgKG1heWJlTmVzdClcbiAgICAgICAgICAgIGZvciAobGV0IHMgb2YgdGhpcy5zdGFja3MpXG4gICAgICAgICAgICAgICAgaWYgKHMuc2NvcmUgPiBtYXliZU5lc3Quc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVOZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIGlmIChtYXliZU5lc3QpXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmVzdGVkKG1heWJlTmVzdCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3JjZUZpbmlzaCgpIHtcbiAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zdGFja3NbMF0uc3BsaXQoKTtcbiAgICAgICAgaWYgKHRoaXMubmVzdGVkKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hOZXN0ZWQoc3RhY2ssIHRoaXMubmVzdGVkLmZvcmNlRmluaXNoKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShzdGFjay5mb3JjZUFsbCgpKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgc3RhY2sncyBidWZmZXIgdG8gYSBzeW50YXggdHJlZS5cbiAgICBzdGFja1RvVHJlZShzdGFjaywgcG9zID0gc3RhY2sucG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlci5jb250ZXh0KVxuICAgICAgICAgICAgc3RhY2suZW1pdENvbnRleHQoKTtcbiAgICAgICAgcmV0dXJuIGxlemVyVHJlZS5UcmVlLmJ1aWxkKHsgYnVmZmVyOiBTdGFja0J1ZmZlckN1cnNvci5jcmVhdGUoc3RhY2spLFxuICAgICAgICAgICAgbm9kZVNldDogdGhpcy5wYXJzZXIubm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiB0aGlzLnRvcFRlcm0sXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IHRoaXMucGFyc2VyLmJ1ZmZlckxlbmd0aCxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5yZXVzZWQsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5zdGFydFBvcyxcbiAgICAgICAgICAgIGxlbmd0aDogcG9zIC0gdGhpcy5zdGFydFBvcyxcbiAgICAgICAgICAgIG1pblJlcGVhdFR5cGU6IHRoaXMucGFyc2VyLm1pblJlcGVhdFRlcm0gfSk7XG4gICAgfVxuICAgIGNoZWNrTmVzdChzdGFjaykge1xuICAgICAgICBsZXQgaW5mbyA9IHRoaXMucGFyc2VyLmZpbmROZXN0ZWQoc3RhY2suc3RhdGUpO1xuICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHNwZWMgPSBpbmZvLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgc3BlYyA9IHNwZWModGhpcy5pbnB1dCwgc3RhY2spO1xuICAgICAgICByZXR1cm4gc3BlYyA/IHsgc3RhY2ssIGluZm8sIHNwZWMgfSA6IG51bGw7XG4gICAgfVxuICAgIHN0YXJ0TmVzdGVkKG5lc3QpIHtcbiAgICAgICAgbGV0IHsgc3RhY2ssIGluZm8sIHNwZWMgfSA9IG5lc3Q7XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW3N0YWNrXTtcbiAgICAgICAgdGhpcy5uZXN0RW5kID0gdGhpcy5zY2FuRm9yTmVzdEVuZChzdGFjaywgaW5mby5lbmQsIHNwZWMuZmlsdGVyRW5kKTtcbiAgICAgICAgdGhpcy5uZXN0V3JhcCA9IHR5cGVvZiBzcGVjLndyYXBUeXBlID09IFwibnVtYmVyXCIgPyB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW3NwZWMud3JhcFR5cGVdIDogc3BlYy53cmFwVHlwZSB8fCBudWxsO1xuICAgICAgICBpZiAoc3BlYy5zdGFydFBhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLm5lc3RlZCA9IHNwZWMuc3RhcnRQYXJzZSh0aGlzLmlucHV0LmNsaXAodGhpcy5uZXN0RW5kKSwgc3RhY2sucG9zLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5pc2hOZXN0ZWQoc3RhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW5Gb3JOZXN0RW5kKHN0YWNrLCBlbmRUb2tlbiwgZmlsdGVyKSB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN0YWNrLnBvczsgcG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgICAgICBkdW1teVRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgZHVtbXlUb2tlbi52YWx1ZSA9IC0xO1xuICAgICAgICAgICAgZW5kVG9rZW4udG9rZW4odGhpcy5pbnB1dCwgZHVtbXlUb2tlbiwgc3RhY2spO1xuICAgICAgICAgICAgaWYgKGR1bW15VG9rZW4udmFsdWUgPiAtMSAmJiAoIWZpbHRlciB8fCBmaWx0ZXIodGhpcy5pbnB1dC5yZWFkKHBvcywgZHVtbXlUb2tlbi5lbmQpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgfVxuICAgIGZpbmlzaE5lc3RlZChzdGFjaywgdHJlZSkge1xuICAgICAgICBpZiAodGhpcy5uZXN0V3JhcClcbiAgICAgICAgICAgIHRyZWUgPSBuZXcgbGV6ZXJUcmVlLlRyZWUodGhpcy5uZXN0V3JhcCwgdHJlZSA/IFt0cmVlXSA6IFtdLCB0cmVlID8gWzBdIDogW10sIHRoaXMubmVzdEVuZCAtIHN0YWNrLnBvcyk7XG4gICAgICAgIGVsc2UgaWYgKCF0cmVlKVxuICAgICAgICAgICAgdHJlZSA9IG5ldyBsZXplclRyZWUuVHJlZShsZXplclRyZWUuTm9kZVR5cGUubm9uZSwgW10sIFtdLCB0aGlzLm5lc3RFbmQgLSBzdGFjay5wb3MpO1xuICAgICAgICBsZXQgaW5mbyA9IHRoaXMucGFyc2VyLmZpbmROZXN0ZWQoc3RhY2suc3RhdGUpO1xuICAgICAgICBzdGFjay51c2VOb2RlKHRyZWUsIHRoaXMucGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGluZm8ucGxhY2Vob2xkZXIsIHRydWUpKTtcbiAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHVubmVzdClgKTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG5jb25zdCBpZCA9IHggPT4geDtcbi8vLyBDb250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbi8vLyBpbmRlbnRhdGlvbiBpbiB0aGUgUHl0aG9uIGdyYW1tYXIsIG9yIHBhcmVudCBlbGVtZW50cyBpbiB0aGUgWE1MXG4vLy8gZ3JhbW1hcikgbmVlZGVkIGJ5IGV4dGVybmFsIHRva2VuaXplcnMuIFlvdSBkZWNsYXJlIHRoZW0gaW4gYVxuLy8vIGdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuLy8vXG4vLy8gQ29udGV4dCB2YWx1ZXMgc2hvdWxkIGJlIGltbXV0YWJsZSwgYW5kIGNhbiBiZSB1cGRhdGVkIChyZXBsYWNlZClcbi8vLyBvbiBzaGlmdCBvciByZWR1Y2UgYWN0aW9ucy5cbmNsYXNzIENvbnRleHRUcmFja2VyIHtcbiAgICAvLy8gVGhlIGV4cG9ydCB1c2VkIGluIGEgYEBjb250ZXh0YCBkZWNsYXJhdGlvbiBzaG91bGQgYmUgb2YgdGhpc1xuICAgIC8vLyB0eXBlLlxuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHNwZWMuc3RhcnQ7XG4gICAgICAgIHRoaXMuc2hpZnQgPSBzcGVjLnNoaWZ0IHx8IGlkO1xuICAgICAgICB0aGlzLnJlZHVjZSA9IHNwZWMucmVkdWNlIHx8IGlkO1xuICAgICAgICB0aGlzLnJldXNlID0gc3BlYy5yZXVzZSB8fCBpZDtcbiAgICAgICAgdGhpcy5oYXNoID0gc3BlYy5oYXNoO1xuICAgICAgICB0aGlzLnN0cmljdCA9IHNwZWMuc3RyaWN0ICE9PSBmYWxzZTtcbiAgICB9XG59XG4vLy8gQSBwYXJzZXIgaG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWRcbi8vLyBieSBgbGV6ZXItZ2VuZXJhdG9yYC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IGxlemVyVHJlZS5EZWZhdWx0QnVmZmVyTGVuZ3RoO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMuc3RyaWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FjaGVkRGlhbGVjdCA9IG51bGw7XG4gICAgICAgIGlmIChzcGVjLnZlcnNpb24gIT0gMTMgLyogVmVyc2lvbiAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQYXJzZXIgdmVyc2lvbiAoJHtzcGVjLnZlcnNpb259KSBkb2Vzbid0IG1hdGNoIHJ1bnRpbWUgdmVyc2lvbiAoJHsxMyAvKiBWZXJzaW9uICovfSlgKTtcbiAgICAgICAgbGV0IHRva2VuQXJyYXkgPSBkZWNvZGVBcnJheShzcGVjLnRva2VuRGF0YSk7XG4gICAgICAgIGxldCBub2RlTmFtZXMgPSBzcGVjLm5vZGVOYW1lcy5zcGxpdChcIiBcIik7XG4gICAgICAgIHRoaXMubWluUmVwZWF0VGVybSA9IG5vZGVOYW1lcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHNwZWMuY29udGV4dDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnJlcGVhdE5vZGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgbm9kZU5hbWVzLnB1c2goXCJcIik7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGVjaWFsaXplZCA9IG5ldyBVaW50MTZBcnJheShzcGVjLnNwZWNpYWxpemVkID8gc3BlYy5zcGVjaWFsaXplZC5sZW5ndGggOiAwKTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMuc3BlY2lhbGl6ZWQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVkW2ldID0gc3BlYy5zcGVjaWFsaXplZFtpXS50ZXJtO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzW2ldID0gc3BlYy5zcGVjaWFsaXplZFtpXS5nZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVzID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZXMsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZURhdGEpO1xuICAgICAgICB0aGlzLmdvdG8gPSBkZWNvZGVBcnJheShzcGVjLmdvdG8pO1xuICAgICAgICBsZXQgdG9wVGVybXMgPSBPYmplY3Qua2V5cyhzcGVjLnRvcFJ1bGVzKS5tYXAociA9PiBzcGVjLnRvcFJ1bGVzW3JdWzFdKTtcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IGxlemVyVHJlZS5Ob2RlU2V0KG5vZGVOYW1lcy5tYXAoKG5hbWUsIGkpID0+IGxlemVyVHJlZS5Ob2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICAgICAgbmFtZTogaSA+PSB0aGlzLm1pblJlcGVhdFRlcm0gPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICBwcm9wczogbm9kZVByb3BzW2ldLFxuICAgICAgICAgICAgdG9wOiB0b3BUZXJtcy5pbmRleE9mKGkpID4gLTEsXG4gICAgICAgICAgICBlcnJvcjogaSA9PSAwLFxuICAgICAgICAgICAgc2tpcHBlZDogc3BlYy5za2lwcGVkTm9kZXMgJiYgc3BlYy5za2lwcGVkTm9kZXMuaW5kZXhPZihpKSA+IC0xXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHRoaXMubWF4VGVybSA9IHNwZWMubWF4VGVybTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXJzID0gc3BlYy50b2tlbml6ZXJzLm1hcCh2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IG5ldyBUb2tlbkdyb3VwKHRva2VuQXJyYXksIHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgdGhpcy50b3BSdWxlcyA9IHNwZWMudG9wUnVsZXM7XG4gICAgICAgIHRoaXMubmVzdGVkID0gKHNwZWMubmVzdGVkIHx8IFtdKS5tYXAoKFtuYW1lLCB2YWx1ZSwgZW5kVG9rZW4sIHBsYWNlaG9sZGVyXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgdmFsdWUsIGVuZDogbmV3IFRva2VuR3JvdXAoZGVjb2RlQXJyYXkoZW5kVG9rZW4pLCAwKSwgcGxhY2Vob2xkZXIgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlhbGVjdHMgPSBzcGVjLmRpYWxlY3RzIHx8IHt9O1xuICAgICAgICB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcyA9IHNwZWMuZHluYW1pY1ByZWNlZGVuY2VzIHx8IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5QcmVjVGFibGUgPSBzcGVjLnRva2VuUHJlYztcbiAgICAgICAgdGhpcy50ZXJtTmFtZXMgPSBzcGVjLnRlcm1OYW1lcyB8fCBudWxsO1xuICAgICAgICB0aGlzLm1heE5vZGUgPSB0aGlzLm5vZGVTZXQudHlwZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoKTtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcFJ1bGVzW09iamVjdC5rZXlzKHRoaXMudG9wUnVsZXMpWzBdXTtcbiAgICB9XG4gICAgLy8vIFBhcnNlIGEgZ2l2ZW4gc3RyaW5nIG9yIHN0cmVhbS5cbiAgICBwYXJzZShpbnB1dCwgc3RhcnRQb3MgPSAwLCBjb250ZXh0ID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBsZXplclRyZWUuc3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICBsZXQgY3ggPSBuZXcgUGFyc2UodGhpcywgaW5wdXQsIHN0YXJ0UG9zLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBjeC5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gU3RhcnQgYW4gaW5jcmVtZW50YWwgcGFyc2UuXG4gICAgc3RhcnRQYXJzZShpbnB1dCwgc3RhcnRQb3MgPSAwLCBjb250ZXh0ID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBsZXplclRyZWUuc3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBzdGFydFBvcywgY29udGV4dCk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBnb3RvIHRhYmxlIGVudHJ5IEBpbnRlcm5hbFxuICAgIGdldEdvdG8oc3RhdGUsIHRlcm0sIGxvb3NlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy5nb3RvO1xuICAgICAgICBpZiAodGVybSA+PSB0YWJsZVswXSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdGFibGVbdGVybSArIDFdOzspIHtcbiAgICAgICAgICAgIGxldCBncm91cFRhZyA9IHRhYmxlW3BvcysrXSwgbGFzdCA9IGdyb3VwVGFnICYgMTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0YWJsZVtwb3MrK107XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsb29zZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgZW5kID0gcG9zICsgKGdyb3VwVGFnID4+IDEpOyBwb3MgPCBlbmQ7IHBvcysrKVxuICAgICAgICAgICAgICAgIGlmICh0YWJsZVtwb3NdID09IHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBDaGVjayBpZiB0aGlzIHN0YXRlIGhhcyBhbiBhY3Rpb24gZm9yIGEgZ2l2ZW4gdGVybWluYWwgQGludGVybmFsXG4gICAgaGFzQWN0aW9uKHN0YXRlLCB0ZXJtaW5hbCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBTa2lwICovIDogMSAvKiBBY3Rpb25zICovKSwgbmV4dDs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmICgobmV4dCA9IGRhdGFbaV0pID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGRhdGFbaSA9IHBhaXIoZGF0YSwgaSArIDIpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVtpICsgMV0gPT0gMiAvKiBPdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IHRlcm1pbmFsIHx8IG5leHQgPT0gMCAvKiBFcnIgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlU2xvdChzdGF0ZSwgc2xvdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbKHN0YXRlICogNiAvKiBTaXplICovKSArIHNsb3RdO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGVGbGFnKHN0YXRlLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDAgLyogRmxhZ3MgKi8pICYgZmxhZykgPiAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZmluZE5lc3RlZChzdGF0ZSkge1xuICAgICAgICBsZXQgZmxhZ3MgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMCAvKiBGbGFncyAqLyk7XG4gICAgICAgIHJldHVybiBmbGFncyAmIDQgLyogU3RhcnROZXN0ICovID8gdGhpcy5uZXN0ZWRbZmxhZ3MgPj4gMTAgLyogTmVzdFNoaWZ0ICovXSA6IG51bGw7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB2YWxpZEFjdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24gPT0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IHBhaXIodGhpcy5kYXRhLCBpICsgMSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEdldCB0aGUgc3RhdGVzIHRoYXQgY2FuIGZvbGxvdyB0aGlzIG9uZSB0aHJvdWdoIHNoaWZ0IGFjdGlvbnMgb3JcbiAgICAvLy8gZ290byBqdW1wcy4gQGludGVybmFsXG4gICAgbmV4dFN0YXRlcyhzdGF0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuZGF0YVtpICsgMl0gJiAoNjU1MzYgLyogUmVkdWNlRmxhZyAqLyA+PiAxNikpID09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZGF0YVtpXSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBvdmVycmlkZXModG9rZW4sIHByZXYpIHtcbiAgICAgICAgbGV0IGlQcmV2ID0gZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHByZXYpO1xuICAgICAgICByZXR1cm4gaVByZXYgPCAwIHx8IGZpbmRPZmZzZXQodGhpcy5kYXRhLCB0aGlzLnRva2VuUHJlY1RhYmxlLCB0b2tlbikgPCBpUHJldjtcbiAgICB9XG4gICAgLy8vIENvbmZpZ3VyZSB0aGUgcGFyc2VyLiBSZXR1cm5zIGEgbmV3IHBhcnNlciBpbnN0YW5jZSB0aGF0IGhhcyB0aGVcbiAgICAvLy8gZ2l2ZW4gc2V0dGluZ3MgbW9kaWZpZWQuIFNldHRpbmdzIG5vdCBwcm92aWRlZCBpbiBgY29uZmlnYCBhcmVcbiAgICAvLy8ga2VwdCBmcm9tIHRoZSBvcmlnaW5hbCBwYXJzZXIuXG4gICAgY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICAvLyBIaWRlb3VzIHJlZmxlY3Rpb24tYmFzZWQga2x1ZGdlIHRvIG1ha2UgaXQgZWFzeSB0byBjcmVhdGUgYVxuICAgICAgICAvLyBzbGlnaHRseSBtb2RpZmllZCBjb3B5IG9mIGEgcGFyc2VyLlxuICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShQYXJzZXIucHJvdG90eXBlKSwgdGhpcyk7XG4gICAgICAgIGlmIChjb25maWcucHJvcHMpXG4gICAgICAgICAgICBjb3B5Lm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLmNvbmZpZy5wcm9wcyk7XG4gICAgICAgIGlmIChjb25maWcudG9wKSB7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IHRoaXMudG9wUnVsZXNbY29uZmlnLnRvcF07XG4gICAgICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgdG9wIHJ1bGUgbmFtZSAke2NvbmZpZy50b3B9YCk7XG4gICAgICAgICAgICBjb3B5LnRvcCA9IGluZm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy50b2tlbml6ZXJzKVxuICAgICAgICAgICAgY29weS50b2tlbml6ZXJzID0gdGhpcy50b2tlbml6ZXJzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcudG9rZW5pemVycy5maW5kKHIgPT4gci5mcm9tID09IHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZCA/IGZvdW5kLnRvIDogdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLmRpYWxlY3QpXG4gICAgICAgICAgICBjb3B5LmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdChjb25maWcuZGlhbGVjdCk7XG4gICAgICAgIGlmIChjb25maWcubmVzdGVkKVxuICAgICAgICAgICAgY29weS5uZXN0ZWQgPSB0aGlzLm5lc3RlZC5tYXAob2JqID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcubmVzdGVkLCBvYmoubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogb2JqLm5hbWUsIHZhbHVlOiBjb25maWcubmVzdGVkW29iai5uYW1lXSwgZW5kOiBvYmouZW5kLCBwbGFjZWhvbGRlcjogb2JqLnBsYWNlaG9sZGVyIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpY3QgIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuc3RyaWN0ID0gY29uZmlnLnN0cmljdDtcbiAgICAgICAgaWYgKGNvbmZpZy5idWZmZXJMZW5ndGggIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuYnVmZmVyTGVuZ3RoID0gY29uZmlnLmJ1ZmZlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8vLyBSZXR1cm5zIHRoZSBuYW1lIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlcm0uIFRoaXMgd2lsbCBvbmx5XG4gICAgLy8vIHdvcmsgZm9yIGFsbCB0ZXJtcyB3aGVuIHRoZSBwYXJzZXIgd2FzIGdlbmVyYXRlZCB3aXRoIHRoZVxuICAgIC8vLyBgLS1uYW1lc2Agb3B0aW9uLiBCeSBkZWZhdWx0LCBvbmx5IHRoZSBuYW1lcyBvZiB0YWdnZWQgdGVybXMgYXJlXG4gICAgLy8vIHN0b3JlZC5cbiAgICBnZXROYW1lKHRlcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybU5hbWVzID8gdGhpcy50ZXJtTmFtZXNbdGVybV0gOiBTdHJpbmcodGVybSA8PSB0aGlzLm1heE5vZGUgJiYgdGhpcy5ub2RlU2V0LnR5cGVzW3Rlcm1dLm5hbWUgfHwgdGVybSk7XG4gICAgfVxuICAgIC8vLyBUaGUgZW9mIHRlcm0gaWQgaXMgYWx3YXlzIGFsbG9jYXRlZCBkaXJlY3RseSBhZnRlciB0aGUgbm9kZVxuICAgIC8vLyB0eXBlcy4gQGludGVybmFsXG4gICAgZ2V0IGVvZlRlcm0oKSB7IHJldHVybiB0aGlzLm1heE5vZGUgKyAxOyB9XG4gICAgLy8vIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgZ3JhbW1hciBoYXMgYW55IG5lc3RlZCBncmFtbWFycy5cbiAgICBnZXQgaGFzTmVzdGVkKCkgeyByZXR1cm4gdGhpcy5uZXN0ZWQubGVuZ3RoID4gMDsgfVxuICAgIC8vLyBUaGUgdHlwZSBvZiB0b3Agbm9kZSBwcm9kdWNlZCBieSB0aGUgcGFyc2VyLlxuICAgIGdldCB0b3BOb2RlKCkgeyByZXR1cm4gdGhpcy5ub2RlU2V0LnR5cGVzW3RoaXMudG9wWzFdXTsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBkeW5hbWljUHJlY2VkZW5jZSh0ZXJtKSB7XG4gICAgICAgIGxldCBwcmVjID0gdGhpcy5keW5hbWljUHJlY2VkZW5jZXM7XG4gICAgICAgIHJldHVybiBwcmVjID09IG51bGwgPyAwIDogcHJlY1t0ZXJtXSB8fCAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcGFyc2VEaWFsZWN0KGRpYWxlY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkRGlhbGVjdCAmJiB0aGlzLmNhY2hlZERpYWxlY3Quc291cmNlID09IGRpYWxlY3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWREaWFsZWN0O1xuICAgICAgICBsZXQgdmFsdWVzID0gT2JqZWN0LmtleXModGhpcy5kaWFsZWN0cyksIGZsYWdzID0gdmFsdWVzLm1hcCgoKSA9PiBmYWxzZSk7XG4gICAgICAgIGlmIChkaWFsZWN0KVxuICAgICAgICAgICAgZm9yIChsZXQgcGFydCBvZiBkaWFsZWN0LnNwbGl0KFwiIFwiKSkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHZhbHVlcy5pbmRleE9mKHBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpZCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBmbGFnc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgZGlzYWJsZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghZmxhZ3NbaV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5kaWFsZWN0c1t2YWx1ZXNbaV1dLCBpZDsgKGlkID0gdGhpcy5kYXRhW2orK10pICE9IDY1NTM1IC8qIEVuZCAqLzspXG4gICAgICAgICAgICAgICAgICAgIChkaXNhYmxlZCB8fCAoZGlzYWJsZWQgPSBuZXcgVWludDhBcnJheSh0aGlzLm1heFRlcm0gKyAxKSkpW2lkXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZERpYWxlY3QgPSBuZXcgRGlhbGVjdChkaWFsZWN0LCBmbGFncywgZGlzYWJsZWQpO1xuICAgIH1cbiAgICAvLy8gKHVzZWQgYnkgdGhlIG91dHB1dCBvZiB0aGUgcGFyc2VyIGdlbmVyYXRvcikgQGludGVybmFsXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoc3BlYyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFpcihkYXRhLCBvZmYpIHsgcmV0dXJuIGRhdGFbb2ZmXSB8IChkYXRhW29mZiArIDFdIDw8IDE2KTsgfVxuZnVuY3Rpb24gZmluZE9mZnNldChkYXRhLCBzdGFydCwgdGVybSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgbmV4dDsgKG5leHQgPSBkYXRhW2ldKSAhPSA2NTUzNSAvKiBFbmQgKi87IGkrKylcbiAgICAgICAgaWYgKG5leHQgPT0gdGVybSlcbiAgICAgICAgICAgIHJldHVybiBpIC0gc3RhcnQ7XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZmluZEZpbmlzaGVkKHN0YWNrcykge1xuICAgIGxldCBiZXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgaWYgKHN0YWNrLnBvcyA9PSBzdGFjay5wLmlucHV0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc3RhY2sucC5wYXJzZXIuc3RhdGVGbGFnKHN0YWNrLnN0YXRlLCAyIC8qIEFjY2VwdGluZyAqLykgJiZcbiAgICAgICAgICAgICghYmVzdCB8fCBiZXN0LnNjb3JlIDwgc3RhY2suc2NvcmUpKVxuICAgICAgICAgICAgYmVzdCA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cblxuZXhwb3J0cy5Ob2RlUHJvcCA9IGxlemVyVHJlZS5Ob2RlUHJvcDtcbmV4cG9ydHMuTm9kZVNldCA9IGxlemVyVHJlZS5Ob2RlU2V0O1xuZXhwb3J0cy5Ob2RlVHlwZSA9IGxlemVyVHJlZS5Ob2RlVHlwZTtcbmV4cG9ydHMuVHJlZSA9IGxlemVyVHJlZS5UcmVlO1xuZXhwb3J0cy5UcmVlQ3Vyc29yID0gbGV6ZXJUcmVlLlRyZWVDdXJzb3I7XG5leHBvcnRzLkNvbnRleHRUcmFja2VyID0gQ29udGV4dFRyYWNrZXI7XG5leHBvcnRzLkV4dGVybmFsVG9rZW5pemVyID0gRXh0ZXJuYWxUb2tlbml6ZXI7XG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbmV4cG9ydHMuU3RhY2sgPSBTdGFjaztcbmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuaXNVb3AgPSBleHBvcnRzLmlzT3AgPSBleHBvcnRzLmlzTGl0ZXJhbCA9IHZvaWQgMDtcclxuZnVuY3Rpb24gaXNMaXRlcmFsKG1heWJlTGl0KSB7XHJcbiAgICB2YXIgdGFnID0gbWF5YmVMaXQudGFnO1xyXG4gICAgaWYgKHRhZyA9PT0gXCJudW1iZXJcIiB8fCB0YWcgPT09IFwidHJ1ZVwiIHx8IHRhZyA9PT0gXCJmYWxzZVwiIHx8IHRhZyA9PT0gXCJub25lXCIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmlzTGl0ZXJhbCA9IGlzTGl0ZXJhbDtcclxudmFyIG9wcyA9IHsgXCIrXCI6IHRydWUsIFwiLVwiOiB0cnVlLCBcIipcIjogdHJ1ZSwgXCIvL1wiOiB0cnVlLCBcIiVcIjogdHJ1ZSwgXCI9PVwiOiB0cnVlLCBcIiE9XCI6IHRydWUsXHJcbiAgICBcIjw9XCI6IHRydWUsIFwiPj1cIjogdHJ1ZSwgXCI8XCI6IHRydWUsIFwiPlwiOiB0cnVlLCBcImlzXCI6IHRydWUgfTtcclxuZnVuY3Rpb24gaXNPcChtYXliZU9wKSB7XHJcbiAgICByZXR1cm4gbWF5YmVPcCBpbiBvcHM7XHJcbn1cclxuZXhwb3J0cy5pc09wID0gaXNPcDtcclxudmFyIHVvcHMgPSB7IFwibm90XCI6IHRydWUsIFwiLVwiOiB0cnVlIH07XHJcbmZ1bmN0aW9uIGlzVW9wKG1heWJlVW9wKSB7XHJcbiAgICByZXR1cm4gbWF5YmVVb3AgaW4gdW9wcztcclxufVxyXG5leHBvcnRzLmlzVW9wID0gaXNVb3A7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufTtcclxudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5jb21waWxlID0gZXhwb3J0cy5jb2RlR2VuU3RtdCA9IGV4cG9ydHMuY29kZUdlbkV4cHIgPSBleHBvcnRzLnVvcFN0bXRzID0gZXhwb3J0cy5vcFN0bXRzID0gZXhwb3J0cy5ydW4gPSB2b2lkIDA7XHJcbnZhciB3YWJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndhYnRcIikpO1xyXG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi9wYXJzZXJcIik7XHJcbnZhciB0Y18xID0gcmVxdWlyZShcIi4vdGNcIik7XHJcbnZhciBMb29wTGFiZWwgPSAxO1xyXG5mdW5jdGlvbiB2YXJpYWJsZU5hbWVzKHN0bXRzKSB7XHJcbiAgICB2YXIgdmFycyA9IFtdO1xyXG4gICAgc3RtdHMuZm9yRWFjaChmdW5jdGlvbiAoc3RtdCkge1xyXG4gICAgICAgIGlmIChzdG10LnRhZyA9PT0gXCJ2YXJkZWZcIikge1xyXG4gICAgICAgICAgICB2YXJzLnB1c2goc3RtdC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB2YXJzO1xyXG59XHJcbmZ1bmN0aW9uIGZ1bnMoc3RtdHMpIHtcclxuICAgIHJldHVybiBzdG10cy5maWx0ZXIoZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudGFnID09PSBcImRlZmluZVwiOyB9KTtcclxufVxyXG5mdW5jdGlvbiBub25GdW5zKHN0bXRzKSB7XHJcbiAgICByZXR1cm4gc3RtdHMuZmlsdGVyKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnRhZyAhPT0gXCJkZWZpbmVcIjsgfSk7XHJcbn1cclxuZnVuY3Rpb24gdmFyc0Z1bnNTdG10cyhzdG10cykge1xyXG4gICAgcmV0dXJuIFt2YXJpYWJsZU5hbWVzKHN0bXRzKSwgZnVucyhzdG10cyksIG5vbkZ1bnMoc3RtdHMpXTtcclxufVxyXG5mdW5jdGlvbiBydW4od2F0U291cmNlLCBjb25maWcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgd2FidEFwaSwgcGFyc2VkLCBiaW5hcnksIHdhc21Nb2R1bGU7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHdhYnRfMS5kZWZhdWx0KCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHdhYnRBcGkgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gd2FidEFwaS5wYXJzZVdhdChcImV4YW1wbGVcIiwgd2F0U291cmNlKTtcclxuICAgICAgICAgICAgICAgICAgICBiaW5hcnkgPSBwYXJzZWQudG9CaW5hcnkoe30pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeS5idWZmZXIsIGNvbmZpZyldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHdhc21Nb2R1bGUgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHdhc21Nb2R1bGUuaW5zdGFuY2UuZXhwb3J0cy5fc3RhcnQoKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMucnVuID0gcnVuO1xyXG5mdW5jdGlvbiBvcFN0bXRzKG9wKSB7XHJcbiAgICAvLysgfCAtIHwgKiB8IC8vIHwgJSB8ID09IHwgIT0gfCA8PSB8ID49IHwgPCB8ID4gfCBpcyAgXHJcbiAgICBzd2l0Y2ggKG9wKSB7XHJcbiAgICAgICAgY2FzZSBcIitcIjogcmV0dXJuIFtcImkzMi5hZGRcIl07XHJcbiAgICAgICAgY2FzZSBcIi1cIjogcmV0dXJuIFtcImkzMi5zdWJcIl07XHJcbiAgICAgICAgY2FzZSBcIipcIjogcmV0dXJuIFtcImkzMi5tdWxcIl07XHJcbiAgICAgICAgY2FzZSBcIi8vXCI6IHJldHVybiBbXCJpMzIuZGl2X3NcIl07XHJcbiAgICAgICAgY2FzZSBcIiVcIjogcmV0dXJuIFtcImkzMi5yZW1fc1wiXTtcclxuICAgICAgICBjYXNlIFwiPT1cIjogcmV0dXJuIFtcImkzMi5lcVwiXTtcclxuICAgICAgICBjYXNlIFwiIT1cIjogcmV0dXJuIFtcImkzMi5uZVwiXTtcclxuICAgICAgICBjYXNlIFwiPD1cIjogcmV0dXJuIFtcImkzMi5sZV9zXCJdO1xyXG4gICAgICAgIGNhc2UgXCI+PVwiOiByZXR1cm4gW1wiaTMyLmdlX3NcIl07XHJcbiAgICAgICAgY2FzZSBcIjxcIjogcmV0dXJuIFtcImkzMi5sdF9zXCJdO1xyXG4gICAgICAgIGNhc2UgXCI+XCI6IHJldHVybiBbXCJpMzIuZ3Rfc1wiXTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmhhbmRsZWQgb3IgdW5rbm93biBvcDogXCIgKyBvcCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5vcFN0bXRzID0gb3BTdG10cztcclxuZnVuY3Rpb24gdW9wU3RtdHModW9wLCBvcHJkQ29kZSkge1xyXG4gICAgc3dpdGNoICh1b3ApIHtcclxuICAgICAgICBjYXNlIFwibm90XCI6IHJldHVybiBfX3NwcmVhZEFycmF5cyhvcHJkQ29kZSwgW1wiaTMyLmVxelwiXSk7XHJcbiAgICAgICAgY2FzZSBcIi1cIjogcmV0dXJuIF9fc3ByZWFkQXJyYXlzKFtcIihpMzIuY29uc3QgMClcIl0sIG9wcmRDb2RlLCBbXCJpMzIuc3ViXCJdKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnVvcFN0bXRzID0gdW9wU3RtdHM7XHJcbmZ1bmN0aW9uIGNvZGVHZW5FeHByKGV4cHIsIGxvY2Fscykge1xyXG4gICAgc3dpdGNoIChleHByLnRhZykge1xyXG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjogcmV0dXJuIFtcIihpMzIuY29uc3QgXCIgKyBleHByLnZhbHVlICsgXCIpXCJdO1xyXG4gICAgICAgIGNhc2UgXCJ0cnVlXCI6IHJldHVybiBbXCIoaTMyLmNvbnN0IDEpXCJdO1xyXG4gICAgICAgIGNhc2UgXCJmYWxzZVwiOiByZXR1cm4gW1wiKGkzMi5jb25zdCAwKVwiXTtcclxuICAgICAgICBjYXNlIFwiaWRcIjpcclxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgdHlwZS1jaGVja2VkIGZvciBtYWtpbmcgc3VyZSBhbGwgdmFyaWFibGUgZXhpc3QsIGhlcmUgd2VcclxuICAgICAgICAgICAgLy8ganVzdCBjaGVjayBpZiBpdCdzIGEgbG9jYWwgdmFyaWFibGUgYW5kIGFzc3VtZSBpdCBpcyBnbG9iYWwgaWYgbm90XHJcbiAgICAgICAgICAgIGlmIChsb2NhbHMuaGFzKGV4cHIubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXCIobG9jYWwuZ2V0ICRcIiArIGV4cHIubmFtZSArIFwiKVwiXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXCIoZ2xvYmFsLmdldCAkXCIgKyBleHByLm5hbWUgKyBcIilcIl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiYmlub3BcIjoge1xyXG4gICAgICAgICAgICB2YXIgbGhzRXhwcnMgPSBjb2RlR2VuRXhwcihleHByLmxocywgbG9jYWxzKTtcclxuICAgICAgICAgICAgdmFyIHJoc0V4cHJzID0gY29kZUdlbkV4cHIoZXhwci5yaHMsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgIHZhciBvcHN0bXRzID0gb3BTdG10cyhleHByLm9wKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXlzKGxoc0V4cHJzLCByaHNFeHBycywgb3BzdG10cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJ1bmlvcFwiOiB7XHJcbiAgICAgICAgICAgIHZhciBvcHJkRXhwcnMgPSBjb2RlR2VuRXhwcihleHByLm9wcmQsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgIHZhciB1b3BzdG10cyA9IHVvcFN0bXRzKGV4cHIudW9wLCBvcHJkRXhwcnMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdW9wc3RtdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJwYXJlbnRoZXNpemVkXCI6IHtcclxuICAgICAgICAgICAgdmFyIGNvbnRFeHByID0gY29kZUdlbkV4cHIoZXhwci5jb250ZW50LCBsb2NhbHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29udEV4cHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJjYWxsXCI6XHJcbiAgICAgICAgICAgIHZhciB2YWxTdG10cyA9IGV4cHIuYXJncy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNvZGVHZW5FeHByKGUsIGxvY2Fscyk7IH0pLmZsYXQoKTtcclxuICAgICAgICAgICAgdmFyIHRvQ2FsbCA9IGV4cHIubmFtZTtcclxuICAgICAgICAgICAgaWYgKGV4cHIubmFtZSA9PT0gXCJwcmludFwiKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHIuYXJnc1swXS5hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9DYWxsID0gXCJwcmludF9ib29sXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9DYWxsID0gXCJwcmludF9udW1cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9DYWxsID0gXCJwcmludF9ub25lXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbFN0bXRzLnB1c2goXCIoY2FsbCAkXCIgKyB0b0NhbGwgKyBcIilcIik7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWxTdG10cztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNvZGVHZW5FeHByID0gY29kZUdlbkV4cHI7XHJcbmZ1bmN0aW9uIGNvZGVHZW5TdG10KHN0bXQsIGxvY2Fscykge1xyXG4gICAgc3dpdGNoIChzdG10LnRhZykge1xyXG4gICAgICAgIGNhc2UgXCJkZWZpbmVcIjpcclxuICAgICAgICAgICAgdmFyIHdpdGhQYXJhbXNBbmRWYXJpYWJsZXNfMSA9IG5ldyBNYXAobG9jYWxzLmVudHJpZXMoKSk7XHJcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgZW52aXJvbm1lbnQgZm9yIHRoZSBmdW5jdGlvbiBib2R5XHJcbiAgICAgICAgICAgIHZhciB2YXJpYWJsZXMgPSB2YXJpYWJsZU5hbWVzKHN0bXQuYm9keSk7XHJcbiAgICAgICAgICAgIHZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiB3aXRoUGFyYW1zQW5kVmFyaWFibGVzXzEuc2V0KHYsIHRydWUpOyB9KTtcclxuICAgICAgICAgICAgc3RtdC5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gd2l0aFBhcmFtc0FuZFZhcmlhYmxlc18xLnNldChwLm5hbWUsIHRydWUpOyB9KTtcclxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBjb2RlIGZvciBwYXJhbXMgYW5kIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBpbiB0aGUgYm9keVxyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gc3RtdC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBcIihwYXJhbSAkXCIgKyBwLm5hbWUgKyBcIiBpMzIpXCI7IH0pLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgICAgICB2YXIgdmFyRGVjbHMgPSB2YXJpYWJsZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBcIihsb2NhbCAkXCIgKyB2ICsgXCIgaTMyKVwiOyB9KS5qb2luKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICB2YXIgc3RtdHMgPSBzdG10LmJvZHkubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBjb2RlR2VuU3RtdChzLCB3aXRoUGFyYW1zQW5kVmFyaWFibGVzXzEpOyB9KS5mbGF0KCk7XHJcbiAgICAgICAgICAgIHZhciBzdG10c0JvZHkgPSBzdG10cy5qb2luKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gW1wiKGZ1bmMgJFwiICsgc3RtdC5uYW1lICsgXCIgXCIgKyBwYXJhbXMgKyBcIiAocmVzdWx0IGkzMilcXG4gICAgICAgIChsb2NhbCAkc2NyYXRjaCBpMzIpXFxuICAgICAgICBcIiArIHZhckRlY2xzICsgXCJcXG4gICAgICAgIFwiICsgc3RtdHNCb2R5ICsgXCJcXG4gICAgICAgIChpMzIuY29uc3QgMCkpXCJdO1xyXG4gICAgICAgIGNhc2UgXCJpZlwiOlxyXG4gICAgICAgICAgICB2YXIgaWZDb2RlID0gXCJcIjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG10Lmlmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25kID0gY29kZUdlbkV4cHIoc3RtdC5pZnNbaV0uY29uZGl0aW9uLCBsb2NhbHMpLmZsYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZENvZGUgPSBjb25kLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlmYm9keSA9IHN0bXQuaWZzW2ldLmJvZHkubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBjb2RlR2VuU3RtdChzLCB3aXRoUGFyYW1zQW5kVmFyaWFibGVzXzEpOyB9KS5mbGF0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlDb2RlID0gaWZib2R5LmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4aWZDb2RlID0gKFwiXFxuICAgICAgICAgIFwiICsgY29uZENvZGUgKyBcIlxcbiAgICAgICAgICAoaWZcXG5cXG4gICAgICAgICAgICAodGhlblxcblxcbiAgICAgICAgICAgICAgXCIgKyBib2R5Q29kZSArIFwiXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgICBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWZDb2RlID0gW2lmQ29kZSwgZXhpZkNvZGVdLmZsYXQoKS5qb2luKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmQgPSBjb2RlR2VuRXhwcihzdG10Lmlmc1tpXS5jb25kaXRpb24sIGxvY2FscykuZmxhdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25kQ29kZSA9IGNvbmQuam9pbihcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWZib2R5ID0gc3RtdC5pZnNbaV0uYm9keS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIGNvZGVHZW5TdG10KHMsIHdpdGhQYXJhbXNBbmRWYXJpYWJsZXNfMSk7IH0pLmZsYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keUNvZGUgPSBpZmJvZHkuam9pbihcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhpZkNvZGUgPSAoXCJcXG4gICAgICAgICAgKGVsc2VcXG4gICAgICAgICAgXCIgKyBjb25kQ29kZSArIFwiXFxuICAgICAgICAgIChpZlxcbiAgICAgICAgICAodGhlblxcbiAgICAgICAgICAgIFwiICsgYm9keUNvZGUgKyBcIlxcbiAgICAgICAgICApXFxuICAgICAgICAgIFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZkNvZGUgPSBbaWZDb2RlLCBleGlmQ29kZV0uZmxhdCgpLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFwiZWxzZVwiIGluIHN0bXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbHNlYm9keSA9IHN0bXQuZWxzZS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIGNvZGVHZW5TdG10KHMsIHdpdGhQYXJhbXNBbmRWYXJpYWJsZXNfMSk7IH0pLmZsYXQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBib2R5Q29kZSA9IGVsc2Vib2R5LmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhpZkNvZGUgPSAoXCJcXG4gICAgICAgIChlbHNlXFxuICAgICAgICAgIFwiICsgYm9keUNvZGUgKyBcIlxcbiAgICAgICAgKVxcbiAgICAgICAgXCIpO1xyXG4gICAgICAgICAgICAgICAgaWZDb2RlID0gW2lmQ29kZSwgZXhpZkNvZGVdLmZsYXQoKS5qb2luKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmQ29kZSA9IFtpZkNvZGUsIFwiKVwiLnJlcGVhdChzdG10Lmlmcy5sZW5ndGggKiAyIC0gMiksIFwiKVwiXS5mbGF0KCkuam9pbihcIlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtpZkNvZGVdO1xyXG4gICAgICAgIGNhc2UgXCJ3aGlsZVwiOlxyXG4gICAgICAgICAgICB2YXIgbG9vcGxhYmVsID0gXCJsb29wXCIgKyBMb29wTGFiZWwudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdmFyIGJsb2NrbGFiZWwgPSBcImJsb2NrXCIgKyBMb29wTGFiZWwudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdmFyIHdoaWxlY29uZCA9IGNvZGVHZW5FeHByKHN0bXQuY29uZGl0aW9uLCBsb2NhbHMpLmZsYXQoKTtcclxuICAgICAgICAgICAgdmFyIHdoaWxlY29uZENvZGUgPSB3aGlsZWNvbmQuam9pbihcIlxcblwiKTtcclxuICAgICAgICAgICAgdmFyIHdoaWxlYm9keSA9IHN0bXQuYm9keS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIGNvZGVHZW5TdG10KHMsIGxvY2Fscyk7IH0pLmZsYXQoKTtcclxuICAgICAgICAgICAgdmFyIHdoaWxlYm9keUNvZGUgPSB3aGlsZWJvZHkuam9pbihcIlxcblwiKTtcclxuICAgICAgICAgICAgdmFyIHdoaWxlQ29kZSA9IFwiXFxuICAgICAgKGJsb2NrICRcIiArIGJsb2NrbGFiZWwgKyBcIlxcbiAgICAgICAgKGxvb3AgJFwiICsgbG9vcGxhYmVsICsgXCJcXG4gICAgICAgICAgXCIgKyB3aGlsZWNvbmRDb2RlICsgXCJcXG4gICAgICAgICAgaTMyLmVxelxcbiAgICAgICAgICBicl9pZiAkXCIgKyBibG9ja2xhYmVsICsgXCJcXG4gICAgICAgICAgXCIgKyB3aGlsZWJvZHlDb2RlICsgXCJcXG4gICAgICAgICAgYnIgJFwiICsgbG9vcGxhYmVsICsgXCJcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgICAgXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBbd2hpbGVDb2RlXTtcclxuICAgICAgICBjYXNlIFwicmV0dXJuXCI6XHJcbiAgICAgICAgICAgIHZhciB2YWxTdG10cyA9IGNvZGVHZW5FeHByKHN0bXQudmFsdWUsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgIHZhbFN0bXRzLnB1c2goXCJyZXR1cm5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWxTdG10cztcclxuICAgICAgICBjYXNlIFwiYXNzaWduXCI6XHJcbiAgICAgICAgICAgIHZhciB2YWxTdG10cyA9IGNvZGVHZW5FeHByKHN0bXQudmFsdWUsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbHMuaGFzKHN0bXQubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbFN0bXRzLnB1c2goXCIobG9jYWwuc2V0ICRcIiArIHN0bXQubmFtZSArIFwiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbFN0bXRzLnB1c2goXCIoZ2xvYmFsLnNldCAkXCIgKyBzdG10Lm5hbWUgKyBcIilcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbFN0bXRzO1xyXG4gICAgICAgIGNhc2UgXCJ2YXJkZWZcIjpcclxuICAgICAgICAgICAgdmFyIHZhbFN0bXRzID0gY29kZUdlbkV4cHIoc3RtdC52YWx1ZSwgbG9jYWxzKTtcclxuICAgICAgICAgICAgaWYgKGxvY2Fscy5oYXMoc3RtdC5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsU3RtdHMucHVzaChcIihsb2NhbC5zZXQgJFwiICsgc3RtdC5uYW1lICsgXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsU3RtdHMucHVzaChcIihnbG9iYWwuc2V0ICRcIiArIHN0bXQubmFtZSArIFwiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsU3RtdHM7XHJcbiAgICAgICAgY2FzZSBcImV4cHJcIjpcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvZGVHZW5FeHByKHN0bXQuZXhwciwgbG9jYWxzKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCIobG9jYWwuc2V0ICRzY3JhdGNoKVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNvZGVHZW5TdG10ID0gY29kZUdlblN0bXQ7XHJcbmZ1bmN0aW9uIGNvbXBpbGUoc291cmNlKSB7XHJcbiAgICB2YXIgYXN0ID0gcGFyc2VyXzEucGFyc2VQcm9ncmFtKHNvdXJjZSk7XHJcbiAgICBhc3QgPSB0Y18xLnRjUHJvZ3JhbShhc3QpO1xyXG4gICAgdmFyIGVtcHR5RW52ID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIF9hID0gdmFyc0Z1bnNTdG10cyhhc3QpLCB2YXJzID0gX2FbMF0sIGZ1bnMgPSBfYVsxXSwgc3RtdHMgPSBfYVsyXTtcclxuICAgIHZhciBmdW5zQ29kZSA9IGZ1bnMubWFwKGZ1bmN0aW9uIChmKSB7IHJldHVybiBjb2RlR2VuU3RtdChmLCBlbXB0eUVudik7IH0pLm1hcChmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5qb2luKFwiXFxuXCIpOyB9KTtcclxuICAgIHZhciBhbGxGdW5zID0gZnVuc0NvZGUuam9pbihcIlxcblxcblwiKTtcclxuICAgIHZhciB2YXJEZWNscyA9IHZhcnMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBcIihnbG9iYWwgJFwiICsgdiArIFwiIChtdXQgaTMyKSAoaTMyLmNvbnN0IDApKVwiOyB9KS5qb2luKFwiXFxuXCIpO1xyXG4gICAgdmFyIGFsbFN0bXRzID0gc3RtdHMubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBjb2RlR2VuU3RtdChzLCBlbXB0eUVudik7IH0pLmZsYXQoKTtcclxuICAgIHZhciBtYWluID0gX19zcHJlYWRBcnJheXMoW1wiKGxvY2FsICRzY3JhdGNoIGkzMilcIl0sIGFsbFN0bXRzKS5qb2luKFwiXFxuXCIpO1xyXG4gICAgdmFyIGxhc3RTdG10ID0gYXN0W2FzdC5sZW5ndGggLSAxXTtcclxuICAgIHZhciBpc0V4cHIgPSBsYXN0U3RtdC50YWcgPT09IFwiZXhwclwiO1xyXG4gICAgdmFyIHJldFR5cGUgPSBcIlwiO1xyXG4gICAgdmFyIHJldFZhbCA9IFwiXCI7XHJcbiAgICBpZiAoaXNFeHByKSB7XHJcbiAgICAgICAgcmV0VHlwZSA9IFwiKHJlc3VsdCBpMzIpXCI7XHJcbiAgICAgICAgcmV0VmFsID0gXCIobG9jYWwuZ2V0ICRzY3JhdGNoKVwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiXFxuICAgIChtb2R1bGVcXG4gICAgICAoZnVuYyAkcHJpbnRfbnVtIChpbXBvcnQgXFxcImltcG9ydHNcXFwiIFxcXCJwcmludF9udW1cXFwiKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXFxuICAgICAgKGZ1bmMgJHByaW50X2Jvb2wgKGltcG9ydCBcXFwiaW1wb3J0c1xcXCIgXFxcInByaW50X2Jvb2xcXFwiKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXFxuICAgICAgKGZ1bmMgJHByaW50X25vbmUgKGltcG9ydCBcXFwiaW1wb3J0c1xcXCIgXFxcInByaW50X25vbmVcXFwiKSAgKHJlc3VsdCBpMzIpKVxcbiAgICAgIFwiICsgdmFyRGVjbHMgKyBcIlxcbiAgICAgIFwiICsgYWxsRnVucyArIFwiXFxuICAgICAgKGZ1bmMgKGV4cG9ydCBcXFwiX3N0YXJ0XFxcIikgXCIgKyByZXRUeXBlICsgXCJcXG4gICAgICAgIFwiICsgbWFpbiArIFwiXFxuICAgICAgICBcIiArIHJldFZhbCArIFwiXFxuICAgICAgKVxcbiAgICApIFxcbiAgXCI7XHJcbn1cclxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy50cmF2ZXJzZUFyZ3VtZW50cyA9IGV4cG9ydHMudHJhdmVyc2VFeHByID0gZXhwb3J0cy50cmF2ZXJzZVBhcmFtZXRlcnMgPSBleHBvcnRzLnRyYXZlcnNlVHlwZSA9IGV4cG9ydHMudHJhdmVyc2VBc3NpZ25tZW50ID0gZXhwb3J0cy50cmF2ZXJzZUJvZHkgPSBleHBvcnRzLnRyYXZlcnNlSWYgPSBleHBvcnRzLnRyYXZlcnNlU3RtdCA9IGV4cG9ydHMudHJhdmVyc2VTdG10cyA9IGV4cG9ydHMucGFyc2VQcm9ncmFtID0gdm9pZCAwO1xyXG52YXIgbGV6ZXJfcHl0aG9uXzEgPSByZXF1aXJlKFwibGV6ZXItcHl0aG9uXCIpO1xyXG52YXIgYXN0XzEgPSByZXF1aXJlKFwiLi9hc3RcIik7XHJcbmZ1bmN0aW9uIHBhcnNlUHJvZ3JhbShzb3VyY2UpIHtcclxuICAgIHZhciB0ID0gbGV6ZXJfcHl0aG9uXzEucGFyc2VyLnBhcnNlKHNvdXJjZSkuY3Vyc29yKCk7XHJcbiAgICByZXR1cm4gdHJhdmVyc2VTdG10cyhzb3VyY2UsIHQpO1xyXG59XHJcbmV4cG9ydHMucGFyc2VQcm9ncmFtID0gcGFyc2VQcm9ncmFtO1xyXG5mdW5jdGlvbiB0cmF2ZXJzZVN0bXRzKHMsIHQpIHtcclxuICAgIC8vIFRoZSB0b3Agbm9kZSBpbiB0aGUgcHJvZ3JhbSBpcyBhIFNjcmlwdCBub2RlIHdpdGggYSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAvLyB0aGF0IGFyZSB2YXJpb3VzIHN0YXRlbWVudHNcclxuICAgIHQuZmlyc3RDaGlsZCgpO1xyXG4gICAgdmFyIHN0bXRzID0gW107XHJcbiAgICBkbyB7XHJcbiAgICAgICAgc3RtdHMucHVzaCh0cmF2ZXJzZVN0bXQocywgdCkpO1xyXG4gICAgfSB3aGlsZSAodC5uZXh0U2libGluZygpKTsgLy8gdC5uZXh0U2libGluZygpIHJldHVybnMgZmFsc2Ugd2hlbiBpdCByZWFjaGVzXHJcbiAgICAvLyAgdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgcmV0dXJuIHN0bXRzO1xyXG59XHJcbmV4cG9ydHMudHJhdmVyc2VTdG10cyA9IHRyYXZlcnNlU3RtdHM7XHJcbi8qXHJcbiAgSW52YXJpYW50IOKAkyB0IG11c3QgZm9jdXMgb24gdGhlIHNhbWUgbm9kZSBhdCB0aGUgZW5kIG9mIHRoZSB0cmF2ZXJzYWxcclxuKi9cclxuZnVuY3Rpb24gdHJhdmVyc2VTdG10KHMsIHQpIHtcclxuICAgIHN3aXRjaCAodC50eXBlLm5hbWUpIHtcclxuICAgICAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XHJcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyByZXR1cm4ga2V5d29yZFxyXG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHJhdmVyc2VFeHByKHMsIHQpO1xyXG4gICAgICAgICAgICB0LnBhcmVudCgpO1xyXG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwicmV0dXJuXCIsIHZhbHVlOiB2YWx1ZSB9O1xyXG4gICAgICAgIGNhc2UgXCJBc3NpZ25TdGF0ZW1lbnRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlQXNzaWdubWVudChzLCB0KTtcclxuICAgICAgICBjYXNlIFwiSWZTdGF0ZW1lbnRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlSWYocywgdCk7XHJcbiAgICAgICAgY2FzZSBcIldoaWxlU3RhdGVtZW50XCI6XHJcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvL3doaWxlXHJcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy9jb25kaXRpb25cclxuICAgICAgICAgICAgdmFyIHdoaWxlY29uZGl0aW9uID0gdHJhdmVyc2VFeHByKHMsIHQpO1xyXG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vYm9keVxyXG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy86XHJcbiAgICAgICAgICAgIHZhciB3aGlsZWJvZHkgPSB0cmF2ZXJzZUJvZHkocywgdCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJ3aGlsZVwiLCBjb25kaXRpb246IHdoaWxlY29uZGl0aW9uLCBib2R5OiB3aGlsZWJvZHkgfTtcclxuICAgICAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxyXG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gVGhlIGNoaWxkIGlzIHNvbWUga2luZCBvZiBleHByZXNzaW9uLCB0aGVcclxuICAgICAgICAgICAgLy8gRXhwcmVzc2lvblN0YXRlbWVudCBpcyBqdXN0IGEgd3JhcHBlciB3aXRoIG5vIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgIHZhciBleHByID0gdHJhdmVyc2VFeHByKHMsIHQpO1xyXG4gICAgICAgICAgICB0LnBhcmVudCgpO1xyXG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiZXhwclwiLCBleHByOiBleHByIH07XHJcbiAgICAgICAgY2FzZSBcIkZ1bmN0aW9uRGVmaW5pdGlvblwiOlxyXG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgb24gZGVmXHJcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gbmFtZSBvZiBmdW5jdGlvblxyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XHJcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gUGFyYW1MaXN0XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB0cmF2ZXJzZVBhcmFtZXRlcnMocywgdCk7XHJcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gQm9keSBvciBUeXBlRGVmXHJcbiAgICAgICAgICAgIHZhciByZXQgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgdmFyIG1heWJlVEQgPSB0O1xyXG4gICAgICAgICAgICBpZiAobWF5YmVURC50eXBlLm5hbWUgPT09IFwiVHlwZURlZlwiKSB7XHJcbiAgICAgICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTtcclxuICAgICAgICAgICAgICAgIHJldCA9IHRyYXZlcnNlVHlwZShzLCB0KTtcclxuICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBzaW5nbGUgc3RhdGVtZW50IChmb3Igbm93KVxyXG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgb24gOlxyXG4gICAgICAgICAgICB2YXIgYm9keSA9IFtdO1xyXG4gICAgICAgICAgICB3aGlsZSAodC5uZXh0U2libGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5LnB1c2godHJhdmVyc2VTdG10KHMsIHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0LnBhcmVudCgpOyAvLyBQb3AgdG8gQm9keVxyXG4gICAgICAgICAgICB0LnBhcmVudCgpOyAvLyBQb3AgdG8gRnVuY3Rpb25EZWZpbml0aW9uXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0YWc6IFwiZGVmaW5lXCIsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLCBwYXJhbXM6IHBhcmFtcywgYm9keTogYm9keSwgcmV0OiByZXRcclxuICAgICAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnRyYXZlcnNlU3RtdCA9IHRyYXZlcnNlU3RtdDtcclxuZnVuY3Rpb24gdHJhdmVyc2VJZihzLCB0KSB7XHJcbiAgICB2YXIgdmlmcyA9IFtdO1xyXG4gICAgdC5maXJzdENoaWxkKCk7XHJcbiAgICBkbyB7XHJcbiAgICAgICAgaWYgKHQudHlwZS5uYW1lID09IFwiZWxzZVwiKSB7XHJcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTtcclxuICAgICAgICAgICAgdmFyIGVib2R5ID0gdHJhdmVyc2VCb2R5KHMsIHQpO1xyXG4gICAgICAgICAgICB0LnBhcmVudCgpO1xyXG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiaWZcIiwgaWZzOiB2aWZzLCBlbHNlOiBlYm9keSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0LnR5cGUubmFtZSA9PSBcImVsaWZcIiB8fCB0LnR5cGUubmFtZSA9PSBcImlmXCIpIHtcclxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xyXG4gICAgICAgICAgICB2YXIgY29uZCA9IHRyYXZlcnNlRXhwcihzLCB0KTtcclxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IHRyYXZlcnNlQm9keShzLCB0KTtcclxuICAgICAgICAgICAgdmFyIGN1cmlmID0geyB0YWc6IFwic3ViaWZcIiwgY29uZGl0aW9uOiBjb25kLCBib2R5OiBib2R5IH07XHJcbiAgICAgICAgICAgIHZpZnMucHVzaChjdXJpZik7XHJcbiAgICAgICAgfVxyXG4gICAgfSB3aGlsZSAodC5uZXh0U2libGluZygpKTtcclxuICAgIHQucGFyZW50KCk7XHJcbiAgICByZXR1cm4geyB0YWc6IFwiaWZcIiwgaWZzOiB2aWZzIH07XHJcbn1cclxuZXhwb3J0cy50cmF2ZXJzZUlmID0gdHJhdmVyc2VJZjtcclxuZnVuY3Rpb24gdHJhdmVyc2VCb2R5KHMsIHQpIHtcclxuICAgIHQuZmlyc3RDaGlsZCgpO1xyXG4gICAgdC5uZXh0U2libGluZygpO1xyXG4gICAgdmFyIHN0bXRzID0gW107XHJcbiAgICBkbyB7XHJcbiAgICAgICAgc3RtdHMucHVzaCh0cmF2ZXJzZVN0bXQocywgdCkpO1xyXG4gICAgfSB3aGlsZSAodC5uZXh0U2libGluZygpKTsgLy8gdC5uZXh0U2libGluZygpIHJldHVybnMgZmFsc2Ugd2hlbiBpdCByZWFjaGVzXHJcbiAgICAvLyAgdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgdC5wYXJlbnQoKTtcclxuICAgIHJldHVybiBzdG10cztcclxufVxyXG5leHBvcnRzLnRyYXZlcnNlQm9keSA9IHRyYXZlcnNlQm9keTtcclxuZnVuY3Rpb24gdHJhdmVyc2VBc3NpZ25tZW50KHMsIHQpIHtcclxuICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBmb2N1c2VkIG9uIG5hbWUgKHRoZSBmaXJzdCBjaGlsZClcclxuICAgIHZhciBuYW1lID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcclxuICAgIHQubmV4dFNpYmxpbmcoKTtcclxuICAgIGlmICh0LnR5cGUubmFtZSA9PT0gXCJUeXBlRGVmXCIpIHtcclxuICAgICAgICB0LmZpcnN0Q2hpbGQoKTtcclxuICAgICAgICB0Lm5leHRTaWJsaW5nKCk7XHJcbiAgICAgICAgdmFyIHR5cGUgPSB0cmF2ZXJzZVR5cGUocywgdCk7XHJcbiAgICAgICAgdC5wYXJlbnQoKTtcclxuICAgICAgICB0Lm5leHRTaWJsaW5nKCk7XHJcbiAgICAgICAgdC5uZXh0U2libGluZygpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRyYXZlcnNlRXhwcihzLCB0KTtcclxuICAgICAgICB0LnBhcmVudCgpO1xyXG4gICAgICAgIHJldHVybiB7IHRhZzogXCJ2YXJkZWZcIiwgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCB0eXBlOiB0eXBlIH07XHJcbiAgICB9XHJcbiAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIGZvY3VzZWQgb24gdGhlIHZhbHVlIGV4cHJlc3Npb25cclxuICAgIHZhciB2YWx1ZSA9IHRyYXZlcnNlRXhwcihzLCB0KTtcclxuICAgIHQucGFyZW50KCk7XHJcbiAgICByZXR1cm4geyB0YWc6IFwiYXNzaWduXCIsIG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9O1xyXG59XHJcbmV4cG9ydHMudHJhdmVyc2VBc3NpZ25tZW50ID0gdHJhdmVyc2VBc3NpZ25tZW50O1xyXG5mdW5jdGlvbiB0cmF2ZXJzZVR5cGUocywgdCkge1xyXG4gICAgc3dpdGNoICh0LnR5cGUubmFtZSkge1xyXG4gICAgICAgIGNhc2UgXCJWYXJpYWJsZU5hbWVcIjpcclxuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XHJcbiAgICAgICAgICAgIGlmIChuYW1lXzEgIT0gXCJpbnRcIiAmJiBuYW1lXzEgIT0gXCJib29sXCIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyBuYW1lXzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lXzE7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIiArIHQudHlwZS5uYW1lKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnRyYXZlcnNlVHlwZSA9IHRyYXZlcnNlVHlwZTtcclxuZnVuY3Rpb24gdHJhdmVyc2VQYXJhbWV0ZXJzKHMsIHQpIHtcclxuICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1c2VzIG9uIG9wZW4gcGFyZW5cclxuICAgIHZhciBwYXJhbWV0ZXJzID0gW107XHJcbiAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gYSBWYXJpYWJsZU5hbWVcclxuICAgIHdoaWxlICh0LnR5cGUubmFtZSAhPT0gXCIpXCIpIHtcclxuICAgICAgICB2YXIgbmFtZV8yID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcclxuICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gXCJUeXBlRGVmXCIsIGhvcGVmdWxseSwgb3IgXCIsXCIgaWYgbWlzdGFrZVxyXG4gICAgICAgIHZhciBuZXh0VGFnTmFtZSA9IHQudHlwZS5uYW1lOyAvLyBOT1RFKGpvZSk6IGEgYml0IG9mIGEgaGFjayBzbyB0aGUgbmV4dCBsaW5lIGRvZXNuJ3QgaWYtc3BsaXRcclxuICAgICAgICBpZiAobmV4dFRhZ05hbWUgIT09IFwiVHlwZURlZlwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NlZCB0eXBlIGFubm90YXRpb24gZm9yIHBhcmFtZXRlciBcIiArIG5hbWVfMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRW50ZXIgVHlwZURlZlxyXG4gICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiB0eXBlIGl0c2VsZlxyXG4gICAgICAgIHZhciB0eXAgPSB0cmF2ZXJzZVR5cGUocywgdCk7XHJcbiAgICAgICAgdC5wYXJlbnQoKTtcclxuICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIE1vdmUgb24gdG8gY29tbWEgb3IgXCIpXCJcclxuICAgICAgICBwYXJhbWV0ZXJzLnB1c2goeyBuYW1lOiBuYW1lXzIsIHR5cDogdHlwIH0pO1xyXG4gICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiBhIFZhcmlhYmxlTmFtZVxyXG4gICAgfVxyXG4gICAgdC5wYXJlbnQoKTsgLy8gUG9wIHRvIFBhcmFtTGlzdFxyXG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XHJcbn1cclxuZXhwb3J0cy50cmF2ZXJzZVBhcmFtZXRlcnMgPSB0cmF2ZXJzZVBhcmFtZXRlcnM7XHJcbmZ1bmN0aW9uIHRyYXZlcnNlRXhwcihzLCB0KSB7XHJcbiAgICBzd2l0Y2ggKHQudHlwZS5uYW1lKSB7XHJcbiAgICAgICAgY2FzZSBcIkJvb2xlYW5cIjpcclxuICAgICAgICAgICAgaWYgKHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykgPT09IFwiVHJ1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0YWc6IFwidHJ1ZVwiIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiZmFsc2VcIiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIk51bWJlclwiOlxyXG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiBOdW1iZXIocy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKSkgfTtcclxuICAgICAgICBjYXNlIFwiTm9uZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwibm9uZVwiIH07XHJcbiAgICAgICAgY2FzZSBcIlZhcmlhYmxlTmFtZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiaWRcIiwgbmFtZTogcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKSB9O1xyXG4gICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxyXG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgbmFtZVxyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XHJcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgQXJnTGlzdFxyXG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgb3BlbiBwYXJlblxyXG4gICAgICAgICAgICB2YXIgYXJncyA9IHRyYXZlcnNlQXJndW1lbnRzKHQsIHMpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0geyB0YWc6IFwiY2FsbFwiLCBuYW1lOiBuYW1lLCBhcmdzOiBhcmdzIH07XHJcbiAgICAgICAgICAgIHQucGFyZW50KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSBcIkJpbmFyeUV4cHJlc3Npb25cIjpcclxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIGdvIHRvIGxoc1xyXG4gICAgICAgICAgICB2YXIgbGhzRXhwciA9IHRyYXZlcnNlRXhwcihzLCB0KTtcclxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBnbyB0byBvcFxyXG4gICAgICAgICAgICB2YXIgb3BTdHIgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xyXG4gICAgICAgICAgICBpZiAoIWFzdF8xLmlzT3Aob3BTdHIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yIHVuaGFuZGxlZCBiaW5hcnkgb3A6IFwiICsgb3BTdHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gZ28gdG8gcmhzXHJcbiAgICAgICAgICAgIHZhciByaHNFeHByID0gdHJhdmVyc2VFeHByKHMsIHQpO1xyXG4gICAgICAgICAgICB0LnBhcmVudCgpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdGFnOiBcImJpbm9wXCIsXHJcbiAgICAgICAgICAgICAgICBvcDogb3BTdHIsXHJcbiAgICAgICAgICAgICAgICBsaHM6IGxoc0V4cHIsXHJcbiAgICAgICAgICAgICAgICByaHM6IHJoc0V4cHJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcclxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7XHJcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTtcclxuICAgICAgICAgICAgdmFyIGNvbnQgPSB0cmF2ZXJzZUV4cHIocywgdCk7XHJcbiAgICAgICAgICAgIHQucGFyZW50KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0YWc6IFwicGFyZW50aGVzaXplZFwiLFxyXG4gICAgICAgICAgICAgICAgY29udGVudDogY29udFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcclxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIGdvIHRvIG9wXHJcbiAgICAgICAgICAgIHZhciB1b3BTdHIgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xyXG4gICAgICAgICAgICBpZiAoIWFzdF8xLmlzVW9wKHVvcFN0cikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3IgdW5oYW5kbGVkIHVuYXJ5IG9wOiBcIiArIHVvcFN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBnbyB0byBvcGVyYW5kXHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kID0gdHJhdmVyc2VFeHByKHMsIHQpO1xyXG4gICAgICAgICAgICB0LnBhcmVudCgpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdGFnOiBcInVuaW9wXCIsXHJcbiAgICAgICAgICAgICAgICB1b3A6IHVvcFN0cixcclxuICAgICAgICAgICAgICAgIG9wcmQ6IG9wZXJhbmRcclxuICAgICAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnRyYXZlcnNlRXhwciA9IHRyYXZlcnNlRXhwcjtcclxuZnVuY3Rpb24gdHJhdmVyc2VBcmd1bWVudHMoYywgcykge1xyXG4gICAgYy5maXJzdENoaWxkKCk7IC8vIEZvY3VzZXMgb24gb3BlbiBwYXJlblxyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGMubmV4dFNpYmxpbmcoKTtcclxuICAgIHdoaWxlIChjLnR5cGUubmFtZSAhPT0gXCIpXCIpIHtcclxuICAgICAgICB2YXIgZXhwciA9IHRyYXZlcnNlRXhwcihzLCBjKTtcclxuICAgICAgICBhcmdzLnB1c2goZXhwcik7XHJcbiAgICAgICAgYy5uZXh0U2libGluZygpOyAvLyBGb2N1c2VzIG9uIGVpdGhlciBcIixcIiBvciBcIilcIlxyXG4gICAgICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiBhIFZhcmlhYmxlTmFtZVxyXG4gICAgfVxyXG4gICAgYy5wYXJlbnQoKTsgLy8gUG9wIHRvIEFyZ0xpc3RcclxuICAgIHJldHVybiBhcmdzO1xyXG59XHJcbmV4cG9ydHMudHJhdmVyc2VBcmd1bWVudHMgPSB0cmF2ZXJzZUFyZ3VtZW50cztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnRjUHJvZ3JhbSA9IGV4cG9ydHMudGNTdWJpZiA9IGV4cG9ydHMudGNTdG10ID0gZXhwb3J0cy50Y0V4cHIgPSB2b2lkIDA7XHJcbnZhciBhc3RfMSA9IHJlcXVpcmUoXCIuL2FzdFwiKTtcclxuZnVuY3Rpb24gdGNFeHByKGUsIGZ1bmN0aW9ucywgdmFyaWFibGVzKSB7XHJcbiAgICBzd2l0Y2ggKGUudGFnKSB7XHJcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOiByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwiaW50XCIgfSk7XHJcbiAgICAgICAgY2FzZSBcInRydWVcIjogcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImJvb2xcIiB9KTtcclxuICAgICAgICBjYXNlIFwiZmFsc2VcIjogcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImJvb2xcIiB9KTtcclxuICAgICAgICBjYXNlIFwibm9uZVwiOiByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwibm9uZVwiIH0pO1xyXG4gICAgICAgIGNhc2UgXCJiaW5vcFwiOiB7XHJcbiAgICAgICAgICAgIGUubGhzID0gdGNFeHByKGUubGhzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XHJcbiAgICAgICAgICAgIGUucmhzID0gdGNFeHByKGUucmhzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZS5vcCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIitcIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5saHMuYSAhPSBcImludFwiIHx8IGUucmhzLmEgIT0gXCJpbnRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIE9wZXJhbmRzIGZvciBcIiArIGUub3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwiaW50XCIgfSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiLVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmxocy5hICE9IFwiaW50XCIgfHwgZS5yaHMuYSAhPSBcImludFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgT3BlcmFuZHMgZm9yIFwiICsgZS5vcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJpbnRcIiB9KTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubGhzLmEgIT0gXCJpbnRcIiB8fCBlLnJocy5hICE9IFwiaW50XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBPcGVyYW5kcyBmb3IgXCIgKyBlLm9wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImludFwiIH0pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIi8vXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubGhzLmEgIT0gXCJpbnRcIiB8fCBlLnJocy5hICE9IFwiaW50XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBPcGVyYW5kcyBmb3IgXCIgKyBlLm9wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImludFwiIH0pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIiVcIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5saHMuYSAhPSBcImludFwiIHx8IGUucmhzLmEgIT0gXCJpbnRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIE9wZXJhbmRzIGZvciBcIiArIGUub3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwiaW50XCIgfSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiPT1cIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISgoZS5saHMuYSA9PSBcImludFwiICYmIGUucmhzLmEgPT0gXCJpbnRcIikgfHwgKGUubGhzLmEgPT0gXCJib29sXCIgJiYgZS5yaHMuYSA9PSBcImJvb2xcIikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgT3BlcmFuZHMgZm9yIFwiICsgZS5vcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJib29sXCIgfSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiIT1cIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISgoZS5saHMuYSA9PSBcImludFwiICYmIGUucmhzLmEgPT0gXCJpbnRcIikgfHwgKGUubGhzLmEgPT0gXCJib29sXCIgJiYgZS5yaHMuYSA9PSBcImJvb2xcIikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgT3BlcmFuZHMgZm9yIFwiICsgZS5vcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJib29sXCIgfSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiPD1cIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShlLmxocy5hID09IFwiaW50XCIgJiYgZS5yaHMuYSA9PSBcImludFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIE9wZXJhbmRzIGZvciBcIiArIGUub3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwiYm9vbFwiIH0pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIj49XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZS5saHMuYSA9PSBcImludFwiICYmIGUucmhzLmEgPT0gXCJpbnRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBPcGVyYW5kcyBmb3IgXCIgKyBlLm9wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImJvb2xcIiB9KTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZS5saHMuYSA9PSBcImludFwiICYmIGUucmhzLmEgPT0gXCJpbnRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBPcGVyYW5kcyBmb3IgXCIgKyBlLm9wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImJvb2xcIiB9KTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCI+XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZS5saHMuYSA9PSBcImludFwiICYmIGUucmhzLmEgPT0gXCJpbnRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBPcGVyYW5kcyBmb3IgXCIgKyBlLm9wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiBcImJvb2xcIiB9KTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIlVuaGFuZGxlZCBvcCBcIiArIGUub3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJ1bmlvcFwiOiB7XHJcbiAgICAgICAgICAgIGUub3ByZCA9IHRjRXhwcihlLm9wcmQsIGZ1bmN0aW9ucywgdmFyaWFibGVzKTtcclxuICAgICAgICAgICAgc3dpdGNoIChlLnVvcCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm9wcmQuYSAhPSBcImJvb2xcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIE9wZXJhbmQgZm9yIFwiICsgZS51b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwiYm9vbFwiIH0pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIi1cIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcHJkLmEgIT0gXCJpbnRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIE9wZXJhbmQgZm9yIFwiICsgZS51b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IFwiaW50XCIgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcInBhcmVudGhlc2l6ZWRcIjoge1xyXG4gICAgICAgICAgICBlLmNvbnRlbnQgPSB0Y0V4cHIoZS5jb250ZW50LCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogZS5jb250ZW50LmEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJpZFwiOiByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGE6IHZhcmlhYmxlcy5nZXQoZS5uYW1lKSB9KTtcclxuICAgICAgICBjYXNlIFwiY2FsbFwiOlxyXG4gICAgICAgICAgICBpZiAoZS5uYW1lID09PSBcInByaW50XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmFyZ3MubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJpbnQgZXhwZWN0cyBhIHNpbmdsZSBhcmd1bWVudFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBuZXdBcmdzXzEgPSBbdGNFeHByKGUuYXJnc1swXSwgZnVuY3Rpb25zLCB2YXJpYWJsZXMpXTtcclxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgYTogXCJub25lXCIsIGFyZ3M6IG5ld0FyZ3NfMSB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFmdW5jdGlvbnMuaGFzKGUubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZ1bmN0aW9uIFwiICsgZS5uYW1lICsgXCIgbm90IGZvdW5kXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfYSA9IGZ1bmN0aW9ucy5nZXQoZS5uYW1lKSwgYXJncyA9IF9hWzBdLCByZXQgPSBfYVsxXTtcclxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBlLmFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIiArIGFyZ3MubGVuZ3RoICsgXCIgYXJndW1lbnRzIGJ1dCBnb3QgXCIgKyBlLmFyZ3MubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV3QXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJndHlwID0gdGNFeHByKGUuYXJnc1tpXSwgZnVuY3Rpb25zLCB2YXJpYWJsZXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgIT09IGFyZ3R5cC5hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR290IFwiICsgYXJndHlwICsgXCIgYXMgYXJndW1lbnQgXCIgKyAoaSArIDEpICsgXCIsIGV4cGVjdGVkIFwiICsgYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndHlwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBhOiByZXQsIGFyZ3M6IG5ld0FyZ3MgfSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy50Y0V4cHIgPSB0Y0V4cHI7XHJcbmZ1bmN0aW9uIHRjU3RtdChzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcywgY3VycmVudFJldHVybikge1xyXG4gICAgdmFyIGxvY2FsdmFyaWFibGVzID0gbmV3IE1hcCgpO1xyXG4gICAgc3dpdGNoIChzLnRhZykge1xyXG4gICAgICAgIGNhc2UgXCJ2YXJkZWZcIjoge1xyXG4gICAgICAgICAgICBpZiAoIWFzdF8xLmlzTGl0ZXJhbChzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFzc2lnbiBub24gbGl0ZXJhbCBpbiB2YXJpYWJsZSBkZWZpbml0aW9uXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByaHMgPSB0Y0V4cHIocy52YWx1ZSwgZnVuY3Rpb25zLCB2YXJpYWJsZXMpO1xyXG4gICAgICAgICAgICBpZiAocmhzLmEgIT0gcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXNzaWduIFwiICsgcmhzICsgXCIgdG8gdHlwZSBcIiArIHMudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYWx2YXJpYWJsZXMuaGFzKHMubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgZGVmaW5pdGlvbiBvZiBcIiArIHMubmFtZSArIFwiIGluIHNhbWUgc2NvcGVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsb2NhbHZhcmlhYmxlcy5zZXQocy5uYW1lLCBzLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzLnNldChzLm5hbWUsIHMudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzKSwgeyB2YWx1ZTogcmhzIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiYXNzaWduXCI6IHtcclxuICAgICAgICAgICAgdmFyIHJocyA9IHRjRXhwcihzLnZhbHVlLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XHJcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZXMuaGFzKHMubmFtZSkgJiYgdmFyaWFibGVzLmdldChzLm5hbWUpICE9PSByaHMuYSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFzc2lnbiBcIiArIHJocyArIFwiIHRvIFwiICsgdmFyaWFibGVzLmdldChzLm5hbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdmFyaWFibGVzLmhhcyhzLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NpZ25tZW50IGJlZm9yZSBkZWZpbml0aW9uIFwiICsgcy5uYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHMpLCB7IHZhbHVlOiByaHMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJkZWZpbmVcIjoge1xyXG4gICAgICAgICAgICB2YXIgYm9keXZhcnNfMSA9IG5ldyBNYXAodmFyaWFibGVzLmVudHJpZXMoKSk7XHJcbiAgICAgICAgICAgIHMucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHApIHsgYm9keXZhcnNfMS5zZXQocC5uYW1lLCBwLnR5cCk7IH0pO1xyXG4gICAgICAgICAgICB2YXIgbmV3U3RtdHMgPSBzLmJvZHkubWFwKGZ1bmN0aW9uIChicykgeyByZXR1cm4gdGNTdG10KGJzLCBmdW5jdGlvbnMsIGJvZHl2YXJzXzEsIHMucmV0KTsgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcyksIHsgYm9keTogbmV3U3RtdHMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJpZlwiOiB7XHJcbiAgICAgICAgICAgIHZhciBuZXdpZnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHMuaWZzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBuZXdpZnMucHVzaCh0Y1N1YmlmKGksIGZ1bmN0aW9ucywgdmFyaWFibGVzLCBjdXJyZW50UmV0dXJuKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCdlbHNlJyBpbiBzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3ZWxzZSA9IHMuZWxzZS5tYXAoZnVuY3Rpb24gKGJzKSB7IHJldHVybiB0Y1N0bXQoYnMsIGZ1bmN0aW9ucywgdmFyaWFibGVzLCBjdXJyZW50UmV0dXJuKTsgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHMpLCB7IGlmczogbmV3aWZzLCBlbHNlOiBuZXdlbHNlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcyksIHsgaWZzOiBuZXdpZnMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJ3aGlsZVwiOiB7XHJcbiAgICAgICAgICAgIHZhciBuZXdib2R5ID0gcy5ib2R5Lm1hcChmdW5jdGlvbiAoYnMpIHsgcmV0dXJuIHRjU3RtdChicywgZnVuY3Rpb25zLCB2YXJpYWJsZXMsIGN1cnJlbnRSZXR1cm4pOyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzKSwgeyBjb25kaXRpb246IHRjRXhwcihzLmNvbmRpdGlvbiwgZnVuY3Rpb25zLCB2YXJpYWJsZXMpLCBib2R5OiBuZXdib2R5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiZXhwclwiOiB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSB0Y0V4cHIocy5leHByLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcyksIHsgZXhwcjogcmV0IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwicmV0dXJuXCI6IHtcclxuICAgICAgICAgICAgdmFyIHZhbFR5cCA9IHRjRXhwcihzLnZhbHVlLCBmdW5jdGlvbnMsIHZhcmlhYmxlcyk7XHJcbiAgICAgICAgICAgIGlmICh2YWxUeXAuYSAhPT0gY3VycmVudFJldHVybikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbFR5cCArIFwiIHJldHVybmVkIGJ1dCBcIiArIGN1cnJlbnRSZXR1cm4gKyBcIiBleHBlY3RlZC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzKSwgeyB2YWx1ZTogdmFsVHlwIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLnRjU3RtdCA9IHRjU3RtdDtcclxuZnVuY3Rpb24gdGNTdWJpZihpLCBmdW5jdGlvbnMsIHZhcmlhYmxlcywgY3VycmVudFJldHVybikge1xyXG4gICAgaS5jb25kaXRpb24gPSB0Y0V4cHIoaS5jb25kaXRpb24sIGZ1bmN0aW9ucywgdmFyaWFibGVzKTtcclxuICAgIGlmIChpLmNvbmRpdGlvbi5hICE9IFwiYm9vbFwiKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZGl0aW9uYWwgc3RhdGVtZW50IG5vdCB0eXBlZCBib29sZWFuXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIG5ld2JvZHkgPSBpLmJvZHkubWFwKGZ1bmN0aW9uIChicykgeyByZXR1cm4gdGNTdG10KGJzLCBmdW5jdGlvbnMsIHZhcmlhYmxlcywgY3VycmVudFJldHVybik7IH0pO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGkuYm9keTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgaXN0bXQgPSBfYVtfaV07XHJcbiAgICAgICAgaWYgKGlzdG10LnRhZyA9PSBcInZhcmRlZlwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlIGRlZmluaXRpb24gaW4gSWYgYmxvY2tcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBpKSwgeyBib2R5OiBuZXdib2R5IH0pO1xyXG59XHJcbmV4cG9ydHMudGNTdWJpZiA9IHRjU3ViaWY7XHJcbmZ1bmN0aW9uIHRjUHJvZ3JhbShwKSB7XHJcbiAgICB2YXIgZnVuY3Rpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgcC5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgaWYgKHMudGFnID09PSBcImRlZmluZVwiKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9ucy5zZXQocy5uYW1lLCBbcy5wYXJhbXMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnR5cDsgfSksIHMucmV0XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgZ2xvYmFscyA9IG5ldyBNYXAoKTtcclxuICAgIHJldHVybiBwLm1hcChmdW5jdGlvbiAocykge1xyXG4gICAgICAgIGlmIChzLnRhZyA9PT0gXCJ2YXJkZWZcIikge1xyXG4gICAgICAgICAgICBpZiAoIWFzdF8xLmlzTGl0ZXJhbChzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFzc2lnbiBub24gbGl0ZXJhbCBpbiB2YXJpYWJsZSBkZWZpbml0aW9uXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByaHMgPSB0Y0V4cHIocy52YWx1ZSwgZnVuY3Rpb25zLCBnbG9iYWxzKTtcclxuICAgICAgICAgICAgaWYgKHJocy5hICE9IHMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFzc2lnbiBcIiArIHJocyArIFwiIHRvIHR5cGUgXCIgKyBzLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbHMuaGFzKHMubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgZGVmaW5pdGlvbiBvZiBcIiArIHMubmFtZSArIFwiIGluIHNhbWUgc2NvcGVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2xvYmFscy5zZXQocy5uYW1lLCByaHMuYSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcyksIHsgdmFsdWU6IHJocyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0Y1N0bXQocywgZnVuY3Rpb25zLCBnbG9iYWxzLCBcIm5vbmVcIik7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy50Y1Byb2dyYW0gPSB0Y1Byb2dyYW07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGVyXCIpO1xyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gZGlzcGxheShhcmcpIHtcclxuICAgICAgICB2YXIgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm91dHB1dFwiKS5pbm5lclRleHQgPSBhcmc7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJMb2dnaW5nIGZyb20gV0FTTTogXCIsIGFyZyk7XHJcbiAgICB9XHJcbiAgICB2YXIgaW1wb3J0T2JqZWN0LCBydW5CdXR0b24sIHVzZXJDb2RlO1xyXG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIGltcG9ydE9iamVjdCA9IHtcclxuICAgICAgICAgICAgaW1wb3J0czoge1xyXG4gICAgICAgICAgICAgICAgcHJpbnRfbnVtOiBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2dnaW5nIGZyb20gV0FTTTogXCIsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheShTdHJpbmcoYXJnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwcmludF9ib29sOiBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5KFwiRmFsc2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5KFwiVHJ1ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwcmludF9ub25lOiBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheShcIk5vbmVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJ1bkJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicnVuXCIpO1xyXG4gICAgICAgIHVzZXJDb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ1c2VyLWNvZGVcIik7XHJcbiAgICAgICAgcnVuQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcHJvZ3JhbSwgb3V0cHV0LCB3YXQsIGNvZGUsIHJlc3VsdCwgZV8xO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmFtID0gdXNlckNvZGUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3V0cHV0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXQgPSBjb21waWxlcl8xLmNvbXBpbGUocHJvZ3JhbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdlbmVyYXRlZC1jb2RlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLnRleHRDb250ZW50ID0gd2F0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb21waWxlcl8xLnJ1bih3YXQsIGltcG9ydE9iamVjdCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQudGV4dENvbnRlbnQgKz0gU3RyaW5nKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImNvbG9yOiBibGFja1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZV8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRleHRDb250ZW50ID0gU3RyaW5nKGVfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImNvbG9yOiByZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdXNlckNvZGUudmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInByb2dyYW1cIik7XHJcbiAgICAgICAgdXNlckNvZGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleXByZXNzXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwicHJvZ3JhbVwiLCB1c2VyQ29kZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pOyB9KTtcclxuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICB9KTtcclxufSk7IH0pO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHdhYnQ7IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZVxuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbl9fd2VicGFja19yZXF1aXJlX18oXCIuL3dlYnN0YXJ0LnRzXCIpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==
